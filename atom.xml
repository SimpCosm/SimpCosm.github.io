<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houmin</title>
  
  <subtitle>Yesterday You Said Tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://houmin.cc/"/>
  <updated>2020-09-10T05:23:07.241Z</updated>
  <id>http://houmin.cc/</id>
  
  <author>
    <name>Houmin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Kubernetes解读】Ingress</title>
    <link href="http://houmin.cc/posts/8dfd4de5/"/>
    <id>http://houmin.cc/posts/8dfd4de5/</id>
    <published>2020-08-19T12:52:45.000Z</published>
    <updated>2020-09-10T05:23:07.241Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Ingress 是 Kubernetes 的一种 API 对象，将集群内部的 Service 通过 HTTP/HTTPS 方式暴露到集群外部，并通过规则定义 HTTP/HTTPS 的路由。Ingress 具备如下特性：集群外部可访问的 URL、负载均衡、SSL Termination、按域名路由。</p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Kubernetes 暴露服务的有三种方式：分别为 LoadBlancer Service、NodePort Service、Ingress。</p><p>LoadBlancer Service 是 Kubernetes 结合云平台的组件，如国外 GCE、AWS、国内阿里云等等，使用它向使用的底层云平台申请创建负载均衡器来实现，有局限性，对于使用云平台的集群比较方便，但是和云平台强绑定。</p><p>NodePort Service 是通过在节点上暴露端口，然后通过将端口映射到具体某个服务上来实现服务暴露，比较直观方便，但是对于集群来说，随着 Service 的不断增加，需要的端口越来越多，很容易出现端口冲突，而且不容易管理。此外，打开节点的端口，也会面临安全上的风险，生产环境并不推荐使用。</p><p>Ingress 作为 Kubernetes 基本API对象，是外部请求访问集群的入口，负责为进入集群的请求提供路由规则集合和转发，将外部的请求转发到集群内部Service上。相对于上述两种暴露方式，有以下特点：</p><ul><li>动态配置服务：增加新的服务时，不再需要在流量入口新增反向代理指向新的服务，只需配置好Ingress即可</li><li>减少不必要端口暴露：只需要将Ingress服务映射出去，即可代理所有后端服务，更加安全，便于管理端口</li></ul><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><h3 id="组成模块"><a href="#组成模块" class="headerlink" title="组成模块"></a>组成模块</h3><p>Ingress 通过反向代理负载均衡服务器实现对外暴露服务目的，一般有三个组件组成：</p><ul><li>反向代理负载均衡服务器<strong>：拦截外部请求，通常以 <code>Deployment</code> 或者 <code>DaemonSet</code> 的方式部署到集群中，常见的有 <code>Nginx</code>、<code>Apache</code>、<code>Traefik</code>等。</strong></li><li><strong>Ingress</strong>：定义路由规则，将路由配置抽象成一个 Ingress 对象。</li><li><strong>Ingress Controller</strong>：实时监控集群，获取 <code>Service</code> 、<code>Pod</code>和 <code>Ingress</code>等的变化，将 Ingress 的规则动态更新到反向代理负载均衡服务器上，刷新其路由配置信息，实现 <strong>服务发现</strong>。</li></ul><p><img alt="Kubernetes Ingress" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-31_k8s-ingress.png"></p><h3 id="语法详解"><a href="#语法详解" class="headerlink" title="语法详解"></a>语法详解</h3><p>下面是一个Ingress资源示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/testpath</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"foo.bar.com"</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/bar"</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"*.foo.com"</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/foo"</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>与所有其他 Kubernetes 资源一样，Ingress 需要使用 <code>apiVersion</code>、<code>kind</code> 和 <code>metadata</code> 字段。 Ingress 对象的命名必须是合法的 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names" target="_blank" rel="external nofollow noopener noreferrer">DNS 子域名名称</a>。  Ingress 经常使用注解（annotations）来配置一些选项，具体取决于 Ingress 控制器， 不同的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="external nofollow noopener noreferrer">Ingress 控制器</a> 支持不同的注解。</p><p>Ingress <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status" target="_blank" rel="external nofollow noopener noreferrer">规约</a> 提供了配置负载均衡器或者代理服务器所需的所有信息。 最重要的是，其中包含与所有传入请求匹配的规则列表。 <strong>Ingress 资源仅支持用于转发 HTTP 流量的规则。</strong></p><h4 id="Ingress-Rules"><a href="#Ingress-Rules" class="headerlink" title="Ingress Rules"></a>Ingress Rules</h4><p>每个 HTTP 规则都包含以下信息：</p><ul><li>可选主机。在此示例第一个规则中，未指定主机，因此该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了主机（例如 foo.bar.com），则规则适用于该主机。</li><li>路径列表（例如，<code>/testpath</code>）,每个路径都有一个由 <code>serviceName</code> 和 <code>servicePort</code> 定义的关联后端。 在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。</li><li>后端是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">Service 文档</a>中所述的服务和端口名称的组合。 与规则的主机和路径匹配的对 Ingress 的 HTTP（和 HTTPS ）请求将发送到列出的后端。</li></ul><p>通常在 Ingress 控制器中会配置默认后端，以服务任何不符合规范中路径的请求。</p><h4 id="DefaultBackend"><a href="#DefaultBackend" class="headerlink" title="DefaultBackend"></a>DefaultBackend</h4><p>没有规则的 Ingress 将所有流量发送到同一个默认后端。 默认后端通常是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="external nofollow noopener noreferrer">Ingress 控制器</a> 的配置选项，并且未在 Ingress 资源中指定。</p><p>如果主机或路径都没有与 Ingress 对象中的 HTTP 请求匹配，则流量将路由到默认后端。</p><h3 id="Path-Types"><a href="#Path-Types" class="headerlink" title="Path Types"></a>Path Types</h3><p>Ingress 中的每个路径都有对应的路径类型。当前支持的路径类型有三种：</p><ul><li><em><code>ImplementationSpecific</code></em> （默认）：对于这种类型，匹配取决于 IngressClass。 具体实现可以将其作为单独的 <code>pathType</code> 处理或者与 <code>Prefix</code> 或 <code>Exact</code> 类型作相同处理。</li><li><em><code>Exact</code></em>：精确匹配 URL 路径，且对大小写敏感。</li><li><em><code>Prefix</code></em>：基于以 <code>/</code> 分隔的 URL 路径前缀匹配。匹配对大小写敏感，并且对路径中的元素逐个完成。 路径元素指的是由 <code>/</code> 分隔符分隔的路径中的标签列表。 如果每个 <em>p</em> 都是请求路径 <em>p</em> 的元素前缀，则请求与路径 <em>p</em> 匹配。</li></ul><h2 id="Traefik实战"><a href="#Traefik实战" class="headerlink" title="Traefik实战"></a>Traefik实战</h2><p><code>Traefik</code>是一个用Go语言开发的轻量级的Http反向代理和<a href="https://cloud.tencent.com/product/clb?from=10680" target="_blank" rel="external nofollow noopener noreferrer">负载均衡</a>器，能够监听后端的变化并自动更新服务配置。它的特点如下：</p><ul><li>天然拥抱<code>kubernetes</code>，直接与集群k8s的<code>Api Server</code>通信，反应非常迅速，实时感知集群中<code>Ingress</code>定义的路由规则集合和后端<code>Service</code>、<code>Pod</code>的变化，自动<strong>热更新</strong><code>Traefik</code>后端配置，根本不用创建<code>Ingress controller</code>对象</li><li>提供了友好的控制面板和监控界面，不仅可以方便地查看<code>Traefik</code>根据<code>Ingress</code>生成的路由配置信息，还可以查看统计的一些性能指标数据</li><li>支持丰富的<code>annotations</code>配置，可配置众多出色的特性，例如：<strong>自动熔断</strong>、<strong>负载均衡策略</strong>、<strong>黑名单</strong>、<strong>白名单</strong></li><li>支持许多后端存储，如：zookeeper、eureka、consul、rancher、docker等，它会自动感知这些统一配置中心的变化，热更新自己的路由配置</li></ul><p><a href="https://www.infoq.cn/article/2glSpfgdiwG0UYz3V4tM" target="_blank" rel="external nofollow noopener noreferrer">如何在 K8S 集群中部署 Traefik Ingress Controller</a> 详细介绍了如何在 k8s 集群部署 Traefik Ingress Controller 的详细过程，本文在此复现其操作。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>在本文的后半部分，我将演示如何在一个 Kubernetes 集群部署 Traefik 作为 Ingress Controller，同时使用 Ingress 实现按域名路由和流量分配。在此之前，你需要一个已经部署成功的 Kubernetes 集群和一个能够与集群通信的kubectl 工具。</p><blockquote><p>软文时间：你可以在MiniKube创建运行 Kubernetes 集群，也欢迎使用腾讯云的TKE容器服务，快速实现1分钟内自动创建好 Kubernetes 集群。</p></blockquote><h3 id="启用RBAC"><a href="#启用RBAC" class="headerlink" title="启用RBAC"></a>启用RBAC</h3><p>为了能够使 Traefik 能够访问集群中运行的 Pod、Endpoint、Ingress和 Service等资源，需要向 Traefik 授予一些权限。这里我们创建了一个具有一组权限的ClusterRole，授予其管理和监视集群中所有命名空间的资源。同时，我们创建一个新的ServiceAccount，为Traefik 提供集群中的身份。最后，通过 ClusterRoleBinding 将二者绑定在一起。</p><figure class="highlight yaml"><figcaption><span>rbac.yam</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">extensions</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ingresses</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><p>在命令行执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f rbac.yaml</span></span><br><span class="line">serviceaccount/traefik-ingress created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/traefik-ingress created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/traefik-ingress created</span><br></pre></td></tr></table></figure><h3 id="部署Traefik"><a href="#部署Traefik" class="headerlink" title="部署Traefik"></a>部署Traefik</h3><p>官方 Traefik 文档支持三种类型的部署：使用 Deployment 对象、使用 DaemonSet 对象或使用 Helm Chart。这里我们使用 Deployment manifest。</p><figure class="highlight yaml"><figcaption><span>deployment.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">traefik-ingress</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">traefik:v1.7.16</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--api</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubernetes</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--logLevel=INFO</span></span><br></pre></td></tr></table></figure><p>在命令行执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f deployment.yaml</span></span><br><span class="line">deployment.extensions/traefik-ingress created</span><br><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl get pods -n kube-system</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">traefik-ingress-56f459f5cb-psrhr    1/1     Running   0          16s</span><br></pre></td></tr></table></figure><h3 id="为外部访问创建NodePorts"><a href="#为外部访问创建NodePorts" class="headerlink" title="为外部访问创建NodePorts"></a>为外部访问创建NodePorts</h3><p>接下来创建一个服务来从集群外部访问 Traefik，这里我们只暴露Traefik给外部，其他的内部服务都可以通过定义Ingress规则来通过 Traefik 暴露出来，极大避免了 NodePort的冲突。在实际生产环境中，这里的 NodePort 可以替换成云服务商提供的LB。</p><figure class="highlight yaml"><figcaption><span>service.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>在命令行执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl create -f service.yaml</span></span><br><span class="line">service/traefik-ingress-service created</span><br><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl get svc -n kube-system</span></span><br><span class="line">NAME                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                       AGE</span><br><span class="line">hpa-metrics-service       ClusterIP   172.18.254.168   &lt;none&gt;        443/TCP                       51d</span><br><span class="line">kube-dns                  ClusterIP   172.18.253.26    &lt;none&gt;        53/TCP,53/UDP                 51d</span><br><span class="line">traefik-ingress-service   NodePort    172.18.253.6     &lt;none&gt;        80:30993/TCP,8080:31846/TCP   2s</span><br></pre></td></tr></table></figure><p>这个时候，已经可以在浏览器访问 Traefik 服务了，在浏览器输入 <code>http://&lt;NodeIP&gt;:&lt;AdminNodePort&gt;</code> 就可以看到 Traefik 的 WebUI了。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-access.png"></p><p>这个时候WebUI还没有管理任何Ingress，接下来我们创建Ingress。</p><h3 id="实现按域名的路由"><a href="#实现按域名的路由" class="headerlink" title="实现按域名的路由"></a>实现按域名的路由</h3><figure class="highlight yaml"><figcaption><span>animals-ingress.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">animals</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">hare.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">hare</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">bear.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">bear</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">moose.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">moose</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure><p>在命令行执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl create -f animals-ingress.yaml</span></span><br><span class="line">ingress.extensions/animals created</span><br></pre></td></tr></table></figure><p>这个时候只创建了 Ingress，还没有创建 Frontend 的 Service 和后端服务的 EndPoint，查看Traefik看到</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-ingress.png"></p><p>创建对应的 Service：</p><figure class="highlight yaml"><figcaption><span>animals-service.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">traefik.backend.circuitbreaker:</span> <span class="string">"NetworkErrorRatio() &gt; 0.5"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">hare</span></span><br></pre></td></tr></table></figure><p>在命令行执行命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@VM-1-28-centos</span> <span class="string">traefik]#</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">animals-service.yaml</span></span><br><span class="line"><span class="string">service/bear</span> <span class="string">created</span></span><br><span class="line"><span class="string">service/moose</span> <span class="string">created</span></span><br><span class="line"><span class="string">service/hare</span> <span class="string">created</span></span><br></pre></td></tr></table></figure><p>这个时候 Ingress 中 Frontend 对应的 Service已经正常工作，但是 Backend 的EndPoint还没有就绪：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-service.png"></p><p>修改本机Host，添加记录如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">NodeIP</span>&gt; <span class="selector-tag">hare</span><span class="selector-class">.houmin</span> <span class="selector-tag">moose</span><span class="selector-class">.houmin</span> <span class="selector-tag">bear</span><span class="selector-class">.houmin</span></span><br></pre></td></tr></table></figure><p>这个时候在浏览器访问 <code>http://hare.houmin:&lt;WebNodePort&gt;</code>，在这里 <code>WebNodePort</code> 也就对应于 30993，显示 <code>Service Unavailable</code>。符合预期，因为Backend的Endpoint还没有起来。</p><p>创建对应的 Deployment：</p><figure class="highlight yaml"><figcaption><span>animals-deployment.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">bear</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:bear</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">moose</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:moose</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">hare</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">hare</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:hare</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在命令行中执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f animals-deployment.yaml</span></span><br><span class="line">deployment.extensions/bear created</span><br><span class="line">deployment.extensions/moose created</span><br><span class="line">deployment.extensions/hare created</span><br></pre></td></tr></table></figure><p><img alt="查看WebUI，显示后端EndPoint服务已就绪" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-endpoint.png"></p><p>这个是否分别访问Bear、Hare和Moose服务：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-bear.png"></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-hare.png"></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-moose.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ingress 是 Kubernetes 的一种 API 对象，将集群内部的 Service 通过 HTTP/HTTPS 方式暴露到集群外部，并通过规则定义 HTTP/HTTPS 的路由。Ingress 具备如下特性：集群外部可访问的 URL、负载均衡、SSL Termination、按域名路由。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-31_k8s-ingress.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="ingress" scheme="http://houmin.cc/tags/ingress/"/>
    
      <category term="service" scheme="http://houmin.cc/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】Service</title>
    <link href="http://houmin.cc/posts/cfed77f0/"/>
    <id>http://houmin.cc/posts/cfed77f0/</id>
    <published>2020-08-18T12:37:46.000Z</published>
    <updated>2020-08-31T06:23:27.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes 中的 Service 将一组 Pod 以统一的形式对外暴露成一个服务，它利用运行在内核空间的 iptables 或者 ipvs 高效地转发来自节点内部和外部的流量。作为非常重要的 Kubernetes 对象，Service 不仅在逻辑上提供了微服务的概念，还引入 LoadBalancer 类型的 Service 无缝对接云服务商提供的复杂资源。</p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>我们知道，Kubernetes 中的每一个 Pod 都可以通过 <code>podIP</code> 被直接访问，但是 Pod 是有生命周期的对象，它们可以被创建，而且销毁之后不会再启动。如果 <code>Deployment</code>、<code>ReplicaSet</code> 等对象管理 Pod，则它们可以动态地创建和销毁 Pod。在这种情况下，<code>Deployment</code>当前时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。</p><p>这就造成了一个问题，如果一组backend Pod 为集群中的另一组frontend Pod 提供服务时，由于每一个 Pod 都有自己的IP地址，并且这组Pod是会动态变化的，那么Frontend如何做服务发现以及会话保持，从而可以使用 Backend Pod 的服务？</p><p>为了解决这个问题，Kubernetes提出了 Service 这个概念：Service 是一组 Pod的逻辑集合和访问方式的抽象。举个例子，考虑一个图片处理后端，它运行了 3 个副本。这些副本是可互换的 —— 前端不需要关心它们调用了哪个后端副本。 然而组成这一组后端程序的 Pod 实际上可能会发生变化， 前端客户端不应该也没必要知道，而且也不需要跟踪这一组后端的状态。 Service 定义的抽象能够解耦这种关联。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>下面是一个 Service 的典型定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>这里注意几个Port的定义区分：</p><ul><li>port：service暴露在cluster ip上的端口，<code>&lt;cluster ip&gt;:port</code> 是提供给集群内部客户访问service的入口</li><li>targetPort：Pod监听的端口，service会把流量转发到对应的Pod，Pod中的容器也需要监听这个端口</li><li>nodePort：对应于NodePort类型的Service时指定的节点上的Port，详见 <a href="#NodePort">NodePort</a></li></ul><p>在命令行中可以看到集群为Service创建了一个 <code>ClusterIP</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos nginx]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">nginx         ClusterIP   172.18.255.55    &lt;none&gt;        8080/TCP   5s</span><br></pre></td></tr></table></figure><p>创建 Nginx 实际对应的 Deployment：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>对应于实际服务请求的路径如下图所示：</p><p><img alt="Kubernetes Service" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-kube-proxy.png"></p><h2 id="Publish-Services"><a href="#Publish-Services" class="headerlink" title="Publish Services"></a>Publish Services</h2><p>Kubernetes 中支持四种服务暴露的方式： ClusterIP、NodePort、LoadBalancer、ExternelName</p><h3 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h3><p>ClusterIP 类型的 service 是 kubernetes 集群默认的服务暴露方式，它只能用于集群内部通信，可以被各 pod 访问，其访问方式为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod ---&gt; ClusterIP:ServicePort --&gt; (iptables)DNAT --&gt; PodIP:containePort</span><br></pre></td></tr></table></figure><p>ClusterIP Service 类型的结构如下图所示:</p><p><img alt="Cluster IP" data-src="https://upload-images.jianshu.io/upload_images/1262158-875870767bdb199d.png"></p><h4 id="Headless-service"><a href="#Headless-service" class="headerlink" title="Headless service"></a>Headless service</h4><p>当不需要负载均衡以及单独的 ClusterIP 时，可以通过指定 <code>spec.clusterIP</code> 的值为 <code>None</code> 来创建 Headless service，它会给一个集群内部的每个成员提供一个唯一的 DNS 域名来作为每个成员的网络标识，集群内部成员之间使用域名通信。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">30080</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><p>如果想要在集群外访问集群内部的服务，可以使用这种类型的 service，NodePort 类型的 service 会在集群内部署了 kube-proxy 的每个节点打开一个指定的端口，之后所有的流量直接发送到这个端口，然后会被转发到 service 后端真实的服务进行访问。Nodeport 构建在 ClusterIP 上，其访问链路如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client ---&gt; NodeIP:NodePort ---&gt; ClusterIP:ServicePort ---&gt; (iptables)DNAT ---&gt; PodIP:containePort</span><br></pre></td></tr></table></figure><p>其对应具体的 iptables 规则会在后文进行讲解。</p><p>NodePort service 类型的结构如下图所示:</p><p><img alt="Node Port" data-src="https://upload-images.jianshu.io/upload_images/1262158-0873f8f59cb83a8c.png"></p><p>修改 service 定义如下，其中 <code>nodeport</code> 字段表示通过 nodeport 方式访问的端口，<code>port</code> 表示通过 service 方式访问的端口，<code>targetPort</code> 表示 pod port。如果这里的 <code>nodePort</code> 字段不指定，Kubernetes会自动申请一个Node Port。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="comment"># By default and for convenience, the `targetPort` is set to the same value as the `port` field.</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="comment"># Optional field</span></span><br><span class="line">    <span class="comment"># By default and for convenience, the Kubernetes control plane will allocate a port from a range (default: 30000-32767)</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30080</span></span><br></pre></td></tr></table></figure><p>执行 <code>kubectl get service</code> 可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx         NodePort    172.18.252.115   &lt;none&gt;        80:30080/TCP   20s</span><br></pre></td></tr></table></figure><p>这时候，在浏览器中选择集群中任意一节点的IP作为 <code>nodeIP</code>，通过浏览器 <code>http://&lt;nodeIP&gt;:&lt;nodePort&gt;</code> 可以看到 Nginx 的欢迎界面。</p><h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><p>LoadBalancer 类型的 service 通常和云厂商的 LB 结合一起使用，用于将集群内部的服务暴露到外网，云厂商的 LoadBalancer 会给用户分配一个 IP，之后通过该 IP 的流量会转发到你的 service 上。</p><p>LoadBalancer service 类型的结构如下图所示:</p><p><img alt="Load Balancer" data-src="https://upload-images.jianshu.io/upload_images/1262158-6f8d3d4c58adeeca.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.0</span><span class="number">.171</span><span class="number">.239</span></span><br><span class="line">  <span class="attr">loadBalancerIP:</span> <span class="number">78.11</span><span class="number">.24</span><span class="number">.19</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">146.148</span><span class="number">.47</span><span class="number">.155</span></span><br></pre></td></tr></table></figure><h3 id="ExternelName"><a href="#ExternelName" class="headerlink" title="ExternelName"></a>ExternelName</h3><p>类型为 ExternalName 的服务将服务映射到 DNS 名称，而不是典型的选择器，例如 <code>my-service</code> 或者 <code>cassandra</code>。 您可以使用 <code>spec.externalName</code> 参数指定这些服务。</p><p>例如，以下 Service 定义将 <code>prod</code> 名称空间中的 <code>my-service</code> 服务映射到 <code>my.database.example.com</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">my.database.example.com</span></span><br></pre></td></tr></table></figure><p>当查找主机 <code>my-service.prod.svc.cluster.local</code> 时，集群 DNS 服务返回 <code>CNAME</code> 记录， 其值为 <code>my.database.example.com</code>。 访问 <code>my-service</code> 的方式与其他服务的方式相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发。 如果以后您决定将数据库移到群集中，则可以启动其 Pod，添加适当的选择器或端点以及更改服务的 <code>type</code>。</p><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><p>Service 是一组具有相同 label pod 集合的抽象，集群内外的各个服务可以通过 service 进行互相通信。在 Kubernetes 中创建一个新的 Service 对象需要两大模块同时协作:</p><ul><li>Controller：在每次创建新的 Service 对象时，会同时创建一个 Endpoint 对象。Endpoint 是用于<strong>容器发现</strong>，Service 只是将多个 Pod 进行关联。Endpoints Controller 是负责生成和维护所有 Endpoints 对象的控制器，监听 Service 和对应 Pod 的变化，更新对应 Service 的 Endpoints 对象。当 Pod 处于 running 且准备就绪时，Endpoints Controller 会将 Pod IP 记录到 Endpoints 对象中。</li><li>kube-proxy：它运行在 Kubernetes 集群中的每一个节点上，会根据 Service 和 Endpoint 的变动改变节点上 iptables 或者 ipvs 中保存的规则。</li></ul><p><img alt="Kubernetes Service" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-service.png"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>每当有服务被创建或者销毁时，Informer 都会通知 <code>ServiceController</code>，它会将这些任务投入工作队列中并由其本身启动的 Worker 协程消费：</p><pre class="mermaid">sequenceDiagram    participant I as Informer    participant SC as ServiceController    participant Q as WorkQueue    participant B as Balancer    I->>+SC: Add/Update/DeleteService    SC->>Q: Add    Q-->>SC: return    deactivate SC    loop Worker        SC->>+Q: Get        Q-->>-SC: key        SC->>SC: syncService        SC->>+B: EnsureLoadBalancer        B-->>-SC: LoadBalancerStatus    end</pre><h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>我们在使用 Kubernetes 时虽然很少会直接与 Endpoint 资源打交道，但是它却是 Kubernetes 中非常重要的组成部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endpoints is a collection of endpoints that implement the actual service.  Example:</span></span><br><span class="line"><span class="comment">//   Name: "mysvc",</span></span><br><span class="line"><span class="comment">//   Subsets: [</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       Addresses: [&#123;"ip": "10.10.1.1"&#125;, &#123;"ip": "10.10.2.2"&#125;],</span></span><br><span class="line"><span class="comment">//       Ports: [&#123;"name": "a", "port": 8675&#125;, &#123;"name": "b", "port": 309&#125;]</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       Addresses: [&#123;"ip": "10.10.3.3"&#125;],</span></span><br><span class="line"><span class="comment">//       Ports: [&#123;"name": "a", "port": 93&#125;, &#123;"name": "b", "port": 76&#125;]</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//  ]</span></span><br><span class="line"><span class="keyword">type</span> Endpoints <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta</span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line"><span class="comment">// The set of all endpoints is the union of all subsets.</span></span><br><span class="line">Subsets []EndpointSubset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EndpointSubset is a group of addresses with a common set of ports.  The</span></span><br><span class="line"><span class="comment">// expanded set of endpoints is the Cartesian product of Addresses x Ports.</span></span><br><span class="line"><span class="comment">// For example, given:</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     Addresses: [&#123;"ip": "10.10.1.1"&#125;, &#123;"ip": "10.10.2.2"&#125;],</span></span><br><span class="line"><span class="comment">//     Ports:     [&#123;"name": "a", "port": 8675&#125;, &#123;"name": "b", "port": 309&#125;]</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// The resulting set of endpoints can be viewed as:</span></span><br><span class="line"><span class="comment">//     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],</span></span><br><span class="line"><span class="comment">//     b: [ 10.10.1.1:309, 10.10.2.2:309 ]</span></span><br><span class="line"><span class="keyword">type</span> EndpointSubset <span class="keyword">struct</span> &#123;</span><br><span class="line">Addresses         []EndpointAddress</span><br><span class="line">NotReadyAddresses []EndpointAddress</span><br><span class="line">Ports             []EndpointPort</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>While you’re correct that in the <a href="https://kubernetes.io/docs/reference/glossary" target="_blank" rel="external nofollow noopener noreferrer">glossary</a> there’s indeed no entry for endpoint, it is a well defined Kubernetes network concept or abstraction. Since it’s of secondary nature, you’d usually not directly manipulate it. There’s a core resource <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#endpoints-v1-core" target="_blank" rel="external nofollow noopener noreferrer">Endpoint</a> defined and it’s also supported on the command line:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="keyword">get</span> ep</span><br><span class="line">NAME         ENDPOINTS            AGE</span><br><span class="line">kubernetes   <span class="number">192.168</span><span class="number">.64</span><span class="number">.13</span>:<span class="number">8443</span>   <span class="number">10</span>d</span><br></pre></td></tr></table></figure><p>And there you see what it effectively is: an IP address and a port. Usually, you’d let a service manage endpoints (one EP per pod the service routes traffic to) but you can also <a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="external nofollow noopener noreferrer">manually manage</a> them if you have a use case that requires it.</p><p>  服务和pod不是直接连接，而是通过<strong>Endpoint资源</strong>进行连通。endpoint资源是暴露<strong>一个服务的ip地址和port的列表。</strong>  选择器用于构建ip和port列表，然后存储在endpoint资源中。当客户端连接到服务时，服务代理选择这些列表中的ip和port对中的一个，并将传入连接重定向到在该位置监听的服务器。  endpoint是一个单独的资源并不是服务的属性，<strong>endpoint的名称必须和服务的名称相匹配</strong>。</p><h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>  为没有选择器的服务创建endpoint资源： <code>$ kubectl create -f endpoint.yml</code>  endpoint对象需要与服务相同的名称，并包含该服务的目标ip和port列表，服务和endpoint资源都发布到服务器后，这样服务就可以像具有pod选择器那样的服务正常使用。</p><p><img alt="endpoint yml 模板" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/1"></p></blockquote><p><code>EndpointController</code> 本身并没有通过 <code>Informer</code> 监听 Endpoint 资源的变动，但是它却同时订阅了 Service 和 Pod 资源的增删事件，对于 Service 资源来讲，<code>EndpointController</code> 会通过以下的方式进行处理：</p><pre class="mermaid">sequenceDiagram    participant I as Informer    participant EC as EndpointController    participant Q as WorkQueue    participant PL as PodLister    participant C as Client    I->>+EC: Add/Update/DeleteService    EC->>Q: Add    Q-->>EC: return    loop Worker        EC->>+Q: Get        Q-->>-EC: key        EC->>+EC: syncService        EC->>+PL: ListPod(service.Spec.Selector)        PL-->>-EC: Pods        loop Every Pod            EC->>EC: addEndpointSubset        end        EC->>C: Create/UpdateEndpoint        C-->>-EC: result    end</pre><p><code>EndpointController</code> 中的 <code>syncService</code> 方法是用于创建和删除 Endpoint 资源最重要的方法，在这个方法中我们会根据 Service 对象规格中的选择器 Selector 获取集群中存在的所有 Pod，并将 Service 和 Pod 上的端口进行映射生成一个 <code>EndpointPort</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">syncService</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">namespace, name, _ := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">service, _ := e.serviceLister.Services(namespace).Get(name)</span><br><span class="line">pods, _ := e.podLister.Pods(service.Namespace).List(labels.Set(service.Spec.Selector).AsSelectorPreValidated())</span><br><span class="line"></span><br><span class="line">subsets := []v1.EndpointSubset&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">epa := *podToEndpointAddress(pod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> service.Spec.Ports &#123;</span><br><span class="line">servicePort := &amp;service.Spec.Ports[i]</span><br><span class="line"></span><br><span class="line">portName := servicePort.Name</span><br><span class="line">portProto := servicePort.Protocol</span><br><span class="line">portNum, _ := podutil.FindPort(pod, servicePort)</span><br><span class="line"></span><br><span class="line">epp := &amp;v1.EndpointPort&#123;Name: portName, Port: <span class="keyword">int32</span>(portNum), Protocol: portProto&#125;</span><br><span class="line">subsets, _, _ = addEndpointSubset(subsets, pod, epa, epp, tolerateUnreadyEndpoints)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">subsets = endpoints.RepackSubsets(subsets)</span><br><span class="line"></span><br><span class="line">currentEndpoints = &amp;v1.Endpoints&#123;</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name:   service.Name,</span><br><span class="line">Labels: service.Labels,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newEndpoints := currentEndpoints.DeepCopy()</span><br><span class="line">newEndpoints.Subsets = subsets</span><br><span class="line">newEndpoints.Labels = service.Labels</span><br><span class="line">e.client.CoreV1().Endpoints(service.Namespace).Create(newEndpoints)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个 Pod 都会生成一个新的 <code>EndpointSubset</code>，其中包含了 Pod 的 IP 地址和端口和 Service 的规格中指定的输入端口和目标端口，在最后 <code>EndpointSubset</code> 的数据会被重新打包并通过客户端创建一个新的 Endpoint 资源。</p><p>在上面我们已经提到过，除了 Service 的变动会触发 Endpoint 的改变之外，Pod 对象的增删也会触发 <code>EndpointController</code> 中的回调函数。</p><pre class="mermaid">sequenceDiagram    participant I as Informer    participant EC as EndpointController    participant Q as WorkQueue    participant SL as ServiceLister    I->>+EC: Add/Update/DeletePod    EC->>+SL: GetPodServices    SL-->>-EC: []Service    EC->>Q: Add    Q-->>EC: return    deactivate EC</pre><p><code>getPodServiceMemberships</code> 会获取跟当前 Pod 有关的 Service 对象并将所有的 Service 对象都转换成 <code>&lt;namespace&gt;/&lt;name&gt;</code> 的字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">getPodServiceMemberships</span><span class="params">(pod *v1.Pod)</span> <span class="params">(sets.String, error)</span></span> &#123;</span><br><span class="line">set := sets.String&#123;&#125;</span><br><span class="line">services, _ := e.serviceLister.GetPodServices(pod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> services &#123;</span><br><span class="line">key, _ := controller.KeyFunc(services[i])</span><br><span class="line">set.Insert(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些服务最后会被加入 <code>EndpointController</code> 的队列中，等待它持有的几个 Worker 对 Service 进行同步。</p><p>这些其实就是 <code>EndpointController</code> 的作用，订阅 Pod 和 Service 对象的变更，并根据当前集群中的对象生成 Endpoint 对象将两者进行关联。</p><h2 id="Proxy-Mode"><a href="#Proxy-Mode" class="headerlink" title="Proxy Mode"></a>Proxy Mode</h2><p>在 Kubernetes 集群中的每一个节点都运行着一个 kube-proxy 进程，这个进程会负责监听 Kubernetes 主节点中 Service 的增加和删除事件并修改运行代理的配置，为节点内的客户端提供流量的转发和负载均衡等功能。在整个集群中另一个订阅 Service 对象变动的组件就是 kube-proxy 了，每当 kube-proxy 在新的节点上启动时都会初始化一个 <code>ServiceConfig</code> 对象，就像介绍 iptables 代理模式时提到的，这个对象会接受 Service 的变更事件：</p><pre class="mermaid">sequenceDiagram    participant SCT as ServiceChangeTracker    participant SC as ServiceConfig    participant P as Proxier    participant EC as EndpointConfig    participant ECT as EndpointChangeTracker    participant SR as SyncRunner    SC->>+P: OnServiceAdd/Update/Delete/Synced    P->>SCT: Update    SCT-->>P: Return ServiceMap    deactivate P    EC->>+P: OnEndpointsAdd/Update/Delete/Synced    ECT-->>P: Return EndpointMap    P->>ECT: Update    deactivate P    loop Every minSyncPeriod ~ syncPeriod        SR->>P: syncProxyRules    end</pre><p>这些变更事件都会被订阅了集群中对象变动的 <code>ServiceConfig</code> 和 <code>EndpointConfig</code> 对象推送给启动的 <code>Proxier</code> 实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceConfig)</span> <span class="title">handleAddService</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">service, ok := obj.(*v1.Service)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.eventHandlers &#123;</span><br><span class="line">c.eventHandlers[i].OnServiceAdd(service)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到事件变动的 <code>Proxier</code> 实例随后会根据启动时的配置更新 iptables 或者 ipvs 中的规则，这些应用最终会负责对进出的流量进行转发并完成一些负载均衡相关的任务。</p><h3 id="Userspace"><a href="#Userspace" class="headerlink" title="Userspace"></a>Userspace</h3><p>作为运行在用户空间的代理，对于每一个 Service 都会在当前的节点上开启一个端口，所有连接到当前代理端口的请求都会被转发到 Service 背后的一组 Pod 上，它其实会在节点上添加 iptables 规则，通过 iptables 将流量转发给 kube-proxy 处理。</p><p>如果当前节点上的 kube-proxy 在启动时选择了 userspace 模式，那么每当有新的 Service 被创建时，kube-proxy 就会增加一条 iptables 记录并启动一个 Goroutine，前者用于将节点中服务对外发出的流量转发给 kube-proxy，再由后者持有的一系列 Goroutine 将流量转发到目标的 Pod 上。</p><p>在 userspace 模式下，访问服务的请求到达节点后首先进入内核 iptables，然后回到用户空间，由 kube-proxy 转发到后端的 pod，这样流量从用户空间进出内核带来的性能损耗是不可接受的，所以也就有了 iptables 模式。</p><p>为什么 userspace 模式要建立 iptables 规则，因为 kube-proxy 监听的端口在用户空间，这个端口不是服务的访问端口也不是服务的 nodePort，因此需要一层 iptables 把访问服务的连接重定向给 kube-proxy 服务。</p><p><img alt="Service Userspace Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-userspace.svg"></p><p>这一系列的工作大都是在 <code>OnServiceAdd</code> 被触发时中完成的，正如上面所说的，该方法会调用 <code>mergeService</code> 将传入服务 Service 的端口变成一条 iptables 的配置命令为当前节点增加一条规则，同时在 <code>addServiceOnPort</code> 方法中启动一个 TCP 或 UDP 的 Socket：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">mergeService</span><span class="params">(service *v1.Service)</span> <span class="title">sets</span>.<span class="title">String</span></span> &#123;</span><br><span class="line">svcName := types.NamespacedName&#123;Namespace: service.Namespace, Name: service.Name&#125;</span><br><span class="line">existingPorts := sets.NewString()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> service.Spec.Ports &#123;</span><br><span class="line">servicePort := &amp;service.Spec.Ports[i]</span><br><span class="line">serviceName := proxy.ServicePortName&#123;NamespacedName: svcName, Port: servicePort.Name&#125;</span><br><span class="line">existingPorts.Insert(servicePort.Name)</span><br><span class="line">info, exists := proxier.getServiceInfo(serviceName)</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">proxier.closePortal(serviceName, info)</span><br><span class="line">proxier.stopProxy(serviceName, info)</span><br><span class="line">&#125;</span><br><span class="line">proxyPort,  := proxier.proxyPorts.AllocateNext()</span><br><span class="line"></span><br><span class="line">serviceIP := net.ParseIP(service.Spec.ClusterIP)</span><br><span class="line">info, _ = proxier.addServiceOnPort(serviceName, servicePort.Protocol, proxyPort, proxier.udpIdleTimeout)</span><br><span class="line">info.portal.ip = serviceIP</span><br><span class="line">info.portal.port = <span class="keyword">int</span>(servicePort.Port)</span><br><span class="line">info.externalIPs = service.Spec.ExternalIPs</span><br><span class="line">info.loadBalancerStatus = *service.Status.LoadBalancer.DeepCopy()</span><br><span class="line">info.nodePort = <span class="keyword">int</span>(servicePort.NodePort)</span><br><span class="line">info.sessionAffinityType = service.Spec.SessionAffinity</span><br><span class="line"></span><br><span class="line">proxier.openPortal(serviceName, info)</span><br><span class="line">proxier.loadBalancer.NewService(serviceName, info.sessionAffinityType, info.stickyMaxAgeSeconds)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> existingPorts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个启动的进程会监听同一个节点上，转发自所有进程的 TCP 和 UDP 请求并将这些数据包发送给目标的 Pod 对象。</p><p>在用户空间模式中，如果一个连接被目标服务拒绝，我们的代理服务能够重新尝试连接其他的服务，除此之外用户空间模式并没有太多的优势。</p><h3 id="IPTables"><a href="#IPTables" class="headerlink" title="IPTables"></a>IPTables</h3><p>另一种常见的代理模式就是直接使用 iptables 转发当前节点上的全部流量，这种脱离了用户空间在内核空间中实现转发的方式能够极大地提高 proxy 的效率，增加 kube-proxy 的吞吐量。</p><p>iptables 模式是目前默认的代理方式，基于 netfilter 实现。当客户端请求 service 的 ClusterIP 时，根据 iptables 规则路由到各 pod 上，iptables 使用 DNAT 来完成转发，其采用了随机数实现负载均衡。</p><p>iptables 模式与 userspace 模式最大的区别在于，iptables 模块使用 DNAT 模块实现了 service 入口地址到 pod 实际地址的转换，免去了一次内核态到用户态的切换，另一个与 userspace 代理模式不同的是，如果 iptables 代理最初选择的那个 pod 没有响应，它不会自动重试其他 pod。</p><p>iptables 模式最主要的问题是在 service 数量大的时候会产生太多的 iptables 规则，使用非增量式更新会引入一定的时延，大规模情况下有明显的性能问题。</p><p><img alt="Service Iptables Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-iptables.svg"></p><p>iptables 作为一种代理模式，它同样实现了 <code>OnServiceUpdate</code>、<code>OnEndpointsUpdate</code> 等方法，这两个方法会分别调用相应的变更追踪对象。</p><pre class="mermaid">sequenceDiagram    participant SC as ServiceConfig    participant P as Proxier    participant SCT as ServiceChangeTracker    participant SR as SyncRunner    participant I as iptable    SC->>+P: OnServiceAdd    P->>P: OnServiceUpdate    P->>SCT: Update    SCT-->>P: Return ServiceMap    deactivate P    loop Every minSyncPeriod ~ syncPeriod        SR->>+P: syncProxyRules        P->>I: UpdateChain        P->>P: writeLine x N        P->>I: RestoreAll        deactivate P    end</pre><p>变更追踪对象会根据 <code>Service</code> 或 <code>Endpoint</code> 对象的前后变化改变 <code>ServiceChangeTracker</code> 本身的状态，这些变更会每隔一段时间通过一个 700 行的巨大方法 <code>syncProxyRules</code> 同步，在这里就不介绍这个方法的具体实现了，它的主要功能就是根据 <code>Service</code> 和 <code>Endpoint</code> 对象的变更生成一条一条的 iptables 规则，比较感兴趣的读者，可以点击 <a href="https://sourcegraph.com/github.com/kubernetes/kubernetes@master/-/blob/pkg/proxy/iptables/proxier.go#L640-1379" target="_blank" rel="external nofollow noopener noreferrer">proxier.go#L640-1379</a> 查看代码。</p><p>当我们使用 iptables 的方式启动节点上的代理时，所有的流量都会先经过 <code>PREROUTING</code> 或者 <code>OUTPUT</code> 链，随后进入 Kubernetes 自定义的链入口 KUBE-SERVICES、单个 Service 对应的链 <code>KUBE-SVC-XXXX</code> 以及每个 Pod 对应的链 <code>KUBE-SEP-XXXX</code>，经过这些链的处理，最终才能够访问当一个服务的真实 IP 地址。</p><p>虽然相比于用户空间来说，直接运行在内核态的 iptables 能够增加代理的吞吐量，但是当集群中的节点数量非常多时，iptables 并不能达到生产级别的可用性要求，每次对规则进行匹配时都会遍历 iptables 中的所有 Service 链。</p><p>规则的更新也不是增量式的，当集群中的 Service 达到 5,000 个，每增加一条规则都需要耗时 11min，当集群中的 Service 达到 20,000 个时，每增加一条规则都需要消耗 5h 的时间，这也就是告诉我们在大规模集群中使用 iptables 作为代理模式是完全不可用的。</p><h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>ipvs 就是用于解决在大量 Service 时，iptables 规则同步变得不可用的性能问题。与 iptables 比较像的是，ipvs 的实现虽然也基于 netfilter 的钩子函数，但是它却使用哈希表作为底层的数据结构并且工作在内核态，这也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能。</p><p><img alt="Service IPVS Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-ipvs.svg"></p><p>在处理 Service 的变化时，ipvs 包和 iptables 其实就有非常相似了，它们都同样使用 <code>ServiceChangeTracker</code> 对象来追踪变更，只是两者对于同步变更的方法 <code>syncProxyRules</code> 实现上有一些不同。</p><pre class="mermaid">sequenceDiagram    participant P as Proxier    participant SR as SyncRunner    participant IP as ipvs    participant I as iptable    loop Every minSyncPeriod ~ syncPeriod        SR->>+P: syncProxyRules        P->>P: writeLine(iptable)        P->>IP: Add/UpdateVirtualServer(syncService)        IP-->>P: result        P->>IP: AddRealServer(syncEndpoint)        IP-->>P: result        P->>I: RestoreAll        deactivate P    end</pre><p>我们从 ipvs 的源代码和上述的时序图中可以看到，Kubernetes ipvs 的实现其实是依赖于 iptables 的，后者能够辅助它完成一些功能，使用 ipvs 相比 iptables 能够减少节点上的 iptables 规则数量，这也是因为 ipvs 接管了原来存储在 iptables 中的规则。</p><p>除了能够提升性能之外，ipvs 也提供了多种类型的负载均衡算法，除了最常见的 Round-Robin 之外，还支持最小连接、目标哈希、最小延迟等算法，能够很好地提升负载均衡的效率。</p><p>当集群规模比较大时，iptables 规则刷新会非常慢，难以支持大规模集群，因其底层路由表的实现是链表，对路由规则的增删改查都要涉及遍历一次链表，ipvs 的问世正是解决此问题的，ipvs 是 LVS 的负载均衡模块，与 iptables 比较像的是，ipvs 的实现虽然也基于 netfilter 的钩子函数，但是它却使用哈希表作为底层的数据结构并且工作在内核态，也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能，几乎允许无限的规模扩张。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://xigang.github.io/2019/07/21/kubernetes-service/" target="_blank" rel="external nofollow noopener noreferrer">https://xigang.github.io/2019/07/21/kubernetes-service/</a></li><li><a href="https://www.cnblogs.com/passzhang/p/12544597.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/passzhang/p/12544597.html</a></li><li><a href="https://draveness.me/kubernetes-service/" target="_blank" rel="external nofollow noopener noreferrer">https://draveness.me/kubernetes-service/</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 中的 Service 将一组 Pod 以统一的形式对外暴露成一个服务，它利用运行在内核空间的 iptables 或者 ipvs 高效地转发来自节点内部和外部的流量。作为非常重要的 Kubernetes 对象，Service 不仅在逻辑上提供了微服务的概念，还引入 LoadBalancer 类型的 Service 无缝对接云服务商提供的复杂资源。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-kube-proxy.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="service" scheme="http://houmin.cc/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】Pod</title>
    <link href="http://houmin.cc/posts/b88b921f/"/>
    <id>http://houmin.cc/posts/b88b921f/</id>
    <published>2020-08-14T11:57:14.000Z</published>
    <updated>2020-08-21T08:11:30.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Pod</code> 是 Kubernetes 集群中能够被创建、调度和管理的最小部署单元，是一组容器的集合，是 k8s 中最简单的对象，也是 k8s 中最为基础的概念。同一个 Pod 中的容器可以共享同一个网络命名空间，IP地址和端口空间。从生命周期上来讲，Pod是短暂而不是长久的应用。Pod被调度到节点，保持在这个节点直到被摧毁。</p><p>本文将分两个部分对 Pod 解读，第一个部分介绍 Pod 的基本概念和常见特性，第二部分会从源码层面介绍 Pod 从创建到删除的整个生命周期的实现。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为 Kubernetes 集群中的基本单元，Pod 就是最小并且最简单的 Kubernetes 对象，这个简单的对象其实就能够独立启动一个后端进程并在集群的内部为调用方提供服务。在上一篇文章 <a href="https://draveness.me/kubernetes-object-intro" target="_blank" rel="external nofollow noopener noreferrer">从 Kubernetes 中的对象谈起</a> 中，我们曾经介绍过简单的 Kubernetes Pod 是如何使用 YAML 进行描述的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3600"</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>这个 YAML 文件描述了一个 Pod 启动时运行的容器和命令以及它的重启策略，在当前 Pod 出现错误或者执行结束后是否应该被 Kubernetes 的控制器拉起来，除了这些比较显眼的配置之外，元数据 <code>metadata</code> 的配置也非常重要，<code>name</code> 是当前对象在 Kubernetes 集群中的唯一标识符，而标签 <code>labels</code> 可以帮助我们快速选择对象。</p><p>在同一个 Pod 中，有几个概念特别值得关注，首先就是容器，在 Pod 中其实可以同时运行一个或者多个容器，这些容器能够共享网络、存储以及 CPU、内存等资源。在这一小节中我们将关注 Pod 中的容器、卷和网络三大概念。</p><h3 id="Pod-Spec"><a href="#Pod-Spec" class="headerlink" title="Pod Spec"></a>Pod Spec</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PodSpec is a description of a pod.</span></span><br><span class="line"><span class="keyword">type</span> PodSpec <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// List of volumes that can be mounted by containers belonging to the pod.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/storage/volumes</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge,retainKeys</span></span><br><span class="line">Volumes []Volume <span class="string">`json:"volumes,omitempty" patchStrategy:"merge,retainKeys" patchMergeKey:"name" protobuf:"bytes,1,rep,name=volumes"`</span></span><br><span class="line"><span class="comment">// List of initialization containers belonging to the pod.</span></span><br><span class="line"><span class="comment">// Init containers are executed in order prior to containers being started. If any</span></span><br><span class="line"><span class="comment">// init container fails, the pod is considered to have failed and is handled according</span></span><br><span class="line"><span class="comment">// to its restartPolicy. The name for an init container or normal container must be</span></span><br><span class="line"><span class="comment">// unique among all containers.</span></span><br><span class="line"><span class="comment">// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.</span></span><br><span class="line"><span class="comment">// The resourceRequirements of an init container are taken into account during scheduling</span></span><br><span class="line"><span class="comment">// by finding the highest request/limit for each resource type, and then using the max of</span></span><br><span class="line"><span class="comment">// of that value or the sum of the normal containers. Limits are applied to init containers</span></span><br><span class="line"><span class="comment">// in a similar fashion.</span></span><br><span class="line"><span class="comment">// Init containers cannot currently be added or removed.</span></span><br><span class="line"><span class="comment">// Cannot be updated.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">InitContainers []Container <span class="string">`json:"initContainers,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,20,rep,name=initContainers"`</span></span><br><span class="line"><span class="comment">// List of containers belonging to the pod.</span></span><br><span class="line"><span class="comment">// Containers cannot currently be added or removed.</span></span><br><span class="line"><span class="comment">// There must be at least one container in a Pod.</span></span><br><span class="line"><span class="comment">// Cannot be updated.</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">Containers []Container <span class="string">`json:"containers" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,2,rep,name=containers"`</span></span><br><span class="line"><span class="comment">// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing</span></span><br><span class="line"><span class="comment">// pod to perform user-initiated actions such as debugging. This list cannot be specified when</span></span><br><span class="line"><span class="comment">// creating a pod, and it cannot be modified by updating the pod spec. In order to add an</span></span><br><span class="line"><span class="comment">// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.</span></span><br><span class="line"><span class="comment">// This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">EphemeralContainers []EphemeralContainer <span class="string">`json:"ephemeralContainers,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,34,rep,name=ephemeralContainers"`</span></span><br><span class="line"><span class="comment">// Restart policy for all containers within the pod.</span></span><br><span class="line"><span class="comment">// One of Always, OnFailure, Never.</span></span><br><span class="line"><span class="comment">// Default to Always.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">RestartPolicy RestartPolicy <span class="string">`json:"restartPolicy,omitempty" protobuf:"bytes,3,opt,name=restartPolicy,casttype=RestartPolicy"`</span></span><br><span class="line"><span class="comment">// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.</span></span><br><span class="line"><span class="comment">// Value must be non-negative integer. The value zero indicates delete immediately.</span></span><br><span class="line"><span class="comment">// If this value is nil, the default grace period will be used instead.</span></span><br><span class="line"><span class="comment">// The grace period is the duration in seconds after the processes running in the pod are sent</span></span><br><span class="line"><span class="comment">// a termination signal and the time when the processes are forcibly halted with a kill signal.</span></span><br><span class="line"><span class="comment">// Set this value longer than the expected cleanup time for your process.</span></span><br><span class="line"><span class="comment">// Defaults to 30 seconds.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">TerminationGracePeriodSeconds *<span class="keyword">int64</span> <span class="string">`json:"terminationGracePeriodSeconds,omitempty" protobuf:"varint,4,opt,name=terminationGracePeriodSeconds"`</span></span><br><span class="line"><span class="comment">// Optional duration in seconds the pod may be active on the node relative to</span></span><br><span class="line"><span class="comment">// StartTime before the system will actively try to mark it failed and kill associated containers.</span></span><br><span class="line"><span class="comment">// Value must be a positive integer.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">ActiveDeadlineSeconds *<span class="keyword">int64</span> <span class="string">`json:"activeDeadlineSeconds,omitempty" protobuf:"varint,5,opt,name=activeDeadlineSeconds"`</span></span><br><span class="line"><span class="comment">// Set DNS policy for the pod.</span></span><br><span class="line"><span class="comment">// Defaults to "ClusterFirst".</span></span><br><span class="line"><span class="comment">// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.</span></span><br><span class="line"><span class="comment">// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.</span></span><br><span class="line"><span class="comment">// To have DNS options set along with hostNetwork, you have to specify DNS policy</span></span><br><span class="line"><span class="comment">// explicitly to 'ClusterFirstWithHostNet'.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">DNSPolicy DNSPolicy <span class="string">`json:"dnsPolicy,omitempty" protobuf:"bytes,6,opt,name=dnsPolicy,casttype=DNSPolicy"`</span></span><br><span class="line"><span class="comment">// NodeSelector is a selector which must be true for the pod to fit on a node.</span></span><br><span class="line"><span class="comment">// Selector which must match a node's labels for the pod to be scheduled on that node.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">NodeSelector <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`json:"nodeSelector,omitempty" protobuf:"bytes,7,rep,name=nodeSelector"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceAccountName is the name of the ServiceAccount to use to run this pod.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">ServiceAccountName <span class="keyword">string</span> <span class="string">`json:"serviceAccountName,omitempty" protobuf:"bytes,8,opt,name=serviceAccountName"`</span></span><br><span class="line"><span class="comment">// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.</span></span><br><span class="line"><span class="comment">// Deprecated: Use serviceAccountName instead.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">DeprecatedServiceAccount <span class="keyword">string</span> <span class="string">`json:"serviceAccount,omitempty" protobuf:"bytes,9,opt,name=serviceAccount"`</span></span><br><span class="line"><span class="comment">// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">AutomountServiceAccountToken *<span class="keyword">bool</span> <span class="string">`json:"automountServiceAccountToken,omitempty" protobuf:"varint,21,opt,name=automountServiceAccountToken"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,</span></span><br><span class="line"><span class="comment">// the scheduler simply schedules this pod onto that node, assuming that it fits resource</span></span><br><span class="line"><span class="comment">// requirements.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">NodeName <span class="keyword">string</span> <span class="string">`json:"nodeName,omitempty" protobuf:"bytes,10,opt,name=nodeName"`</span></span><br><span class="line"><span class="comment">// Host networking requested for this pod. Use the host's network namespace.</span></span><br><span class="line"><span class="comment">// If this option is set, the ports that will be used must be specified.</span></span><br><span class="line"><span class="comment">// Default to false.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">HostNetwork <span class="keyword">bool</span> <span class="string">`json:"hostNetwork,omitempty" protobuf:"varint,11,opt,name=hostNetwork"`</span></span><br><span class="line"><span class="comment">// Use the host's pid namespace.</span></span><br><span class="line"><span class="comment">// Optional: Default to false.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">HostPID <span class="keyword">bool</span> <span class="string">`json:"hostPID,omitempty" protobuf:"varint,12,opt,name=hostPID"`</span></span><br><span class="line"><span class="comment">// Use the host's ipc namespace.</span></span><br><span class="line"><span class="comment">// Optional: Default to false.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">HostIPC <span class="keyword">bool</span> <span class="string">`json:"hostIPC,omitempty" protobuf:"varint,13,opt,name=hostIPC"`</span></span><br><span class="line"><span class="comment">// Share a single process namespace between all of the containers in a pod.</span></span><br><span class="line"><span class="comment">// When this is set containers will be able to view and signal processes from other containers</span></span><br><span class="line"><span class="comment">// in the same pod, and the first process in each container will not be assigned PID 1.</span></span><br><span class="line"><span class="comment">// HostPID and ShareProcessNamespace cannot both be set.</span></span><br><span class="line"><span class="comment">// Optional: Default to false.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">ShareProcessNamespace *<span class="keyword">bool</span> <span class="string">`json:"shareProcessNamespace,omitempty" protobuf:"varint,27,opt,name=shareProcessNamespace"`</span></span><br><span class="line"><span class="comment">// SecurityContext holds pod-level security attributes and common container settings.</span></span><br><span class="line"><span class="comment">// Optional: Defaults to empty.  See type description for default values of each field.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">SecurityContext *PodSecurityContext <span class="string">`json:"securityContext,omitempty" protobuf:"bytes,14,opt,name=securityContext"`</span></span><br><span class="line"><span class="comment">// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.</span></span><br><span class="line"><span class="comment">// If specified, these secrets will be passed to individual puller implementations for them to use. For example,</span></span><br><span class="line"><span class="comment">// in the case of docker, only DockerConfig type secrets are honored.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">ImagePullSecrets []LocalObjectReference <span class="string">`json:"imagePullSecrets,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,15,rep,name=imagePullSecrets"`</span></span><br><span class="line"><span class="comment">// Specifies the hostname of the Pod</span></span><br><span class="line"><span class="comment">// If not specified, the pod's hostname will be set to a system-defined value.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Hostname <span class="keyword">string</span> <span class="string">`json:"hostname,omitempty" protobuf:"bytes,16,opt,name=hostname"`</span></span><br><span class="line"><span class="comment">// If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".</span></span><br><span class="line"><span class="comment">// If not specified, the pod will not have a domainname at all.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Subdomain <span class="keyword">string</span> <span class="string">`json:"subdomain,omitempty" protobuf:"bytes,17,opt,name=subdomain"`</span></span><br><span class="line"><span class="comment">// If specified, the pod's scheduling constraints</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Affinity *Affinity <span class="string">`json:"affinity,omitempty" protobuf:"bytes,18,opt,name=affinity"`</span></span><br><span class="line"><span class="comment">// If specified, the pod will be dispatched by specified scheduler.</span></span><br><span class="line"><span class="comment">// If not specified, the pod will be dispatched by default scheduler.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">SchedulerName <span class="keyword">string</span> <span class="string">`json:"schedulerName,omitempty" protobuf:"bytes,19,opt,name=schedulerName"`</span></span><br><span class="line"><span class="comment">// If specified, the pod's tolerations.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Tolerations []Toleration <span class="string">`json:"tolerations,omitempty" protobuf:"bytes,22,opt,name=tolerations"`</span></span><br><span class="line"><span class="comment">// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts</span></span><br><span class="line"><span class="comment">// file if specified. This is only valid for non-hostNetwork pods.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=ip</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">HostAliases []HostAlias <span class="string">`json:"hostAliases,omitempty" patchStrategy:"merge" patchMergeKey:"ip" protobuf:"bytes,23,rep,name=hostAliases"`</span></span><br><span class="line"><span class="comment">// If specified, indicates the pod's priority. "system-node-critical" and</span></span><br><span class="line"><span class="comment">// "system-cluster-critical" are two special keywords which indicate the</span></span><br><span class="line"><span class="comment">// highest priorities with the former being the highest priority. Any other</span></span><br><span class="line"><span class="comment">// name must be defined by creating a PriorityClass object with that name.</span></span><br><span class="line"><span class="comment">// If not specified, the pod priority will be default or zero if there is no</span></span><br><span class="line"><span class="comment">// default.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">PriorityClassName <span class="keyword">string</span> <span class="string">`json:"priorityClassName,omitempty" protobuf:"bytes,24,opt,name=priorityClassName"`</span></span><br><span class="line"><span class="comment">// The priority value. Various system components use this field to find the</span></span><br><span class="line"><span class="comment">// priority of the pod. When Priority Admission Controller is enabled, it</span></span><br><span class="line"><span class="comment">// prevents users from setting this field. The admission controller populates</span></span><br><span class="line"><span class="comment">// this field from PriorityClassName.</span></span><br><span class="line"><span class="comment">// The higher the value, the higher the priority.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Priority *<span class="keyword">int32</span> <span class="string">`json:"priority,omitempty" protobuf:"bytes,25,opt,name=priority"`</span></span><br><span class="line"><span class="comment">// Specifies the DNS parameters of a pod.</span></span><br><span class="line"><span class="comment">// Parameters specified here will be merged to the generated DNS</span></span><br><span class="line"><span class="comment">// configuration based on DNSPolicy.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">DNSConfig *PodDNSConfig <span class="string">`json:"dnsConfig,omitempty" protobuf:"bytes,26,opt,name=dnsConfig"`</span></span><br><span class="line"><span class="comment">// If specified, all readiness gates will be evaluated for pod readiness.</span></span><br><span class="line"><span class="comment">// A pod is ready when all its containers are ready AND</span></span><br><span class="line"><span class="comment">// all conditions specified in the readiness gates have status equal to "True"</span></span><br><span class="line"><span class="comment">// More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">ReadinessGates []PodReadinessGate <span class="string">`json:"readinessGates,omitempty" protobuf:"bytes,28,opt,name=readinessGates"`</span></span><br><span class="line"><span class="comment">// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used</span></span><br><span class="line"><span class="comment">// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.</span></span><br><span class="line"><span class="comment">// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an</span></span><br><span class="line"><span class="comment">// empty definition that uses the default runtime handler.</span></span><br><span class="line"><span class="comment">// More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md</span></span><br><span class="line"><span class="comment">// This is a beta feature as of Kubernetes v1.14.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">RuntimeClassName *<span class="keyword">string</span> <span class="string">`json:"runtimeClassName,omitempty" protobuf:"bytes,29,opt,name=runtimeClassName"`</span></span><br><span class="line"><span class="comment">// EnableServiceLinks indicates whether information about services should be injected into pod's</span></span><br><span class="line"><span class="comment">// environment variables, matching the syntax of Docker links.</span></span><br><span class="line"><span class="comment">// Optional: Defaults to true.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">EnableServiceLinks *<span class="keyword">bool</span> <span class="string">`json:"enableServiceLinks,omitempty" protobuf:"varint,30,opt,name=enableServiceLinks"`</span></span><br><span class="line"><span class="comment">// PreemptionPolicy is the Policy for preempting pods with lower priority.</span></span><br><span class="line"><span class="comment">// One of Never, PreemptLowerPriority.</span></span><br><span class="line"><span class="comment">// Defaults to PreemptLowerPriority if unset.</span></span><br><span class="line"><span class="comment">// This field is alpha-level and is only honored by servers that enable the NonPreemptingPriority feature.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">PreemptionPolicy *PreemptionPolicy <span class="string">`json:"preemptionPolicy,omitempty" protobuf:"bytes,31,opt,name=preemptionPolicy"`</span></span><br><span class="line"><span class="comment">// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.</span></span><br><span class="line"><span class="comment">// This field will be autopopulated at admission time by the RuntimeClass admission controller. If</span></span><br><span class="line"><span class="comment">// the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.</span></span><br><span class="line"><span class="comment">// The RuntimeClass admission controller will reject Pod create requests which have the overhead already</span></span><br><span class="line"><span class="comment">// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value</span></span><br><span class="line"><span class="comment">// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.</span></span><br><span class="line"><span class="comment">// More info: https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md</span></span><br><span class="line"><span class="comment">// This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the PodOverhead feature.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Overhead ResourceList <span class="string">`json:"overhead,omitempty" protobuf:"bytes,32,opt,name=overhead"`</span></span><br><span class="line"><span class="comment">// TopologySpreadConstraints describes how a group of pods ought to spread across topology</span></span><br><span class="line"><span class="comment">// domains. Scheduler will schedule pods in a way which abides by the constraints.</span></span><br><span class="line"><span class="comment">// This field is only honored by clusters that enable the EvenPodsSpread feature.</span></span><br><span class="line"><span class="comment">// All topologySpreadConstraints are ANDed.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=topologyKey</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line"><span class="comment">// +listType=map</span></span><br><span class="line"><span class="comment">// +listMapKey=topologyKey</span></span><br><span class="line"><span class="comment">// +listMapKey=whenUnsatisfiable</span></span><br><span class="line">TopologySpreadConstraints []TopologySpreadConstraint <span class="string">`json:"topologySpreadConstraints,omitempty" patchStrategy:"merge" patchMergeKey:"topologyKey" protobuf:"bytes,33,opt,name=topologySpreadConstraints"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pod的状态"><a href="#Pod的状态" class="headerlink" title="Pod的状态"></a>Pod的状态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These are the valid statuses of pods.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// PodPending means the pod has been accepted by the system, but one or more of the containers</span></span><br><span class="line"><span class="comment">// has not been started. This includes time before being bound to a node, as well as time spent</span></span><br><span class="line"><span class="comment">// pulling images onto the host.</span></span><br><span class="line">PodPending PodPhase = <span class="string">"Pending"</span></span><br><span class="line"><span class="comment">// PodRunning means the pod has been bound to a node and all of the containers have been started.</span></span><br><span class="line"><span class="comment">// At least one container is still running or is in the process of being restarted.</span></span><br><span class="line">PodRunning PodPhase = <span class="string">"Running"</span></span><br><span class="line"><span class="comment">// PodSucceeded means that all containers in the pod have voluntarily terminated</span></span><br><span class="line"><span class="comment">// with a container exit code of 0, and the system is not going to restart any of these containers.</span></span><br><span class="line">PodSucceeded PodPhase = <span class="string">"Succeeded"</span></span><br><span class="line"><span class="comment">// PodFailed means that all containers in the pod have terminated, and at least one container has</span></span><br><span class="line"><span class="comment">// terminated in a failure (exited with a non-zero exit code or was stopped by the system).</span></span><br><span class="line">PodFailed PodPhase = <span class="string">"Failed"</span></span><br><span class="line"><span class="comment">// PodUnknown means that for some reason the state of the pod could not be obtained, typically due</span></span><br><span class="line"><span class="comment">// to an error in communicating with the host of the pod.</span></span><br><span class="line">PodUnknown PodPhase = <span class="string">"Unknown"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="亲和性"><a href="#亲和性" class="headerlink" title="亲和性"></a>亲和性</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pod affinity is a group of inter pod affinity scheduling rules.</span></span><br><span class="line"><span class="keyword">type</span> PodAffinity <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// NOT YET IMPLEMENTED. <span class="doctag">TODO:</span> Uncomment field once it is implemented.</span></span><br><span class="line"><span class="comment">// If the affinity requirements specified by this field are not met at</span></span><br><span class="line"><span class="comment">// scheduling time, the pod will not be scheduled onto the node.</span></span><br><span class="line"><span class="comment">// If the affinity requirements specified by this field cease to be met</span></span><br><span class="line"><span class="comment">// at some point during pod execution (e.g. due to a pod label update), the</span></span><br><span class="line"><span class="comment">// system will try to eventually evict the pod from its node.</span></span><br><span class="line"><span class="comment">// When there are multiple elements, the lists of nodes corresponding to each</span></span><br><span class="line"><span class="comment">// podAffinityTerm are intersected, i.e. all terms must be satisfied.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If the affinity requirements specified by this field are not met at</span></span><br><span class="line"><span class="comment">// scheduling time, the pod will not be scheduled onto the node.</span></span><br><span class="line"><span class="comment">// If the affinity requirements specified by this field cease to be met</span></span><br><span class="line"><span class="comment">// at some point during pod execution (e.g. due to a pod label update), the</span></span><br><span class="line"><span class="comment">// system may or may not try to eventually evict the pod from its node.</span></span><br><span class="line"><span class="comment">// When there are multiple elements, the lists of nodes corresponding to each</span></span><br><span class="line"><span class="comment">// podAffinityTerm are intersected, i.e. all terms must be satisfied.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm <span class="string">`json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,rep,name=requiredDuringSchedulingIgnoredDuringExecution"`</span></span><br><span class="line"><span class="comment">// The scheduler will prefer to schedule pods to nodes that satisfy</span></span><br><span class="line"><span class="comment">// the affinity expressions specified by this field, but it may choose</span></span><br><span class="line"><span class="comment">// a node that violates one or more of the expressions. The node that is</span></span><br><span class="line"><span class="comment">// most preferred is the one with the greatest sum of weights, i.e.</span></span><br><span class="line"><span class="comment">// for each node that meets all of the scheduling requirements (resource</span></span><br><span class="line"><span class="comment">// request, requiredDuringScheduling affinity expressions, etc.),</span></span><br><span class="line"><span class="comment">// compute a sum by iterating through the elements of this field and adding</span></span><br><span class="line"><span class="comment">// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the</span></span><br><span class="line"><span class="comment">// node(s) with the highest sum are the most preferred.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm <span class="string">`json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pod anti affinity is a group of inter pod anti affinity scheduling rules.</span></span><br><span class="line"><span class="keyword">type</span> PodAntiAffinity <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// NOT YET IMPLEMENTED. <span class="doctag">TODO:</span> Uncomment field once it is implemented.</span></span><br><span class="line"><span class="comment">// If the anti-affinity requirements specified by this field are not met at</span></span><br><span class="line"><span class="comment">// scheduling time, the pod will not be scheduled onto the node.</span></span><br><span class="line"><span class="comment">// If the anti-affinity requirements specified by this field cease to be met</span></span><br><span class="line"><span class="comment">// at some point during pod execution (e.g. due to a pod label update), the</span></span><br><span class="line"><span class="comment">// system will try to eventually evict the pod from its node.</span></span><br><span class="line"><span class="comment">// When there are multiple elements, the lists of nodes corresponding to each</span></span><br><span class="line"><span class="comment">// podAffinityTerm are intersected, i.e. all terms must be satisfied.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If the anti-affinity requirements specified by this field are not met at</span></span><br><span class="line"><span class="comment">// scheduling time, the pod will not be scheduled onto the node.</span></span><br><span class="line"><span class="comment">// If the anti-affinity requirements specified by this field cease to be met</span></span><br><span class="line"><span class="comment">// at some point during pod execution (e.g. due to a pod label update), the</span></span><br><span class="line"><span class="comment">// system may or may not try to eventually evict the pod from its node.</span></span><br><span class="line"><span class="comment">// When there are multiple elements, the lists of nodes corresponding to each</span></span><br><span class="line"><span class="comment">// podAffinityTerm are intersected, i.e. all terms must be satisfied.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm <span class="string">`json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,rep,name=requiredDuringSchedulingIgnoredDuringExecution"`</span></span><br><span class="line"><span class="comment">// The scheduler will prefer to schedule pods to nodes that satisfy</span></span><br><span class="line"><span class="comment">// the anti-affinity expressions specified by this field, but it may choose</span></span><br><span class="line"><span class="comment">// a node that violates one or more of the expressions. The node that is</span></span><br><span class="line"><span class="comment">// most preferred is the one with the greatest sum of weights, i.e.</span></span><br><span class="line"><span class="comment">// for each node that meets all of the scheduling requirements (resource</span></span><br><span class="line"><span class="comment">// request, requiredDuringScheduling anti-affinity expressions, etc.),</span></span><br><span class="line"><span class="comment">// compute a sum by iterating through the elements of this field and adding</span></span><br><span class="line"><span class="comment">// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the</span></span><br><span class="line"><span class="comment">// node(s) with the highest sum are the most preferred.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm <span class="string">`json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>每一个 Kubernetes 的 Pod 其实都具有两种不同的容器，两种不同容器的职责其实十分清晰，一种是 <code>InitContainer</code>，这种容器会在 Pod 启动时运行，主要用于初始化一些配置，另一种是 Pod 在 Running 状态时内部存活的 <code>Container</code>，它们的主要作用是对外提供服务或者作为工作节点处理异步任务等等。</p><p><img alt="kubernetes-pod-init-and-regular-containers" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-init-and-regular-containers.png"></p><p>通过对不同容器类型的命名我们也可以看出，<code>InitContainer</code> 会比 <code>Container</code> 优先启动，在 <code>kubeGenericRuntimeManager.SyncPod</code> 方法中会先后启动两种容器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line"><span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line"><span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line"><span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line"><span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5: start the init container.</span></span><br><span class="line"><span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 6: start containers in podContainerChanges.ContainersToStart.</span></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">container := &amp;pod.Spec.Containers[idx]</span><br><span class="line"></span><br><span class="line">msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析私有方法 <code>startContainer</code> 的实现我们得出：容器的类型最终只会影响在 Debug 时创建的标签，所以对于 Kubernetes 来说两种容器的启动和执行也就只有顺序先后的不同。</p><h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><p>每一个 Pod 中的容器是可以通过 <a href="https://draveness.me/kubernetes-volume" target="_blank" rel="external nofollow noopener noreferrer">卷（Volume）</a> 的方式共享文件目录的，这些 Volume 能够存储持久化的数据；在当前 Pod 出现故障或者滚动更新时，对应 Volume 中的数据并不会被清除，而是会在 Pod 重启后重新挂载到期望的文件目录中：</p><p><img alt="kubernetes-containers-share-volumes" data-src="https://img.draveness.me/2018-12-25-kubernetes-containers-share-volumes.png"></p><p>kubelet.go 文件中的私有方法 <code>syncPod</code> 会调用 <code>WaitForAttachAndMount</code> 方法为等待当前 Pod 启动需要的挂载文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *volumeManager)</span> <span class="title">WaitForAttachAndMount</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">expectedVolumes := getExpectedVolumes(pod)</span><br><span class="line">uniquePodName := util.GetUniquePodName(pod)</span><br><span class="line"></span><br><span class="line">vm.desiredStateOfWorldPopulator.ReprocessPod(uniquePodName)</span><br><span class="line"></span><br><span class="line">wait.PollImmediate(</span><br><span class="line">podAttachAndMountRetryInterval,</span><br><span class="line">podAttachAndMountTimeout,</span><br><span class="line">vm.verifyVolumesMountedFunc(uniquePodName, expectedVolumes))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会在 <a href="https://draveness.me/kubernetes-volume" target="_blank" rel="external nofollow noopener noreferrer">后面的章节</a> 详细地介绍 Kubernetes 中卷的创建、挂载是如何进行的，在这里我们需要知道的是卷的挂载是 Pod 启动之前必须要完成的工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncPod</span><span class="params">(o syncPodOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !kl.podIsTerminated(pod) &#123;</span><br><span class="line">kl.volumeManager.WaitForAttachAndMount(pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pullSecrets := kl.getPullSecretsForPod(pod)</span><br><span class="line"></span><br><span class="line">result := kl.containerRuntime.SyncPod(pod, apiPodStatus, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">kl.reasonCache.Update(pod.UID, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前 Pod 的卷创建完成之后，就会调用上一节中提到的 <code>SyncPod</code> 公有方法继续进行同步 Pod 信息和创建、启动容器的工作。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>同一个 Pod 中的多个容器会被共同分配到同一个 Host 上并且共享网络栈，也就是说这些 Pod 能够通过 localhost 互相访问到彼此的端口和服务，如果使用了相同的端口也会发生冲突，同一个 Pod 上的所有容器会连接到同一个网络设备上，这个网络设备就是由 Pod Sandbox 中的沙箱容器在 <code>RunPodSandbox</code> 方法中启动时创建的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *dockerService)</span> <span class="title">RunPodSandbox</span><span class="params">(ctx context.Context, r *runtimeapi.RunPodSandboxRequest)</span> <span class="params">(*runtimeapi.RunPodSandboxResponse, error)</span></span> &#123;</span><br><span class="line">config := r.GetConfig()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: Pull the image for the sandbox.</span></span><br><span class="line">image := defaultSandboxImage</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Create the sandbox container.</span></span><br><span class="line">createConfig, _ := ds.makeSandboxDockerConfig(config, image)</span><br><span class="line">createResp, _ := ds.client.CreateContainer(*createConfig)</span><br><span class="line"></span><br><span class="line">resp := &amp;runtimeapi.RunPodSandboxResponse&#123;PodSandboxId: createResp.ID&#125;</span><br><span class="line"></span><br><span class="line">ds.setNetworkReady(createResp.ID, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: Create Sandbox Checkpoint.</span></span><br><span class="line">ds.checkpointManager.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: Start the sandbox container.</span></span><br><span class="line">ds.client.StartContainer(createResp.ID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5: Setup networking for the sandbox.</span></span><br><span class="line">cID := kubecontainer.BuildContainerID(runtimeName, createResp.ID)</span><br><span class="line">networkOptions := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations, networkOptions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>沙箱容器其实就是 <code>pause</code> 容器，上述方法引用的 <code>defaultSandboxImage</code> 其实就是官方提供的 <code>k8s.gcr.io/pause:3.1</code> 镜像，这里会创建沙箱镜像和检查点并启动容器。</p><p><img alt="kubernetes-pod-network" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-network.png"></p><p>每一个节点上都会由 Kubernetes 的网络插件 Kubenet 创建一个基本的 <code>cbr0</code> 网桥并为每一个 Pod 创建 <code>veth</code> 虚拟网络设备，同一个 Pod 中的所有容器就会通过这个网络设备共享网络，也就是能够通过 localhost 互相访问彼此暴露的端口和服务。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Kubernetes 中的每一个 Pod 都包含多个容器，这些容器在通过 Kubernetes 创建之后就能共享网络和存储，这其实是 Pod 非常重要的特性，我们能通过这个特性构建比较复杂的服务拓扑和依赖关系。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>想要深入理解 Pod 的实现原理，最好最快的办法就是从 Pod 的生命周期入手，通过理解 Pod 创建、重启和删除的原理我们最终就能够系统地掌握 Pod 的生命周期与核心原理。</p><p><img alt="kubernetes-pod-lifecycle" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-lifecycle.png"></p><p>当 Pod 被创建之后，就会进入健康检查状态，当 Kubernetes 确定当前 Pod 已经能够接受外部的请求时，才会将流量打到新的 Pod 上并继续对外提供服务，在这期间如果发生了错误就可能会触发重启机制，在 Pod 被删除之前都会触发一个 <code>PreStop</code> 的钩子，其中的方法完成之后 Pod 才会被删除，接下来我们就会按照这里的顺序依次介绍 Pod 『从生到死』的过程。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Pod 的创建都是通过 <code>SyncPod</code> 来实现的，创建的过程大体上可以分为六个步骤：</p><ol><li>计算 Pod 中沙盒和容器的变更；</li><li>强制停止 Pod 对应的沙盒；</li><li>强制停止所有不应该运行的容器；</li><li>为 Pod 创建新的沙盒；</li><li>创建 Pod 规格中指定的初始化容器；</li><li>依次创建 Pod 规格中指定的常规容器；</li></ol><p>我们可以看到 Pod 的创建过程其实是比较简单的，首先计算 Pod 规格和沙箱的变更，然后停止可能影响这一次创建或者更新的容器，最后依次创建沙盒、初始化容器和常规容器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line">podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">ref, _ := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">m.purgeInitContainers(pod, podStatus)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, <span class="literal">nil</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">podSandboxID := podContainerChanges.SandboxID</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">podSandboxID, _, _ = m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line">&#125;</span><br><span class="line">podSandboxConfig, _ := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">container := &amp;pod.Spec.Containers[idx]</span><br><span class="line">msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化后的 <code>SyncPod</code> 方法的脉络非常清晰，可以很好地理解整个创建 Pod 的工作流程；而初始化容器和常规容器被调用 <code>startContainer</code> 来启动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">startContainer</span><span class="params">(podSandboxID <span class="keyword">string</span>, podSandboxConfig *runtimeapi.PodSandboxConfig, container *v1.Container, pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, podIP <span class="keyword">string</span>, containerType kubecontainer.ContainerType)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">imageRef, _, _ := m.imagePuller.EnsureImageExists(pod, container, pullSecrets)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">containerID, _ := m.runtimeService.CreateContainer(podSandboxID, containerConfig, podSandboxConfig)</span><br><span class="line"></span><br><span class="line">m.internalLifecycle.PreStartContainer(pod, container, containerID)</span><br><span class="line"></span><br><span class="line">m.runtimeService.StartContainer(containerID)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> container.Lifecycle != <span class="literal">nil</span> &amp;&amp; container.Lifecycle.PostStart != <span class="literal">nil</span> &#123;</span><br><span class="line">kubeContainerID := kubecontainer.ContainerID&#123;</span><br><span class="line">Type: m.runtimeName,</span><br><span class="line">ID:   containerID,</span><br><span class="line">&#125;</span><br><span class="line">msg, _ := m.runner.Run(kubeContainerID, pod, container, container.Lifecycle.PostStart)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动每一个容器的过程中也都按照相同的步骤进行操作：</p><ol><li>通过镜像拉取器获得当前容器中使用镜像的引用；</li><li>调用远程的 <code>runtimeService</code> 创建容器；</li><li>调用内部的生命周期方法 <code>PreStartContainer</code> 为当前的容器设置分配的 CPU 等资源；</li><li>调用远程的 <code>runtimeService</code> 开始运行镜像；</li><li>如果当前的容器包含 <code>PostStart</code> 钩子就会执行该回调；</li></ol><p>每次 <code>SyncPod</code> 被调用时不一定是创建新的 Pod 对象，它还会承担更新、删除和同步 Pod 规格的职能，根据输入的新规格执行相应的操作。</p><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>如果我们遵循 Pod 的最佳实践，其实应该尽可能地为每一个 Pod 添加 <code>livenessProbe</code> 和 <code>readinessProbe</code> 的健康检查，这两者能够为 Kubernetes 提供额外的存活信息，如果我们配置了合适的健康检查方法和规则，那么就不会出现服务未启动就被打入流量或者长时间未响应依然没有重启等问题。</p><p>在 Pod 被创建或者被移除时，会被加入到当前节点上的 <code>ProbeManager</code> 中，<code>ProbeManager</code> 会负责这些 Pod 的健康检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodAdditions</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">start := kl.clock.Now()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">kl.podManager.AddPod(pod)</span><br><span class="line">kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</span><br><span class="line">kl.probeManager.AddPod(pod)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodRemoves</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">start := kl.clock.Now()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">kl.podManager.DeletePod(pod)</span><br><span class="line">kl.deletePod(pod)</span><br><span class="line">kl.probeManager.RemovePod(pod)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化后的 <code>HandlePodAdditions</code> 和 <code>HandlePodRemoves</code> 方法非常直白，我们可以直接来看 <code>ProbeManager</code> 如何处理不同节点的健康检查。</p><p><img alt="kubernetes-probe-manager" data-src="https://img.draveness.me/2018-12-25-kubernetes-probe-manager.png"></p><p>每一个新的 Pod 都会被调用 <code>ProbeManager</code> 的<code>AddPod</code> 函数，这个方法会初始化一个新的 Goroutine 并在其中运行对当前 Pod 进行健康检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">AddPod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">key.containerName = c.Name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.ReadinessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">key.probeType = readiness</span><br><span class="line">w := newWorker(m, readiness, pod, c)</span><br><span class="line">m.workers[key] = w</span><br><span class="line"><span class="keyword">go</span> w.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.LivenessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">key.probeType = liveness</span><br><span class="line">w := newWorker(m, liveness, pod, c)</span><br><span class="line">m.workers[key] = w</span><br><span class="line"><span class="keyword">go</span> w.run()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行健康检查的过程中，Worker 只是负责根据当前 Pod 的状态定期触发一次 <code>Probe</code>，它会根据 Pod 的配置分别选择调用 <code>Exec</code>、<code>HTTPGet</code> 或 <code>TCPSocket</code> 三种不同的 <code>Probe</code> 方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *prober)</span> <span class="title">runProbe</span><span class="params">(probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">timeout := time.Duration(p.TimeoutSeconds) * time.Second</span><br><span class="line"><span class="keyword">if</span> p.Exec != <span class="literal">nil</span> &#123;</span><br><span class="line">command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)</span><br><span class="line"><span class="keyword">return</span> pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.HTTPGet != <span class="literal">nil</span> &#123;</span><br><span class="line">scheme := strings.ToLower(<span class="keyword">string</span>(p.HTTPGet.Scheme))</span><br><span class="line">host := p.HTTPGet.Host</span><br><span class="line">port, _ := extractPort(p.HTTPGet.Port, container)</span><br><span class="line">path := p.HTTPGet.Path</span><br><span class="line">url := formatURL(scheme, host, port, path)</span><br><span class="line">headers := buildHeader(p.HTTPGet.HTTPHeaders)</span><br><span class="line"><span class="keyword">if</span> probeType == liveness &#123;</span><br><span class="line"><span class="keyword">return</span> pb.livenessHttp.Probe(url, headers, timeout)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// readiness</span></span><br><span class="line"><span class="keyword">return</span> pb.readinessHttp.Probe(url, headers, timeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.TCPSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">port, _ := extractPort(p.TCPSocket.Port, container)</span><br><span class="line">host := p.TCPSocket.Host</span><br><span class="line"><span class="keyword">return</span> pb.tcp.Probe(host, port, timeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> probe.Unknown, <span class="string">""</span>, fmt.Errorf(<span class="string">"Missing probe handler for %s:%s"</span>, format.Pod(pod), container.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kubernetes 在 Pod 启动后的 <code>InitialDelaySeconds</code> 时间内会等待 Pod 的启动和初始化，在这之后会开始健康检查，默认的健康检查重试次数是三次，如果健康检查正常运行返回了一个确定的结果，那么 Worker 就是记录这次的结果，在连续失败 <code>FailureThreshold</code> 次或者成功 <code>SuccessThreshold</code> 次，那么就会改变当前 Pod 的状态，这也是为了避免由于服务不稳定带来的抖动。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>当 Kubelet 在 <code>HandlePodRemoves</code> 方法中接收到来自客户端的删除请求时，就会通过一个名为 <code>deletePod</code> 的私有方法中的 Channel 将这一事件传递给 PodKiller 进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">deletePod</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">kl.podWorkers.ForgetWorker(pod.UID)</span><br><span class="line"></span><br><span class="line">runningPods, _ := kl.runtimeCache.GetPods()</span><br><span class="line">runningPod := kubecontainer.Pods(runningPods).FindPod(<span class="string">""</span>, pod.UID)</span><br><span class="line">podPair := kubecontainer.PodPair&#123;APIPod: pod, RunningPod: &amp;runningPod&#125;</span><br><span class="line"></span><br><span class="line">kl.podKillingCh &lt;- &amp;podPair</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kubelet 除了将事件通知给 PodKiller 之外，还需要将当前 Pod 对应的 Worker 从持有的 <code>podWorkers</code> 中删除；PodKiller 其实就是 Kubelet 持有的一个 Goroutine，它会在后台持续运行并监听来自 <code>podKillingCh</code> 的事件：</p><p><img alt="kubernetes-pod-killer" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-killer.png"></p><p>经过一系列的方法调用之后，最终调用容器运行时的 <code>killContainersWithSyncResult</code> 方法，这个方法会同步地杀掉当前 Pod 中全部的容器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killContainersWithSyncResult</span><span class="params">(pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="params">(syncResults []*kubecontainer.SyncResult)</span></span> &#123;</span><br><span class="line">containerResults := <span class="built_in">make</span>(<span class="keyword">chan</span> *kubecontainer.SyncResult, <span class="built_in">len</span>(runningPod.Containers))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, container := <span class="keyword">range</span> runningPod.Containers &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(container *kubecontainer.Container)</span></span> &#123;</span><br><span class="line">killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, container.Name)</span><br><span class="line">m.killContainer(pod, container.ID, container.Name, <span class="string">"Need to kill Pod"</span>, gracePeriodOverride)</span><br><span class="line">containerResults &lt;- killContainerResult</span><br><span class="line">&#125;(container)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(containerResults)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> containerResult := <span class="keyword">range</span> containerResults &#123;</span><br><span class="line">syncResults = <span class="built_in">append</span>(syncResults, containerResult)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个容器来说，它们在被停止之前都会先调用 <code>PreStop</code> 的钩子方法，让容器中的应用程序能够有时间完成一些未处理的操作，随后调用远程的服务停止运行的容器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killContainer</span><span class="params">(pod *v1.Pod, containerID kubecontainer.ContainerID, containerName <span class="keyword">string</span>, reason <span class="keyword">string</span>, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">containerSpec := kubecontainer.GetContainerSpec(pod, containerName);</span><br><span class="line"></span><br><span class="line">gracePeriod := <span class="keyword">int64</span>(minimumGracePeriodInSeconds)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> pod.DeletionGracePeriodSeconds != <span class="literal">nil</span>:</span><br><span class="line">gracePeriod = *pod.DeletionGracePeriodSeconds</span><br><span class="line"><span class="keyword">case</span> pod.Spec.TerminationGracePeriodSeconds != <span class="literal">nil</span>:</span><br><span class="line">gracePeriod = *pod.Spec.TerminationGracePeriodSeconds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.executePreStopHook(pod, containerID, containerSpec, gracePeriod)</span><br><span class="line">m.internalLifecycle.PreStopContainer(containerID.ID)</span><br><span class="line">m.runtimeService.StopContainer(containerID.ID, gracePeriod)</span><br><span class="line">m.containerRefManager.ClearRef(containerID)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个简化版本的 <code>killContainer</code> 方法中，我们可以大致看出停止运行容器的大致逻辑，先从 Pod 的规格中计算出当前停止所需要的时间，然后运行钩子方法和内部的生命周期方法，最后将容器停止并清除引用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们已经介绍了 Pod 中的几个重要概念 — 容器、卷和网络以及从创建到删除整个过程是如何实现的。</p><p>Kubernetes 中 Pod 的运行和管理总是与 kubelet 以及它的组件密不可分，后面的文章中也会介绍 kubelet 究竟是什么，它在整个 Kubernetes 中扮演什么样的角色。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Pod&lt;/code&gt; 是 Kubernetes 集群中能够被创建、调度和管理的最小部署单元，是一组容器的集合，是 k8s 中最简单的对象，也是 k8s 中最为基础的概念。同一个 Pod 中的容器可以共享同一个网络命名空间，IP地址和端口空间。从生命周期上来讲，Pod是短暂而不是长久的应用。Pod被调度到节点，保持在这个节点直到被摧毁。&lt;/p&gt;
&lt;p&gt;本文将分两个部分对 Pod 解读，第一个部分介绍 Pod 的基本概念和常见特性，第二部分会从源码层面介绍 Pod 从创建到删除的整个生命周期的实现。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-27_pod.svg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="pod" scheme="http://houmin.cc/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】Controller Manager</title>
    <link href="http://houmin.cc/posts/76a404e7/"/>
    <id>http://houmin.cc/posts/76a404e7/</id>
    <published>2020-08-11T12:46:45.000Z</published>
    <updated>2020-08-21T08:11:30.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Controller Manager</code>作为集群的管理控制中心，维护集群中的所有控制器，对维持集群的稳定和自我修复，实现高可用，副本控制等起关键作用。</p><a id="more"></a><h2 id="内部结构图"><a href="#内部结构图" class="headerlink" title="内部结构图"></a>内部结构图</h2><p><img alt="12039474-1e134c69dc68c410.png" data-src="https://www.pianshen.com/images/715/6480752a76065ff8de202236459f36bb.png"></p><h2 id="关键性调用链"><a href="#关键性调用链" class="headerlink" title="关键性调用链"></a>关键性调用链</h2><p><img alt="12039474-6d0b6a2aabc46a28.png" data-src="https://www.pianshen.com/images/592/394742076228162f618ca01a59ee1170.png"></p><h2 id="源码分析过程"><a href="#源码分析过程" class="headerlink" title="源码分析过程"></a>源码分析过程</h2><h3 id="组件启动的入口"><a href="#组件启动的入口" class="headerlink" title="组件启动的入口"></a>组件启动的入口</h3><figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/controller-manager.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">command := app.NewControllerManagerCommand()</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line"><span class="comment">// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line"><span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line"><span class="comment">// utilflag.InitFlags()</span></span><br><span class="line">logs.InitLogs()</span><br><span class="line"><span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取配置文件，进行配置读取和初始化默认配置"><a href="#读取配置文件，进行配置读取和初始化默认配置" class="headerlink" title="读取配置文件，进行配置读取和初始化默认配置"></a>读取配置文件，进行配置读取和初始化默认配置</h3><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go -&gt;NewControllerManagerCommand</p><ul><li>初始化Controller-manager的配置选项结构:<strong>NewKubeControllerManagerOptions()</strong></li><li>创建执行命令结构包括Use,Long,和Run:<strong>cmd := &amp;cobra.Command{</strong></li><li>解析配置文件: <strong>s.AddFlags</strong><br>1.KnownControllers()获取所有controller<br>2.将配置文件中的配置选项注入到配置对象中<br>3.同时将controller需要的参数写入.</li></ul><figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/app/controllermanager.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerManagerCommand creates a *cobra.Command object with default parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerManagerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">s, err := options.NewKubeControllerManagerOptions()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">"unable to initialize command options: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use: <span class="string">"kube-controller-manager"</span>,</span><br><span class="line">Long: <span class="string">`The Kubernetes controller manager is a daemon that embeds</span></span><br><span class="line"><span class="string">the core control loops shipped with Kubernetes. In applications of robotics and</span></span><br><span class="line"><span class="string">automation, a control loop is a non-terminating loop that regulates the state of</span></span><br><span class="line"><span class="string">the system. In Kubernetes, a controller is a control loop that watches the shared</span></span><br><span class="line"><span class="string">state of the cluster through the apiserver and makes changes attempting to move the</span></span><br><span class="line"><span class="string">current state towards the desired state. Examples of controllers that ship with</span></span><br><span class="line"><span class="string">Kubernetes today are the replication controller, endpoints controller, namespace</span></span><br><span class="line"><span class="string">controller, and serviceaccounts controller.`</span>,</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">verflag.PrintAndExitIfRequested()</span><br><span class="line">utilflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs := cmd.Flags()</span><br><span class="line">namedFlagSets := s.Flags(KnownControllers(), ControllersDisabledByDefault.List())</span><br><span class="line">verflag.AddFlags(namedFlagSets.FlagSet(<span class="string">"global"</span>))</span><br><span class="line">globalflag.AddGlobalFlags(namedFlagSets.FlagSet(<span class="string">"global"</span>), cmd.Name())</span><br><span class="line">registerLegacyGlobalFlags(namedFlagSets)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> namedFlagSets.FlagSets &#123;</span><br><span class="line">fs.AddFlagSet(f)</span><br><span class="line">&#125;</span><br><span class="line">usageFmt := <span class="string">"Usage:\n  %s\n"</span></span><br><span class="line">cols, _, _ := term.TerminalSize(cmd.OutOrStdout())</span><br><span class="line">cmd.SetUsageFunc(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Fprintf(cmd.OutOrStderr(), usageFmt, cmd.UseLine())</span><br><span class="line">cliflag.PrintSections(cmd.OutOrStderr(), namedFlagSets, cols)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">cmd.SetHelpFunc(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(cmd.OutOrStdout(), <span class="string">"%s\n\n"</span>+usageFmt, cmd.Long, cmd.UseLine())</span><br><span class="line">cliflag.PrintSections(cmd.OutOrStdout(), namedFlagSets, cols)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件启动执行"><a href="#组件启动执行" class="headerlink" title="组件启动执行"></a>组件启动执行</h3><p>从main中的command.Execute()到4.2中构造的Run<br><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>//加载所有控制器，并将对应参数注入到控制器中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List())</span><br></pre></td></tr></table></figure><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>KnownControllers()中的NewControllerInitializers初始化所有的控制器</p><figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/app/controllermanager.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)</span></span><br><span class="line"><span class="comment">// paired to their InitFunc.  This allows for structured downstream composition and subdivision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line">controllers[<span class="string">"endpoint"</span>] = startEndpointController</span><br><span class="line">controllers[<span class="string">"endpointslice"</span>] = startEndpointSliceController</span><br><span class="line">controllers[<span class="string">"replicationcontroller"</span>] = startReplicationController</span><br><span class="line">controllers[<span class="string">"podgc"</span>] = startPodGCController</span><br><span class="line">controllers[<span class="string">"resourcequota"</span>] = startResourceQuotaController</span><br><span class="line">controllers[<span class="string">"namespace"</span>] = startNamespaceController</span><br><span class="line">controllers[<span class="string">"serviceaccount"</span>] = startServiceAccountController</span><br><span class="line">controllers[<span class="string">"garbagecollector"</span>] = startGarbageCollectorController</span><br><span class="line">controllers[<span class="string">"daemonset"</span>] = startDaemonSetController</span><br><span class="line">controllers[<span class="string">"job"</span>] = startJobController</span><br><span class="line">controllers[<span class="string">"deployment"</span>] = startDeploymentController</span><br><span class="line">controllers[<span class="string">"replicaset"</span>] = startReplicaSetController</span><br><span class="line">controllers[<span class="string">"horizontalpodautoscaling"</span>] = startHPAController</span><br><span class="line">controllers[<span class="string">"disruption"</span>] = startDisruptionController</span><br><span class="line">controllers[<span class="string">"statefulset"</span>] = startStatefulSetController</span><br><span class="line">controllers[<span class="string">"cronjob"</span>] = startCronJobController</span><br><span class="line">controllers[<span class="string">"csrsigning"</span>] = startCSRSigningController</span><br><span class="line">controllers[<span class="string">"csrapproving"</span>] = startCSRApprovingController</span><br><span class="line">controllers[<span class="string">"csrcleaner"</span>] = startCSRCleanerController</span><br><span class="line">controllers[<span class="string">"ttl"</span>] = startTTLController</span><br><span class="line">controllers[<span class="string">"bootstrapsigner"</span>] = startBootstrapSignerController</span><br><span class="line">controllers[<span class="string">"tokencleaner"</span>] = startTokenCleanerController</span><br><span class="line">controllers[<span class="string">"nodeipam"</span>] = startNodeIpamController</span><br><span class="line">controllers[<span class="string">"nodelifecycle"</span>] = startNodeLifecycleController</span><br><span class="line"><span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">controllers[<span class="string">"service"</span>] = startServiceController</span><br><span class="line">controllers[<span class="string">"route"</span>] = startRouteController</span><br><span class="line">controllers[<span class="string">"cloud-node-lifecycle"</span>] = startCloudNodeLifecycleController</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> volume controller into the IncludeCloudLoops only set.</span></span><br><span class="line">&#125;</span><br><span class="line">controllers[<span class="string">"persistentvolume-binder"</span>] = startPersistentVolumeBinderController</span><br><span class="line">controllers[<span class="string">"attachdetach"</span>] = startAttachDetachController</span><br><span class="line">controllers[<span class="string">"persistentvolume-expander"</span>] = startVolumeExpandController</span><br><span class="line">controllers[<span class="string">"clusterrole-aggregation"</span>] = startClusterRoleAggregrationController</span><br><span class="line">controllers[<span class="string">"pvc-protection"</span>] = startPVCProtectionController</span><br><span class="line">controllers[<span class="string">"pv-protection"</span>] = startPVProtectionController</span><br><span class="line">controllers[<span class="string">"ttl-after-finished"</span>] = startTTLAfterFinishedController</span><br><span class="line">controllers[<span class="string">"root-ca-cert-publisher"</span>] = startRootCACertPublisher</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>真正进入执行</p><ul><li>启动controller-manager的http服务和对应处理器，包括安全和非安全：<strong>BuildHandlerChain</strong></li><li>构造run的执行体</li><li>需要选主的情况，选主完执行run;不需要选主的直接执行run，然后panic</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(<span class="built_in">c</span> *config.CompletedConfig)</span></span> error &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// To help debugging, immediately log version</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glog.<span class="type">Infof</span>(<span class="string">"Version: %+v"</span>, version.<span class="type">Get</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cfgz, err := configz.<span class="type">New</span>(<span class="string">"componentconfig"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cfgz.<span class="type">Set</span>(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        glog.<span class="type">Errorf</span>(<span class="string">"unable to register configz: %c"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the controller manager HTTP server</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stopCh := make(chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">SecureServing</span> != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler := genericcontrollermanager.<span class="type">NewBaseHandler</span>(&amp;<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">Debugging</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler = genericcontrollermanager.<span class="type">BuildHandlerChain</span>(handler, &amp;<span class="built_in">c</span>.<span class="type">Authorization</span>, &amp;<span class="built_in">c</span>.<span class="type">Authentication</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">c</span>.<span class="type">SecureServing</span>.<span class="type">Serve</span>(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">InsecureServing</span> != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler := genericcontrollermanager.<span class="type">NewBaseHandler</span>(&amp;<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">Debugging</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler = genericcontrollermanager.<span class="type">BuildHandlerChain</span>(handler, &amp;<span class="built_in">c</span>.<span class="type">Authorization</span>, &amp;<span class="built_in">c</span>.<span class="type">Authentication</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">c</span>.<span class="type">InsecureServing</span>.<span class="type">Serve</span>(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-chan <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        rootClientBuilder := controller.<span class="type">SimpleControllerClientBuilder</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">ClientConfig</span>: <span class="built_in">c</span>.<span class="type">Kubeconfig</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> clientBuilder controller.<span class="type">ControllerClientBuilder</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">KubeCloudShared</span>.<span class="type">UseServiceAccountCredentials</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> len(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">SAController</span>.<span class="type">ServiceAccountKeyFile</span>) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// It'c possible another controller process is creating the tokens for us.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If one isn't, we'll timeout and exit when our client builder is unable to create the tokens.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                glog.<span class="type">Warningf</span>(<span class="string">"--use-service-account-credentials was specified without providing a --service-account-private-key-file"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            clientBuilder = controller.<span class="type">SAControllerClientBuilder</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">ClientConfig</span>:         restclient.<span class="type">AnonymousClientConfig</span>(<span class="built_in">c</span>.<span class="type">Kubeconfig</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">CoreClient</span>:           <span class="built_in">c</span>.<span class="type">Client</span>.<span class="type">CoreV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">AuthenticationClient</span>: <span class="built_in">c</span>.<span class="type">Client</span>.<span class="type">AuthenticationV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">Namespace</span>:            <span class="string">"kube-system"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            clientBuilder = rootClientBuilder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ctx, err := <span class="type">CreateControllerContext</span>(<span class="built_in">c</span>, rootClientBuilder, clientBuilder, stop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            glog.<span class="type">Fatalf</span>(<span class="string">"error building controller context: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动控制器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="type">StartControllers</span>(ctx, saTokenControllerInitFunc, <span class="type">NewControllerInitializers</span>(ctx.<span class="type">LoopMode</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            glog.<span class="type">Fatalf</span>(<span class="string">"error starting controllers: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ctx.<span class="type">InformerFactory</span>.<span class="type">Start</span>(ctx.<span class="type">Stop</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        close(ctx.<span class="type">InformersStarted</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        select &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//note 如果未启用选主（只是单节点），直接启动，并且panic，不在往下走，因为run内部有select挂起</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">LeaderElect</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        run(wait.<span class="type">NeverStop</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panic(<span class="string">"unreachable"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id, err := os.<span class="type">Hostname</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add a uniquifier so that two processes on the same host don't accidentally both become active</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成唯一ID,相当于进程锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id = id + <span class="string">"_"</span> + string(uuid.<span class="type">NewUUID</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rl, err := resourcelock.<span class="type">New</span>(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">ResourceLock</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">"kube-system"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">"kube-controller-manager"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">c</span>.<span class="type">LeaderElectionClient</span>.<span class="type">CoreV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        resourcelock.<span class="type">ResourceLockConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Identity</span>:      id,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">EventRecorder</span>: <span class="built_in">c</span>.<span class="type">EventRecorder</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        glog.<span class="type">Fatalf</span>(<span class="string">"error creating lock: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行选主，并在选为主节点后执行run</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    leaderelection.<span class="type">RunOrDie</span>(leaderelection.<span class="type">LeaderElectionConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Lock</span>:          rl,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">LeaseDuration</span>: <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">LeaseDuration</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">RenewDeadline</span>: <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">RenewDeadline</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">RetryPeriod</span>:   <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">RetryPeriod</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Callbacks</span>: leaderelection.<span class="type">LeaderCallbacks</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//选主完成后执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">OnStartedLeading</span>: run,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">OnStoppedLeading</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                glog.<span class="type">Fatalf</span>(<span class="string">"leaderelection lost"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    panic(<span class="string">"unreachable"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转到run内部核心的三个动作</strong> ：CreateControllerContext 、 StartControllers和ctx.InformerFactory.Start</p><h4 id="CreateControllerContext"><a href="#CreateControllerContext" class="headerlink" title="CreateControllerContext"></a>CreateControllerContext</h4><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go</p><ul><li>拿到对kube-APIserver中资源的操作句柄</li><li>确认Kube-APIServer的健康（最多等待10s），然后拿获取连接</li><li>创建控制器上下文</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateControllerContext creates a context struct containing references to resources needed by the</span></span><br><span class="line"><span class="comment">// controllers such as the cloud provider and clientBuilder. rootClientBuilder is only used for</span></span><br><span class="line"><span class="comment">// the shared-informers client and token controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateControllerContext</span><span class="params">(s *config.CompletedConfig, rootClientBuilder, clientBuilder controller.ControllerClientBuilder, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(ControllerContext, error)</span></span> &#123;</span><br><span class="line">versionedClient := rootClientBuilder.ClientOrDie(<span class="string">"shared-informers"</span>)</span><br><span class="line">sharedInformers := informers.NewSharedInformerFactory(versionedClient, ResyncPeriod(s)())</span><br><span class="line"></span><br><span class="line">metadataClient := metadata.NewForConfigOrDie(rootClientBuilder.ConfigOrDie(<span class="string">"metadata-informers"</span>))</span><br><span class="line">metadataInformers := metadatainformer.NewSharedInformerFactory(metadataClient, ResyncPeriod(s)())</span><br><span class="line"></span><br><span class="line"><span class="comment">// If apiserver is not running we should wait for some time and fail only then. This is particularly</span></span><br><span class="line"><span class="comment">// important when we start apiserver and controller manager at the same time.</span></span><br><span class="line"><span class="keyword">if</span> err := genericcontrollermanager.WaitForAPIServer(versionedClient, <span class="number">10</span>*time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ControllerContext&#123;&#125;, fmt.Errorf(<span class="string">"failed to wait for apiserver being healthy: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a discovery client capable of being refreshed.</span></span><br><span class="line">discoveryClient := rootClientBuilder.ClientOrDie(<span class="string">"controller-discovery"</span>)</span><br><span class="line">cachedClient := cacheddiscovery.NewMemCacheClient(discoveryClient.Discovery())</span><br><span class="line">restMapper := restmapper.NewDeferredDiscoveryRESTMapper(cachedClient)</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">restMapper.Reset()</span><br><span class="line">&#125;, <span class="number">30</span>*time.Second, stop)</span><br><span class="line"></span><br><span class="line">availableResources, err := GetAvailableResources(rootClientBuilder)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ControllerContext&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cloud, loopMode, err := createCloudProvider(s.ComponentConfig.KubeCloudShared.CloudProvider.Name, s.ComponentConfig.KubeCloudShared.ExternalCloudVolumePlugin,</span><br><span class="line">s.ComponentConfig.KubeCloudShared.CloudProvider.CloudConfigFile, s.ComponentConfig.KubeCloudShared.AllowUntaggedCloud, sharedInformers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ControllerContext&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx := ControllerContext&#123;</span><br><span class="line">ClientBuilder:                   clientBuilder,</span><br><span class="line">InformerFactory:                 sharedInformers,</span><br><span class="line">ObjectOrMetadataInformerFactory: controller.NewInformerFactory(sharedInformers, metadataInformers),</span><br><span class="line">ComponentConfig:                 s.ComponentConfig,</span><br><span class="line">RESTMapper:                      restMapper,</span><br><span class="line">AvailableResources:              availableResources,</span><br><span class="line">Cloud:                           cloud,</span><br><span class="line">LoopMode:                        loopMode,</span><br><span class="line">Stop:                            stop,</span><br><span class="line">InformersStarted:                <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">ResyncPeriod:                    ResyncPeriod(s),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StartControllers"><a href="#StartControllers" class="headerlink" title="StartControllers"></a>StartControllers</h4><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>启动初始化的所有控制器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartControllers starts a set of controllers with a specified ControllerContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Always start the SA token controller first using a full-power client, since it needs to mint tokens for the rest</span></span><br><span class="line"><span class="comment">// If this fails, just return here and fail since other controllers won't be able to get credentials.</span></span><br><span class="line"><span class="keyword">if</span> _, _, err := startSATokenController(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the cloud provider with a reference to the clientBuilder only after token controller</span></span><br><span class="line"><span class="comment">// has started in case the cloud provider uses the client builder.</span></span><br><span class="line"><span class="keyword">if</span> ctx.Cloud != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.Cloud.Initialize(ctx.ClientBuilder, ctx.Stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line"><span class="keyword">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">klog.Warningf(<span class="string">"%q is disabled"</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">1</span>).Infof(<span class="string">"Starting %q"</span>, controllerName)</span><br><span class="line">debugHandler, started, err := initFn(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error starting %q"</span>, controllerName)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !started &#123;</span><br><span class="line">klog.Warningf(<span class="string">"Skipping %q"</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> debugHandler != <span class="literal">nil</span> &amp;&amp; unsecuredMux != <span class="literal">nil</span> &#123;</span><br><span class="line">basePath := <span class="string">"/debug/controllers/"</span> + controllerName</span><br><span class="line">unsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">unsecuredMux.UnlistedHandlePrefix(basePath+<span class="string">"/"</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">&#125;</span><br><span class="line">klog.Infof(<span class="string">"Started %q"</span>, controllerName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ctx-InformerFactory-Start"><a href="#ctx-InformerFactory-Start" class="headerlink" title="ctx.InformerFactory.Start"></a>ctx.InformerFactory.Start</h4><p>controller-manager中的informer开始启动监听资源的事件，将事件放到自己的队列中（具有限流特性）。处理进程从队列总获取事件开始进行任务处理。</p><blockquote><p>将新建的ReplicaSet，放入队列</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj could be an *apps.ReplicaSet, or a DeletionFinalStateUnknown marker item.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">enqueueReplicaSet</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    key, err := controller.KeyFunc(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"couldn't get key for object %+v: %v"</span>, obj, err))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rsc.queue.Add(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从队列中获取对象进行处理（具体过程见下方）</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    key, quit := rsc.queue.Get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> quit &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> rsc.queue.Done(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    err := rsc.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        rsc.queue.Forget(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"Sync %q failed with %v"</span>, key, err))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rsc.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="以startReplicaSetController为例"><a href="#以startReplicaSetController为例" class="headerlink" title="以startReplicaSetController为例"></a>以startReplicaSetController为例</h2><p>在StartControllers中initFn方法是NewControllerInitializers中初始化Controller是定义，以下主要看下startReplicaSetController。<br><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/apps.go<br>其中NewReplicaSetController主要是初始化ReplicaSetController的结构，包括apiserver的客户端，informer的回调函数等等。NewReplicaSetController-&gt;NewBaseController</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReplicaSetController</span><span class="params">(ctx ControllerContext)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: <span class="string">"apps"</span>, Version: <span class="string">"v1"</span>, Resource: <span class="string">"replicasets"</span>&#125;] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> replicaset.NewReplicaSetController(</span><br><span class="line">ctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">ctx.ClientBuilder.ClientOrDie(<span class="string">"replicaset-controller"</span>),</span><br><span class="line">replicaset.BurstReplicas,</span><br><span class="line">).Run(<span class="keyword">int</span>(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键函数run：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go<br>run中执行rsc.worker。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run begins watching and syncing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> rsc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">controllerName := strings.ToLower(rsc.Kind)</span><br><span class="line">klog.Infof(<span class="string">"Starting %v controller"</span>, controllerName)</span><br><span class="line"><span class="keyword">defer</span> klog.Infof(<span class="string">"Shutting down %v controller"</span>, controllerName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(rsc.worker, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rsc.worker即为rsc.syncHandler，而syncHandler在创建时来源于rsc.syncReplicaSet（见NewBaseController方法）<br><strong>那么我们转到syncReplicaSet</strong><br><strong>位置：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go<br><strong>updateReplicaSetStatus：</strong>在pod死亡或者新建时更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncReplicaSet will sync the ReplicaSet with the given key if it has had its expectations fulfilled,</span></span><br><span class="line"><span class="comment">// meaning it did not expect to see any more of its pods created or deleted. This function is not meant to be</span></span><br><span class="line"><span class="comment">// invoked concurrently with the same key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">syncReplicaSet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing %v %q (%v)"</span>, rsc.Kind, key, time.Since(startTime))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line"><span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"%v %v has been deleted"</span>, rsc.Kind, key)</span><br><span class="line">rsc.expectations.DeleteExpectations(key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"error converting pod selector to selector: %v"</span>, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list all pods to include the pods that don't match the rs`s selector</span></span><br><span class="line"><span class="comment">// anymore but has the stale controller ref.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Do the List and Filter in a single pass, or use an index.</span></span><br><span class="line">allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ignore inactive pods.</span></span><br><span class="line">filteredPods := controller.FilterActivePods(allPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> filteredPods are pointing to objects from cache - if you need to</span></span><br><span class="line"><span class="comment">// modify them, you need to copy it first.</span></span><br><span class="line">filteredPods, err = rsc.claimPods(rs, selector, filteredPods)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manageReplicasErr error</span><br><span class="line"><span class="keyword">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">manageReplicasErr = rsc.manageReplicas(filteredPods, rs)</span><br><span class="line">&#125;</span><br><span class="line">rs = rs.DeepCopy()</span><br><span class="line">newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Always updates status as pods come up or die.</span></span><br><span class="line">updatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Multiple things could lead to this update failing. Requeuing the replica set ensures</span></span><br><span class="line"><span class="comment">// Returning an error causes a requeue without forcing a hotloop</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Resync the ReplicaSet after MinReadySeconds as a last line of defense to guard against clock-skew.</span></span><br><span class="line"><span class="keyword">if</span> manageReplicasErr == <span class="literal">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class="line">updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class="line">rsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> manageReplicasErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转到updateReplicaSetStatus：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set_utils.go<br>调用UpdateStatus，通过apiserver更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// updateReplicaSetStatus attempts to update the Status.Replicas of the given ReplicaSet, with a single GET/PUT retry.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateReplicaSetStatus</span><span class="params">(c appsclient.ReplicaSetInterface, rs *apps.ReplicaSet, newStatus apps.ReplicaSetStatus)</span> <span class="params">(*apps.ReplicaSet, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// This is the steady state. It happens when the ReplicaSet doesn't have any expectations, since</span></span><br><span class="line"><span class="comment">// we do a periodic relist every 30s. If the generations differ but the replicas are</span></span><br><span class="line"><span class="comment">// the same, a caller might've resized to the same replica count.</span></span><br><span class="line"><span class="keyword">if</span> rs.Status.Replicas == newStatus.Replicas &amp;&amp;</span><br><span class="line">rs.Status.FullyLabeledReplicas == newStatus.FullyLabeledReplicas &amp;&amp;</span><br><span class="line">rs.Status.ReadyReplicas == newStatus.ReadyReplicas &amp;&amp;</span><br><span class="line">rs.Status.AvailableReplicas == newStatus.AvailableReplicas &amp;&amp;</span><br><span class="line">rs.Generation == rs.Status.ObservedGeneration &amp;&amp;</span><br><span class="line">reflect.DeepEqual(rs.Status.Conditions, newStatus.Conditions) &#123;</span><br><span class="line"><span class="keyword">return</span> rs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the generation number we acted on, otherwise we might wrongfully indicate</span></span><br><span class="line"><span class="comment">// that we've seen a spec update when we retry.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This can clobber an update if we allow multiple agents to write to the</span></span><br><span class="line"><span class="comment">// same status.</span></span><br><span class="line">newStatus.ObservedGeneration = rs.Generation</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getErr, updateErr error</span><br><span class="line"><span class="keyword">var</span> updatedRS *apps.ReplicaSet</span><br><span class="line"><span class="keyword">for</span> i, rs := <span class="number">0</span>, rs; ; i++ &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(fmt.Sprintf(<span class="string">"Updating status for %v: %s/%s, "</span>, rs.Kind, rs.Namespace, rs.Name) +</span><br><span class="line">fmt.Sprintf(<span class="string">"replicas %d-&gt;%d (need %d), "</span>, rs.Status.Replicas, newStatus.Replicas, *(rs.Spec.Replicas)) +</span><br><span class="line">fmt.Sprintf(<span class="string">"fullyLabeledReplicas %d-&gt;%d, "</span>, rs.Status.FullyLabeledReplicas, newStatus.FullyLabeledReplicas) +</span><br><span class="line">fmt.Sprintf(<span class="string">"readyReplicas %d-&gt;%d, "</span>, rs.Status.ReadyReplicas, newStatus.ReadyReplicas) +</span><br><span class="line">fmt.Sprintf(<span class="string">"availableReplicas %d-&gt;%d, "</span>, rs.Status.AvailableReplicas, newStatus.AvailableReplicas) +</span><br><span class="line">fmt.Sprintf(<span class="string">"sequence No: %v-&gt;%v"</span>, rs.Status.ObservedGeneration, newStatus.ObservedGeneration))</span><br><span class="line"></span><br><span class="line">rs.Status = newStatus</span><br><span class="line">updatedRS, updateErr = c.UpdateStatus(context.TODO(), rs, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> updateErr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> updatedRS, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Stop retrying if we exceed statusUpdateRetries - the replicaSet will be requeued with a rate limit.</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= statusUpdateRetries &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Update the ReplicaSet with the latest resource version for the next poll</span></span><br><span class="line"><span class="keyword">if</span> rs, getErr = c.Get(context.TODO(), rs.Name, metav1.GetOptions&#123;&#125;); getErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If the GET fails we can't trust status.Replicas anymore. This error</span></span><br><span class="line"><span class="comment">// is bound to be more interesting than the update failure.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, getErr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, updateErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PodGCController"><a href="#PodGCController" class="headerlink" title="PodGCController"></a>PodGCController</h2><blockquote><p>1.gc掉超过阈值限制的pod，按时间排序gc</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcTerminated</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">terminatedPods := []*v1.Pod&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> isPodTerminated(pod) &#123;</span><br><span class="line">terminatedPods = <span class="built_in">append</span>(terminatedPods, pod)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">terminatedPodCount := <span class="built_in">len</span>(terminatedPods)</span><br><span class="line">deleteCount := terminatedPodCount - gcc.terminatedPodThreshold</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> deleteCount &gt; terminatedPodCount &#123;</span><br><span class="line">deleteCount = terminatedPodCount</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> deleteCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.Infof(<span class="string">"garbage collecting %v pods"</span>, deleteCount)</span><br><span class="line"><span class="comment">// sort only when necessary</span></span><br><span class="line">sort.Sort(byCreationTimestamp(terminatedPods))</span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; deleteCount; i++ &#123;</span><br><span class="line">wait.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(namespace <span class="keyword">string</span>, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wait.Done()</span><br><span class="line"><span class="keyword">if</span> err := gcc.deletePod(namespace, name); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// ignore not founds</span></span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleError(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(terminatedPods[i].Namespace, terminatedPods[i].Name)</span><br><span class="line">&#125;</span><br><span class="line">wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.gc掉孤儿pod：pod上的node信息不在当前可调度的节点上，即没有和有效node绑定</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcOrphaned deletes pods that are bound to nodes that don't exist.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcOrphaned</span><span class="params">(pods []*v1.Pod, nodes []*v1.Node)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"GC'ing orphaned"</span>)</span><br><span class="line">existingNodeNames := sets.NewString()</span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">existingNodeNames.Insert(node.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add newly found unknown nodes to quarantine</span></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> pod.Spec.NodeName != <span class="string">""</span> &amp;&amp; !existingNodeNames.Has(pod.Spec.NodeName) &#123;</span><br><span class="line">gcc.nodeQueue.AddAfter(pod.Spec.NodeName, quarantineTime)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check if nodes are still missing after quarantine period</span></span><br><span class="line">deletedNodesNames, quit := gcc.discoverDeletedNodes(existingNodeNames)</span><br><span class="line"><span class="keyword">if</span> quit &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Delete orphaned pods</span></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> !deletedNodesNames.Has(pod.Spec.NodeName) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Found orphaned Pod %v/%v assigned to the Node %v. Deleting."</span>, pod.Namespace, pod.Name, pod.Spec.NodeName)</span><br><span class="line"><span class="keyword">if</span> err := gcc.deletePod(pod.Namespace, pod.Name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">0</span>).Infof(<span class="string">"Forced deletion of orphaned Pod %v/%v succeeded"</span>, pod.Namespace, pod.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.gc掉没有调度成功的pod：表现在pod的NodeName为空,主要由于资源等条件不满足</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcUnscheduledTerminating deletes pods that are terminating and haven't been scheduled to a particular node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcUnscheduledTerminating</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"GC'ing unscheduled pods which are terminating."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> pod.DeletionTimestamp == <span class="literal">nil</span> || <span class="built_in">len</span>(pod.Spec.NodeName) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Found unscheduled terminating Pod %v/%v not assigned to any Node. Deleting."</span>, pod.Namespace, pod.Name)</span><br><span class="line"><span class="keyword">if</span> err := gcc.deletePod(pod.Namespace, pod.Name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">0</span>).Infof(<span class="string">"Forced deletion of unscheduled terminating Pod %v/%v succeeded"</span>, pod.Namespace, pod.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// byCreationTimestamp sorts a list by creation timestamp, using their names as a tie breaker.</span></span><br><span class="line"><span class="keyword">type</span> byCreationTimestamp []*v1.Pod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(o) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; o[i], o[j] = o[j], o[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> o[i].CreationTimestamp.Equal(&amp;o[j].CreationTimestamp) &#123;</span><br><span class="line"><span class="keyword">return</span> o[i].Name &lt; o[j].Name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o[i].CreationTimestamp.Before(&amp;o[j].CreationTimestamp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Controller Manager&lt;/code&gt;作为集群的管理控制中心，维护集群中的所有控制器，对维持集群的稳定和自我修复，实现高可用，副本控制等起关键作用。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="controller" scheme="http://houmin.cc/tags/controller/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】ApiServer之初识API</title>
    <link href="http://houmin.cc/posts/3bc1a603/"/>
    <id>http://houmin.cc/posts/3bc1a603/</id>
    <published>2020-08-10T12:46:14.000Z</published>
    <updated>2020-08-19T13:01:04.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>ApiServer</code>作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。</p><p>kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：</p><ul><li>提供 <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用</li><li>代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；</li><li>允许对于对象状态的操作，比如Pod和Service的状态的改变，实现对象的持久化到Etcd</li><li>资源在不同版本之间的转换</li></ul><a id="more"></a><h2 id="API-Overview"><a href="#API-Overview" class="headerlink" title="API Overview"></a>API Overview</h2><p>ApiServer 主要通过对外提供HTTP API 的方式与其他组件进行交互。API首选的序列化方案是JSON，但是也支持Protobuf协议。API主要有下面三种类型：</p><ul><li>core group：主要在 <code>/api/v1</code> 下；</li><li>named groups：其 path 为 <code>/apis/$NAME/$VERSION</code>；</li><li>暴露系统状态的一些 API：如<code>/metrics</code> 、<code>/healthz</code> 等；</li></ul><p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-space-1.png"></p><h3 id="GVK-GVR"><a href="#GVK-GVR" class="headerlink" title="GVK/GVR"></a>GVK/GVR</h3><p><img alt="Terminology" data-src="https://www.openshift.com/hs-fs/hubfs/Imported_Blog_Media/API-server-gvr.png?width=400&amp;height=152&amp;name=API-server-gvr.png"></p><p>在Kubernetes中，要想定位一个对象，我们需要指定GVK或者GVR。比如这里声明了 apiVersion 是 <code>apps/v1</code>，其实就是隐含了 <code>Group</code> 是 apps，<code>Version</code> 是 v1，<code>Kind</code> 就是定义的 DaemonSet，而 kubectl 接收到这个声明之后，就可以根据这个声明去调用 API Server 对应的 URL 去获取信息，例如这个就是 <code>/api/apps/v1/daemonset</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br></pre></td></tr></table></figure><p>对应到实际的URI的请求组织形式，如下图所示：</p><p><img alt="GVR" data-src="http://images.liuliqiang.info/2019/11/24/02/25/56/d14b874da710/"></p><p>通过结构体字段可以发现，它们其实就是Group、Version、Kind、Resource的不同组合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersionKind <span class="keyword">struct</span> &#123;</span><br><span class="line">Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">Kind    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersionResource <span class="keyword">struct</span> &#123;</span><br><span class="line">Group    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">Resource <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=resource"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupKind <span class="keyword">struct</span> &#123;</span><br><span class="line">Group <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Kind  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h3><p>Kubernetes中的每个对象都有一个字段 <code>Kind</code> 表明其类型，以Pod为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><code>Kubernetes</code> 中 Kind 有三种类型：</p><ul><li>系统中持久的实体对象，比如 <code>Pod</code> , <code>Namespace</code></li><li>一系列有某些共同特征的实体列表，比如 <code>PodLists</code>，<code>NodeLists</code></li><li>用于某些特定应用的一些非持久的实体，比如 <code>APIGroup</code>，<code>APIResource</code>, <code>Status</code></li></ul><p>Kind就是一个资源对象对应的种类 kind是通过<code>Kind=reflector.TypeOf(&amp;Pod{}).Elem().Name()</code>进行取值，取得的就是Pod这个结构体的名字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> PodList <span class="keyword">struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> NodeList <span class="keyword">struct</span></span><br></pre></td></tr></table></figure><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p><code>API Group</code> 是一些有关系的Kinds的集合，比如所有的批处理对象，<code>Job</code> 或者 <code>ScheduledJob</code> 都在 <code>batch</code>这个API Group。</p><p>各个Group是相互独立的，发展速度也不同，所有每个Group都会有不同的Version，而kubernetes是通过插件的方式来使用各个Group的，可以根据需求决定使用哪个Group。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Group="core"</span></span><br><span class="line"><span class="string">Version=v1</span></span><br><span class="line"></span><br><span class="line"><span class="string">Group="apps"</span></span><br><span class="line"><span class="string">Version=v1beta1</span></span><br></pre></td></tr></table></figure><p><code>GroupMeta</code>主要包括Group的元信息，里面的成员RESTMapper，与APIGroupVersion一样，其实APIGroupVersion的RESTMapper直接取值于GroupMeta的RESTMapper。一个Group可能包含多个版本，存储在 GroupVersions 中，而 GroupVersion 是默认存储在etcd中的版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupMeta <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// GroupVersion represents the preferred version of the group.</span></span><br><span class="line"><span class="comment">// 该group的默认版本</span></span><br><span class="line">GroupVersion unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// GroupVersions is Group + all versions in that group.</span></span><br><span class="line"><span class="comment">// 该Group中可能会有多个版本，该字段就包含了所有的versions</span></span><br><span class="line">GroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// Codec is the default codec for serializing output that should use</span></span><br><span class="line"><span class="comment">// the preferred version.  Use this Codec when writing to</span></span><br><span class="line"><span class="comment">// disk, a data store that is not dynamically versioned, or in tests.</span></span><br><span class="line"><span class="comment">// This codec can decode any object that the schema is aware of.</span></span><br><span class="line"><span class="comment">// 用于编解码</span></span><br><span class="line">Codec runtime.Codec</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelfLinker can set or get the SelfLink field of all API types.</span></span><br><span class="line"><span class="comment">// to go through the InterfacesFor method below.</span></span><br><span class="line">SelfLinker runtime.SelfLinker</span><br><span class="line"></span><br><span class="line"><span class="comment">// RESTMapper provides the default mapping between REST paths and the objects declared in api.Scheme and all known</span></span><br><span class="line"><span class="comment">// versions.</span></span><br><span class="line"><span class="comment">// RESTMapper提供 REST路径 与 那些在api.Scheme和所有已知版本中声明的对象之间的默认映射。用于类型，对象之间的转换</span></span><br><span class="line"></span><br><span class="line">RESTMapper meta.RESTMapper</span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfacesFor returns the default Codec and ResourceVersioner for a given version</span></span><br><span class="line"><span class="comment">// string, or an error if the version is not known.</span></span><br><span class="line"><span class="comment">// function provided below once every place that populates this field has been changed.</span></span><br><span class="line">InterfacesFor <span class="function"><span class="keyword">func</span><span class="params">(version unversioned.GroupVersion)</span> <span class="params">(*meta.VersionInterfaces, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfacesByVersion stores the per-version interfaces.</span></span><br><span class="line">InterfacesByVersion <span class="keyword">map</span>[unversioned.GroupVersion]*meta.VersionInterfaces</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>每个 API Group 下面都能存在有多个 version 版本。为了扩展性，Kubernetes支持多版本的API路径，比如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1/</code>， 不同版本的API意味着不同程度的稳定性和支持度。比如在一个 group 群组中最早有第一个 v1alpha1 版本，后来中间发展到了 v1beta1 版本，最终发展到 v1 的稳定版本。 如果在系统创建了一个 v1beta1 版本的对象，那么它能过被 Group 任一支持的版本（ 比如v1 ）检索到， 这是由于 API server 能够支持不同版本对象之间的无损耗转换。</p><p><strong>type GroupVersion struct</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GroupVersion</code>中就是两个string类型，<code>Group</code>和<code>Version</code>，分别对应了api所处的分组和版本，这也是kubernetes实现多版本的基础。</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>Resource 代表以 JSON 格式通过 HTTP 发送或检索的资源实体。 它既可以使一个单独的resource资源（比如…/namespaces/default，也可以是一组resource 资源（比如…/jobs）。 这里说明一下 Reource 和 Kind 的区别： 其实基本上都是一个概念，只是 Kind 表示一个种类，在实际中它是首字母大写的； Resource 表示资源，在实际中它是全部小写的，并且有单数和复数之分。我们可以把Kind和Resource的关系理解成面向对象编程中类与对象的关系，Kind 其实就是一个类，用于描述对象的；而 Resource 就是具体的 Kind，可以理解成类已经实例化成对象。</p><p>Resource就是指定了一个名字和kind的资源对象，不管它有没有namespace。 resource是通过<code>plural, singular := KindToResource(kind)</code>取值，singular是将Kind转换为小写字母，而plural是变为复数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIResource <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// name is the name of the resource.</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name" protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line"><span class="comment">// namespaced indicates if a resource is namespaced or not.</span></span><br><span class="line">Namespaced <span class="keyword">bool</span> <span class="string">`json:"namespaced" protobuf:"varint,2,opt,name=namespaced"`</span></span><br><span class="line"><span class="comment">// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')</span></span><br><span class="line">Kind <span class="keyword">string</span> <span class="string">`json:"kind" protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reousrce := unversioned.APIResource&#123;</span><br><span class="line">Name:       <span class="string">"nodes"</span>, </span><br><span class="line">Namespaced: <span class="literal">false</span>,</span><br><span class="line">Kind:       <span class="string">"Node"</span>, </span><br><span class="line">&#125;</span><br><span class="line">reousrce = unversioned.APIResource&#123;</span><br><span class="line">Name:       <span class="string">"pods"</span>,</span><br><span class="line">Namespaced: <span class="literal">true</span>,</span><br><span class="line">Kind:       <span class="string">"Pod"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="资源外部版本与内部版本"><a href="#资源外部版本与内部版本" class="headerlink" title="资源外部版本与内部版本"></a>资源外部版本与内部版本</h4><h4 id="资源代码定义"><a href="#资源代码定义" class="headerlink" title="资源代码定义"></a>资源代码定义</h4><h4 id="将资源注册到资源注册表"><a href="#将资源注册到资源注册表" class="headerlink" title="将资源注册到资源注册表"></a>将资源注册到资源注册表</h4><h4 id="资源首选版本"><a href="#资源首选版本" class="headerlink" title="资源首选版本"></a>资源首选版本</h4><h4 id="资源操作方法"><a href="#资源操作方法" class="headerlink" title="资源操作方法"></a>资源操作方法</h4><h4 id="资源与命名空间"><a href="#资源与命名空间" class="headerlink" title="资源与命名空间"></a>资源与命名空间</h4><h4 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h4><h4 id="资源对象描述文件定义"><a href="#资源对象描述文件定义" class="headerlink" title="资源对象描述文件定义"></a>资源对象描述文件定义</h4><h3 id="Kubernetes内置资源全图"><a href="#Kubernetes内置资源全图" class="headerlink" title="Kubernetes内置资源全图"></a>Kubernetes内置资源全图</h3><h3 id="runtime-Object-类型基石"><a href="#runtime-Object-类型基石" class="headerlink" title="runtime.Object 类型基石"></a>runtime.Object 类型基石</h3><h3 id="Unstructured数据"><a href="#Unstructured数据" class="headerlink" title="Unstructured数据"></a>Unstructured数据</h3><h3 id="Scheme资源注册表"><a href="#Scheme资源注册表" class="headerlink" title="Scheme资源注册表"></a>Scheme资源注册表</h3><h4 id="Scheme资源注册表数据结构"><a href="#Scheme资源注册表数据结构" class="headerlink" title="Scheme资源注册表数据结构"></a>Scheme资源注册表数据结构</h4><h4 id="资源注册表注册方法"><a href="#资源注册表注册方法" class="headerlink" title="资源注册表注册方法"></a>资源注册表注册方法</h4><h4 id="资源注册表查询方法"><a href="#资源注册表查询方法" class="headerlink" title="资源注册表查询方法"></a>资源注册表查询方法</h4><h3 id="Codec编解码器"><a href="#Codec编解码器" class="headerlink" title="Codec编解码器"></a>Codec编解码器</h3><h4 id="Codec编解码实例化"><a href="#Codec编解码实例化" class="headerlink" title="Codec编解码实例化"></a>Codec编解码实例化</h4><h4 id="jsonSerializer-与-yamlSerializer序列化器"><a href="#jsonSerializer-与-yamlSerializer序列化器" class="headerlink" title="jsonSerializer 与 yamlSerializer序列化器"></a>jsonSerializer 与 yamlSerializer序列化器</h4><h4 id="protobufSerializer序列化器"><a href="#protobufSerializer序列化器" class="headerlink" title="protobufSerializer序列化器"></a>protobufSerializer序列化器</h4><h3 id="Converter-资源版本转换器"><a href="#Converter-资源版本转换器" class="headerlink" title="Converter 资源版本转换器"></a>Converter 资源版本转换器</h3><h4 id="Converter-转换器数据结构"><a href="#Converter-转换器数据结构" class="headerlink" title="Converter 转换器数据结构"></a>Converter 转换器数据结构</h4><h4 id="Converter注册转换函数"><a href="#Converter注册转换函数" class="headerlink" title="Converter注册转换函数"></a>Converter注册转换函数</h4><h4 id="Converter-资源版本转换原理"><a href="#Converter-资源版本转换原理" class="headerlink" title="Converter 资源版本转换原理"></a>Converter 资源版本转换原理</h4><h2 id="API-Request-Flow"><a href="#API-Request-Flow" class="headerlink" title="API Request Flow"></a>API Request Flow</h2><p>了解了 kube-apiserver 的 API 后，下面会介绍 kube-apiserver 如何处理一个 API 请求，一个请求完整的流程如下图所示：</p><p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-flow-2.png"></p><p>关于 API 的处理代码都在 <code>k8s.io/pkg/api</code> 包中，会处理来自集群内部和集群外部的API请求。</p><p>此处以一次 POST 请求示例说明，当请求到达 kube-apiserver 时，kube-apiserver 首先会执行在 http filter chain 中注册的过滤器链。该过滤器对其执行一系列过滤操作，主要有认证、鉴权等检查操作。当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互。</p><h3 id="Filter-Chain"><a href="#Filter-Chain" class="headerlink" title="Filter Chain"></a>Filter Chain</h3><p>一个HTTP Request首先会被 <code>DefaultBuildHandlerChain</code>注册的 filter chain处理，每一个filter会传递各自的info到 <code>ctx.RequestInfo</code>上。</p><ul><li><code>WithRequestInfo()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/requestinfo.go" target="_blank" rel="external nofollow noopener noreferrer">requestinfo.go</a> attaches a <code>RequestInfo</code> to the context</li><li><code>WithMaxInFlightLimit()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/maxinflight.go" target="_blank" rel="external nofollow noopener noreferrer">maxinflight.go</a> limits the number of in-flight requests</li><li><code>WithTimeoutForNonLongRunningRequests()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/timeout.go" target="_blank" rel="external nofollow noopener noreferrer">timeout.go</a> times out non-long-running requests like most <code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code> requests in contrast to long-running requests like watches and proxy requests</li><li><code>WithPanicRecovery()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/wrap.go" target="_blank" rel="external nofollow noopener noreferrer">wrap.go</a> wraps an handler to recover and log panics</li><li><code>WithCORS()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/cors.go" target="_blank" rel="external nofollow noopener noreferrer">cors.go</a> provides a CORS implementation; CORS stands for Cross-Origin Resource Sharing and is a mechanism that allows JavaScript embedded in a HTML page to make XMLHttpRequests to a domain different from the one the JavaScript originated from.</li><li><code>WithAuthentication()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authentication.go" target="_blank" rel="external nofollow noopener noreferrer">authentication.go</a> tries to authenticate the given request as a user and stores the user info in the provided context. On success, the <code>Authorization</code> HTTP header is removed from the request.</li><li><code>WithAudit()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/audit.go" target="_blank" rel="external nofollow noopener noreferrer">audit.go</a> decorates the handler with audit logging information for all incoming requests The audit log entries contain infos such as source IP of the request, user invoking the operation, and namespace of the request.</li><li><code>WithImpersonation()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/impersonation.go" target="_blank" rel="external nofollow noopener noreferrer">impersonation.go</a> handles user impersonation, by checking requests that attempt to change the user (similar to sudo).</li><li><code>WithAuthorization()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authorization.go" target="_blank" rel="external nofollow noopener noreferrer">authorization.go</a> passes all authorized requests on to multiplexer which dispatched the request to the right handler, and returns a forbidden error otherwise.</li></ul><ul><li>WithRequestInfo：</li><li>MaxInflightLimit</li><li>TimeoutForNonLongRunningRequests</li><li>Panic Recovery</li><li>CORS</li><li>Authentication</li><li>Audit</li><li>Impersonation</li><li>Authorization</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultBuildHandlerChain</span><span class="params">(apiHandler http.Handler, c *Config)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line"><span class="keyword">if</span> c.FlowControl != <span class="literal">nil</span> &#123;</span><br><span class="line">handler = genericfilters.WithPriorityAndFairness(handler, c.LongRunningFunc, c.FlowControl)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc)</span><br><span class="line">&#125;</span><br><span class="line">handler = genericapifilters.WithImpersonation(handler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">handler = genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)</span><br><span class="line">failedHandler := genericapifilters.Unauthorized(c.Serializer)</span><br><span class="line">failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences)</span><br><span class="line">handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"true"</span>)</span><br><span class="line">handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc, c.RequestTimeout)</span><br><span class="line">handler = genericfilters.WithWaitGroup(handler, c.LongRunningFunc, c.HandlerChainWaitGroup)</span><br><span class="line">handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver)</span><br><span class="line"><span class="keyword">if</span> c.SecureServing != <span class="literal">nil</span> &amp;&amp; !c.SecureServing.DisableHTTP2 &amp;&amp; c.GoawayChance &gt; <span class="number">0</span> &#123;</span><br><span class="line">handler = genericfilters.WithProbabilisticGoaway(handler, c.GoawayChance)</span><br><span class="line">&#125;</span><br><span class="line">handler = genericapifilters.WithAuditAnnotations(handler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">handler = genericapifilters.WithWarningRecorder(handler)</span><br><span class="line">handler = genericapifilters.WithCacheControl(handler)</span><br><span class="line">handler = genericfilters.WithPanicRecovery(handler)</span><br><span class="line"><span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Handler-Operation"><a href="#Handler-Operation" class="headerlink" title="Handler Operation"></a>Handler Operation</h3><p>当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互，在 handler 中的主要的操作如下所示：</p><p><img alt="API-server-storage-flow-2" data-src="http://cdn.tianfeiyu.com/API-server-storage-flow-2.png"></p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a><strong>Decoder</strong></h3><p>在解码时，首先从 HTTP path 中获取期待的 version，然后使用 scheme 以正确的 version 创建一个与之匹配的空对象，并使用 JSON 或 protobuf 解码器进行转换，在转换的第一步中，如果用户省略了某些字段，Decoder 会把其设置为默认值。</p><h3 id="Admission"><a href="#Admission" class="headerlink" title="Admission"></a><strong>Admission</strong></h3><p>在解码完成后，需要通过验证集群的全局约束来检查是否可以创建或更新对象，并根据集群配置设置默认值。在 <code>k8s.io/kubernetes/plugin/pkg/admission</code> 目录下可以看到 kube-apiserver 可以使用的所有全局约束插件，kube-apiserver 在启动时通过设置 <code>--enable-admission-plugins</code> 参数来开启需要使用的插件，通过 <code>ValidatingAdmissionWebhook</code> 或 <code>MutatingAdmissionWebhook</code> 添加的插件也都会在此处进行工作。</p><h3 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a><strong>Validation</strong></h3><p>主要检查 object 中字段的合法性。</p><p>在 handler 中执行完以上操作后最后会执行与 etcd 相关的操作，POST 操作会将数据写入到 etcd 中，以上在 handler 中的主要处理流程如下所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1beta1 ⇒ internal ⇒    |<span class="string">    ⇒       </span>|<span class="string">    ⇒  v1  ⇒ json/yaml ⇒ etcd</span></span><br><span class="line"><span class="string">                     admission    validation</span></span><br></pre></td></tr></table></figure><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img alt="apiserver diagram" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png"></p><ul><li>Scheme：定义了资源序列化和反序列化的方法，以及资源类型和版本的对应关系</li><li>Storage：是对资源的完整封装，实现了资源创建、删除、watch等操作</li><li>APIGroupInfo：是同一个group下所有资源的集合</li></ul><p>每个资源对应着两个版本：</p><ul><li>External Object：这个版本是对外给用户访问创建的接口对象，比如使用yaml或json创建对象时，都要使用External Object</li><li>Internal Object：这个版本是核心对象，实现了资源的创建和删除，对应了在ETCD中持久化的版本</li></ul><p>这两个版本的资源是需要相互转换的，而转换的函数就需要事先初始化到Scheme中， 多个external version版本之间的资源进行相互转换，都是需要通过internal version进行中转。所以在ETCD中存储的资源是带版本的，这也是kubernetes能实现多版本转换的关键。</p><h2 id="组件构成"><a href="#组件构成" class="headerlink" title="组件构成"></a>组件构成</h2><p>ApiServer 共由 3 个组件构成（Aggregator、KubeAPIServer、APIExtensionServer），这些组件依次通过 Delegation 处理请求：</p><ul><li><strong>Aggregator</strong>：暴露的功能类似于一个七层负载均衡，将来自用户的请求拦截转发给其他服务器，并且负责整个 APIServer 的 Discovery 功能；</li><li><strong>KubeAPIServer</strong> ：负责对请求的一些通用处理，认证、鉴权等，以及处理各个内建资源的 REST 服务；</li><li><strong>APIExtensionServer</strong>：主要处理 CustomResourceDefinition（CRD）和 CustomResource（CR）的 REST 请求，也是 Delegation 的最后一环，如果对应 CR 不能被处理的话则会返回 404。</li></ul><p>Aggregator 和 APIExtensionsServer 对应两种主要扩展 APIServer 资源的方式，即分别是 AA 和 CRD。</p><h3 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h3><p>Aggregator 通过 APIServices 对象关联到某个 Service 来进行请求的转发，其关联的 Service 类型进一步决定了请求转发形式。Aggregator 包括一个 <code>GenericAPIServer</code> 和维护自身状态的 Controller。其中 <code>GenericAPIServer</code> 主要处理 <code>apiregistration.k8s.io</code> 组下的 APIService 资源请求。</p><p><strong>Aggregator 除了处理资源请求外还包含几个 controller：</strong></p><ul><li><code>apiserviceRegistrationController</code>：负责 APIServices 中资源的注册与删除；</li><li><code>availableConditionController</code>：维护 APIServices 的可用状态，包括其引用 Service 是否可用等；</li><li><code>autoRegistrationController</code>：用于保持 API 中存在的一组特定的 APIServices；</li><li><code>crdRegistrationController</code>：负责将 CRD GroupVersions 自动注册到 APIServices 中；</li><li><code>openAPIAggregationController</code>：将 APIServices 资源的变化同步至提供的 OpenAPI 文档；</li></ul><p>kubernetes 中的一些附加组件，比如 metrics-server 就是通过 Aggregator 的方式进行扩展的，实际环境中可以通过使用 <a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha" target="_blank" rel="external nofollow noopener noreferrer">apiserver-builder</a> 工具轻松以 Aggregator 的扩展方式创建自定义资源。</p><h4 id="启用-API-Aggregation"><a href="#启用-API-Aggregation" class="headerlink" title="启用 API Aggregation"></a>启用 API Aggregation</h4><p>在 kube-apiserver 中需要增加以下配置来开启 API Aggregation：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--proxy-client-cert-file=/etc/kubernetes/certs/proxy.crt</span><br><span class="line">--proxy-client-key-file=/etc/kubernetes/certs/proxy.key</span><br><span class="line">--requestheader-client-ca-file=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line">--requestheader-allowed-names=aggregator</span><br><span class="line">--requestheader-extra-headers-prefix=X-Remote-Extra-</span><br><span class="line">--requestheader-group-headers=X-Remote-Group</span><br><span class="line">--requestheader-username-headers=X-Remote-User</span><br></pre></td></tr></table></figure><h3 id="KubeAPIServer"><a href="#KubeAPIServer" class="headerlink" title="KubeAPIServer"></a>KubeAPIServer</h3><p>KubeAPIServer 主要是提供对 API Resource 的操作请求，为 kubernetes 中众多 API 注册路由信息，暴露 RESTful API 并且对外提供 kubernetes service，使集群中以及集群外的服务都可以通过 RESTful API 操作 kubernetes 中的资源。</p><h3 id="APIExtensionServer"><a href="#APIExtensionServer" class="headerlink" title="APIExtensionServer"></a>APIExtensionServer</h3><p>APIExtensionServer 作为 Delegation 链的最后一层，是处理所有用户通过 Custom Resource Definition 定义的资源服务器。</p><p>其中包含的 controller 以及功能如下所示：</p><ul><li><code>openapiController</code>：将 crd 资源的变化同步至提供的 OpenAPI 文档，可通过访问 <code>/openapi/v2</code> 进行查看；</li><li><code>crdController</code>：负责将 crd 信息注册到 apiVersions 和 apiResources 中，两者的信息可通过 <code>$ kubectl api-versions</code> 和 <code>$ kubectl api-resources</code> 查看；</li><li><code>namingController</code>：检查 crd obj 中是否有命名冲突，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>establishingController</code>：检查 crd 是否处于正常状态，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>nonStructuralSchemaController</code>：检查 crd obj 结构是否正常，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>apiApprovalController</code>：检查 crd 是否遵循 kubernetes API 声明策略，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>finalizingController</code>：类似于 finalizes 的功能，与 CRs 的删除有关；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ApiServer&lt;/code&gt;作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。&lt;/p&gt;
&lt;p&gt;kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供 &lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/kubernetes-api/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Kubernetes API&lt;/a&gt;，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用&lt;/li&gt;
&lt;li&gt;代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；&lt;/li&gt;
&lt;li&gt;允许对于对象状态的操作，比如Pod和Service的状态的改变，实现对象的持久化到Etcd&lt;/li&gt;
&lt;li&gt;资源在不同版本之间的转换&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="apiserver" scheme="http://houmin.cc/tags/apiserver/"/>
    
  </entry>
  
  <entry>
    <title>所谓生活</title>
    <link href="http://houmin.cc/posts/47d0d3b/"/>
    <id>http://houmin.cc/posts/47d0d3b/</id>
    <published>2020-08-09T14:20:20.000Z</published>
    <updated>2020-08-21T08:11:30.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很久没有出去走走了，趁着夏天还没有结束，在封闭培训前去什刹海走了走，看到了生活的另一种可能。这里是「朝花夕拾」第二十二期，今天我们聊一聊生活。</p><a id="more"></a><h2 id="所见"><a href="#所见" class="headerlink" title="所见"></a>所见</h2><p>一直说要拍拍夏天的荷花，入职一个月以来，周末却一直呆在家里，没有出门。一来是外面太热，二来一直没有把自己的时间安排好，迟迟没有出门。下周要去房山参加一个星期的封闭培训，等到回来时，北京的夏天就过去了。想到这里，立马敲定晚上出门，带着相机，坐地铁到达什刹海公园。</p><p>走出地铁第一感受是，外面人好多。这不是我第一次来这里了，从烟袋斜街进去，转后海一条街，已经成了我的惯常路线。然而我们想到的是，即使国内仍然被疫情阴影笼罩，什刹海这里已经摩肩接踵，除了口罩已经不太能够看出疫情的痕迹了。</p><p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily.png"></p><p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily2.png"></p><p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily3.png"></p><p>第二个让我感触比较大的是人们的生活状态。踢毽子、抽陀螺、跳舞、遛狗、打球、跑步，大家的状态都很放松，可以自在的玩自己的爱好。</p><p><img alt="荷花市坊抽陀螺的大爷" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_pick.png"></p><p><img alt="地安门两个人一起跳舞的叔叔阿姨" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dance.png"></p><p><img alt="走到景山后街，见证了两个导盲犬的相遇与分离" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dogs1.png"></p><p><img alt="他们两个明天应该还会相遇吧" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_forbidden-dogs2.png"></p><p><img alt="狗狗主人还热情地给我看了他平时拍到的狗狗照片" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dogs3.png"></p><p>这与我在办公室的状态很不一样。在平常的日子里，每天除了上下班就没有其他的生活了。周末自己宅在家里，也不是这种惬意。总觉得有事情要做，总觉得有事情没有做完。这种状态，只有在找完工作之后的那半年才有吧。</p><h2 id="所闻"><a href="#所闻" class="headerlink" title="所闻"></a>所闻</h2><p>继续往景山走，却不想景区已经关门，只好往故宫走。</p><p><img alt="在角楼，一边也在拍角楼的素不相识的大哥主动提出借给我三脚架，于是才有了这张照片" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_forbidden-city.png"></p><p>拍角楼的时候，一个大爷主动跟我说话，推荐我拍拍景山前面的灯。本以为是一个简单的搭话，没想到我们两个聊了一个多小时的庄子、道与术、中西方哲学。这可能是这段时间里我交流密度最多的一个小时了。真的很奇妙，本是互不相识的人，却可以因为一方的主动聊起来，聊完之后也拂袖而去。与之相反，在办公室中，虽然也是每天都见面，但是实际上却说不上什么话。</p><h2 id="所想"><a href="#所想" class="headerlink" title="所想"></a>所想</h2><p>总的来说，这次外出让我感到很开心，让我感觉到城市中人与人的连接性，让我感到了北京的可爱。这些都是实实在在存在的人，他们都有着自己的生活。就是这样，你是可以变得更加主动一些的，没准你就可以发现难得的惊喜。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没有出去走走了，趁着夏天还没有结束，在封闭培训前去什刹海走了走，看到了生活的另一种可能。这里是「朝花夕拾」第二十二期，今天我们聊一聊生活。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_forbidden-city.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="夏天" scheme="http://houmin.cc/tags/%E5%A4%8F%E5%A4%A9/"/>
    
      <category term="故宫" scheme="http://houmin.cc/tags/%E6%95%85%E5%AE%AB/"/>
    
      <category term="什刹海" scheme="http://houmin.cc/tags/%E4%BB%80%E5%88%B9%E6%B5%B7/"/>
    
      <category term="生活" scheme="http://houmin.cc/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Go Module</title>
    <link href="http://houmin.cc/posts/55d129f1/"/>
    <id>http://houmin.cc/posts/55d129f1/</id>
    <published>2020-08-07T14:07:31.000Z</published>
    <updated>2020-08-22T08:36:58.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="包管理机制"><a href="#包管理机制" class="headerlink" title="包管理机制"></a>包管理机制</h2><p>Go 的包管理方式是逐渐演进的， 最初是 monorepo 模式，所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包，不过这种包管理显然是有问题，由于包依赖可能会引入破坏性更新，生产环境和测试环境会出现运行不一致的问题。</p><p>从 v1.5 开始开始引入 vendor 包模式，如果项目目录下有 vendor 目录，那么 go 工具链会优先使用 vendor 内的包进行编译、测试等，这之后第三方的包管理思路都是通过这种方式来实现，比如说由社区维护准官方包管理工具 dep。</p><a id="more"></a><p>不过官方并不认同这种方式，在 v1.11 中加入了 Go Module 作为官方包管理形式，就这样 dep 无奈的结束了使命。最初的 Go Module 提案的名称叫做 vgo，下面为了介绍简称为 gomod。不过在 v1.11 和 v1.12 的 Go 版本中 gomod 是不能直接使用的。可以通过 <code>go env</code> 命令返回值的 <code>GOMOD</code> 字段是否为空来判断是否已经开启了 gomod，如果没有开启，可以通过设置环境变量 <code>export GO111MODULE=on</code> 开启。</p><p>目前 gomod 在 Go v1.12 功能基本稳定，到下一个版本 v1.13 将默认开启，是时候开始在项目中使用 gomod 了。</p><p>自从 Go 官方从去年推出 1.11 之后，增加新的依赖管理模块并且更加易于管理项目中所需要的模块。模块是存储在文件树中的 Go 包的集合，其根目录中包含 go.mod 文件。 go.mod 文件定义了模块的模块路径，它也是用于根目录的导入路径，以及它的依赖性要求。每个依赖性要求都被写为模块路径和特定语义版本。</p><p>从 Go 1.11 开始，Go 允许在 $GOPATH/src 外的任何目录下使用 go.mod 创建项目。在 $GOPATH/src 中，为了兼容性，Go 命令仍然在旧的 GOPATH 模式下运行。从 Go 1.13 开始，模块模式将成为默认模式。</p><p>Go在构建设计方面深受Google内部开发实践的影响，比如go get的设计就深受<a href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/pdf" target="_blank" rel="external nofollow noopener noreferrer">Google内部单一代码仓库(single monorepo)和基于主干(trunk/mainline based)的开发模型</a>的影响：只获取Trunk/mainline代码和版本无感知。</p><p><img alt="img{512x368}" data-src="https://tonybai.com/wp-content/uploads/google-trunk-based-and-release-branch-dev-model.png"></p><blockquote><p>Google内部基于主干的开发模型：<br>– 所有开发人员基于主干trunk/mainline开发：提交到trunk或从trunk获取最新的代码（同步到本地workspace）<br>– 版本发布时，建立Release branch，release branch实质上就是某一个时刻主干代码的快照；<br>– 必须同步到release branch上的bug fix和增强改进代码也通常是先在主干上提交(commit)，然后再cherry-pick到release branch上</p></blockquote><p>我们知道go get获取的代码会放在$GOPATH/src下面，而go build会在$GOROOT/src和$GOPATH/src下面按照import path去搜索package，由于go get 获取的都是各个package repo的trunk/mainline的代码，因此，<a href="https://tonybai.com/2015/07/10/some-changes-in-go-1-5/" target="_blank" rel="external nofollow noopener noreferrer">Go 1.5</a>之前的Go compiler都是基于目标Go程序依赖包的trunk/mainline代码去编译的。这样的机制带来的问题是显而易见的，至少包括：</p><ul><li>因依赖包的trunk的变化，导致不同人获取和编译你的包/程序时得到的结果实质是不同的，即不能实现reproduceable build</li><li>因依赖包的trunk的变化，引入不兼容的实现，导致你的包/程序无法通过编译</li><li>因依赖包演进而无法通过编译，导致你的包/程序无法通过编译</li></ul><p>为了实现reporduceable build，Go 1.5引入了<a href="https://tonybai.com/2015/07/31/understand-go15-vendor/" target="_blank" rel="external nofollow noopener noreferrer">Vendor机制</a>，Go编译器会优先在vendor下搜索依赖的第三方包，这样如果开发者将特定版本的依赖包存放在vendor下面并提交到code repo，那么所有人理论上都会得到同样的编译结果，从而实现reporduceable build。</p><p>在Go 1.5发布后的若干年，gopher们把注意力都集中在如何利用vendor解决包依赖问题，从手工添加依赖到vendor、手工更新依赖，到一众包依赖管理工具的诞生：比如: <a href="https://github.com/kardianos/govendor" target="_blank" rel="external nofollow noopener noreferrer">govendor</a>、<a href="https://github.com/Masterminds/glide" target="_blank" rel="external nofollow noopener noreferrer">glide</a>以及号称准官方工具的<a href="https://github.com/golang/dep" target="_blank" rel="external nofollow noopener noreferrer">dep</a>，努力地尝试着按照当今主流思路解决着诸如：“钻石型依赖”等难题。</p><p>正当gopher认为dep将“顺理成章”地升级为go toolchain一部分的时候，vgo横空出世，并通过对“Semantic Import Versioning”和”Minimal Version Selected”的设定，在原Go tools上简单快速地实现了Go原生的包依赖管理方案 。vgo就是go module的前身。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>你可以在 $GOPATH/src 之外的任何地方创建一个新的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /tmp/scratchpad/repo &amp;&amp; <span class="built_in">cd</span> /tmp/scratchpad/repo</span><br></pre></td></tr></table></figure><p>初始化一个新的模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init github.com/SimpCosm/repo</span><br><span class="line">go: creating new go.mod: module github.com/SimpCosm/repo</span><br></pre></td></tr></table></figure><p>成功之后你会发现目录下会生成一个 go.mod 文件。首行为当前的模块名称，接下来是 go 的使用版本。这两行和 <code>npm package.json</code> 的 <code>name</code> 和 <code>engine</code> 字段的功能很类似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat go.mod</span><br><span class="line">module github.com/SimpCosm/repo</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure><p>创建一个文件 main.go 然后加入以下代码，这里直接 import 了 Go 维护者 Russ Cox 写一个简单的库，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"rsc.io/quote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(quote.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并且运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o hello</span><br><span class="line">go: finding module <span class="keyword">for</span> package rsc.io/quote</span><br><span class="line">go: downloading rsc.io/quote v1.5.2</span><br><span class="line">go: found rsc.io/quote <span class="keyword">in</span> rsc.io/quote v1.5.2</span><br><span class="line">go: downloading rsc.io/sampler v1.3.0</span><br><span class="line">go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">$ ./hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><p><code>go build</code> 之后，会在 go.mod 引入所需要的依赖包。之后再来看看 go.mod 文件的情况，require 就是 gin 框架所需要的所有依赖包 并且在每个依赖包的后面已经表明了版本号。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module github.com/SimpCosm/repo</span><br><span class="line"></span><br><span class="line">go <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>与此同时，工程目录下多了一个 <code>go.sum</code>文件，有点类似于 <code>npm package-lock.json</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">golang.org&#x2F;x&#x2F;text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8&#x3D;</span><br><span class="line">golang.org&#x2F;x&#x2F;text v0.0.0-20170915032832-14c0d48ead0c&#x2F;go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi&#x2F;IjpwHt7yyuwOQ&#x3D;</span><br><span class="line">rsc.io&#x2F;quote v1.5.2 h1:w5fcysjrx7yqtD&#x2F;aO+QwRjYZOKnaM9Uh2b40tElTs3Y&#x3D;</span><br><span class="line">rsc.io&#x2F;quote v1.5.2&#x2F;go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0&#x3D;</span><br><span class="line">rsc.io&#x2F;sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh&#x2F;QiW4&#x3D;</span><br><span class="line">rsc.io&#x2F;sampler v1.3.0&#x2F;go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA&#x3D;</span><br></pre></td></tr></table></figure><p>gomod 不会在 <code>$GOPATH/src</code> 目录下保存 <code>rsc.io/quote</code> 包的源码，而是包源码和链接库保存在 <code>$GOPATH/pkg/mod</code> 目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls $GOPATH&#x2F;pkg&#x2F;mod</span><br><span class="line">cache      golang.org rsc.io</span><br></pre></td></tr></table></figure><p>除了 <code>go run</code> 命令以外，<code>go build</code>、<code>go test</code> 等命令也能自动下载相关依赖包。</p><h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>可以看到，在上面的示例中完全没有使用 <code>go get</code> 命令，日常的工作流如下：</p><ul><li>编写 <code>.go</code> 代码，根据需要添加 import statements</li><li><code>go build</code> 或者 <code>go test</code> 命令会自动添加下载新的依赖来满足 import 的要求，并且更新 <code>go.mod</code> 文件</li><li>当对依赖的版本有特殊要求的时候，可以使用 <code>go get foo@v1.2.3</code>, <code>go get foo@master</code>, <code>go get foo@e3702bed2</code> 命令，或者直接编辑 <code>go.mod</code> 文件</li></ul><p>使用较多的命令初识：</p><ul><li><code>go list -m all</code> — 查看在编译中所有直接和非直接依赖的最终版本</li><li><code>go list -u -m all</code> — 查看所有直接和非直接依赖可用的升级补丁</li><li><code>go get -u ./...</code> or <code>go get -u=patch ./...</code> (from module root directory) — 更新所有直接和非直接以来到最新版本</li><li><code>go build ./...</code> or <code>go test ./...</code> (from module root directory) — 编译或测试模块中所有package</li><li><code>go mod tidy</code> — 移除不再需要的依赖，并且添加需要的依赖</li><li><code>replace</code> directive or <code>gohack</code> — 使用replace 指令</li><li><code>go mod vendor</code> — 可选的创造 <code>vendor</code> 目录</li></ul><h2 id="New-Concept"><a href="#New-Concept" class="headerlink" title="New Concept"></a>New Concept</h2><p>本小结提供了一些 <code>High-Level</code>的概念介绍。如果想要了解更多的细节，可以看这个40分钟的 <a href="https://www.youtube.com/watch?v=F8nrpe0XWRg&amp;list=PLq2Nv-Sh8EbbIjQgDzapOFeVfv5bGOoPE&amp;index=3&amp;t=0s" target="_blank" rel="external nofollow noopener noreferrer">Russ Cox 介绍 go module背后的设计哲学</a> 视频，也可以看官方的 <a href="https://go.googlesource.com/proposal/+/master/design/24301-versioned-go.md" target="_blank" rel="external nofollow noopener noreferrer">Proposal</a>，或者是早期更详细的 <a href="https://research.swtch.com/vgo" target="_blank" rel="external nofollow noopener noreferrer">vgo博客系列</a> 。</p><h3 id="Modules-定义"><a href="#Modules-定义" class="headerlink" title="Modules 定义"></a>Modules 定义</h3><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><h3 id="Version-Selection"><a href="#Version-Selection" class="headerlink" title="Version Selection"></a>Version Selection</h3><h3 id="Semantic-Import-Versioning"><a href="#Semantic-Import-Versioning" class="headerlink" title="Semantic Import Versioning"></a>Semantic Import Versioning</h3><h2 id="How-to-Use-Modules"><a href="#How-to-Use-Modules" class="headerlink" title="How to Use Modules"></a>How to Use Modules</h2><h2 id="包管理命令"><a href="#包管理命令" class="headerlink" title="包管理命令"></a>包管理命令</h2><h3 id="升级依赖项"><a href="#升级依赖项" class="headerlink" title="升级依赖项"></a>升级依赖项</h3><p>首先我们需要查看以下我们使用到的依赖列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ go list -m all                                                                           ─╯</span><br><span class="line">backend</span><br><span class="line">github.com/davecgh/go-spew v1.1.1</span><br><span class="line">github.com/gin-contrib/sse v0.1.0</span><br><span class="line">github.com/gin-gonic/gin v1.6.3</span><br><span class="line">github.com/go-playground/assert/v2 v2.0.1</span><br><span class="line">github.com/go-playground/locales v0.13.0</span><br><span class="line">github.com/go-playground/universal-translator v0.17.0</span><br><span class="line">github.com/go-playground/validator/v10 v10.2.0</span><br><span class="line">github.com/golang/protobuf v1.3.3</span><br><span class="line">github.com/google/gofuzz v1.0.0</span><br><span class="line">github.com/json-iterator/go v1.1.9</span><br><span class="line">github.com/leodido/go-urn v1.2.0</span><br><span class="line">github.com/mattn/go-isatty v0.0.12</span><br><span class="line">github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421</span><br><span class="line">github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742</span><br><span class="line">github.com/pmezard/go-difflib v1.0.0</span><br><span class="line">github.com/stretchr/objx v0.1.0</span><br><span class="line">github.com/stretchr/testify v1.4.0</span><br><span class="line">github.com/ugorji/go v1.1.7</span><br><span class="line">github.com/ugorji/go/codec v1.1.7</span><br><span class="line">golang.org/x/sys v0.0.0-20200116001909-b77594299b42</span><br><span class="line">golang.org/x/text v0.3.2</span><br><span class="line">golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e</span><br><span class="line">gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405</span><br><span class="line">gopkg.in/yaml.v2 v2.2.8</span><br></pre></td></tr></table></figure><p>因为这里使用的是最新的版本，无法升级，所以这里给出一个回退的例子。将 GIN 框架的版本回退到上个版本。这里需要使用一个命令查看依赖的版本历史。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go list -m -versions github.com/gin-gonic/gin</span><br><span class="line"><span class="comment"># 将会列出 Gin 版本历史</span></span><br><span class="line">github.com/gin-gonic/gin v1.1.1 v1.1.2 v1.1.3 v1.1.4 v1.3.0 v1.4.0 v1.5.0 v1.6.0 v1.6.1 v1.6.2 v1.6.3</span><br></pre></td></tr></table></figure><p>将版本更新到上个版本，这里只是个演示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/gin-gonic/gin@v1.4.0 <span class="comment"># 只需要在依赖后面加上 @version 就可以了</span></span><br><span class="line">go get github.com/gin-gonic/gin@v1.4.0                                                   ─╯</span><br><span class="line">go: downloading github.com/gin-gonic/gin v1.4.0</span><br><span class="line">go: downloading github.com/json-iterator/go v1.1.9</span><br><span class="line">go: downloading gopkg.in/go-playground/validator.v8 v8.18.2</span><br><span class="line">$ go list -m all</span><br><span class="line"><span class="comment"># 看到了版本变化</span></span><br><span class="line">github.com/gin-gonic/gin v1.4.0</span><br></pre></td></tr></table></figure><p>或者可以使用 <code>go mod</code> 来进行版本的切换，这样就需要两个步骤了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod edit -require=<span class="string">"github.com/gin-gonic/gin@v1.4.0"</span> <span class="comment"># 修改 go.mod 文件</span></span><br><span class="line">$ go mod tidy <span class="comment"># 下载更新依赖</span></span><br></pre></td></tr></table></figure><p><code>go mod tidy</code> 会自动清理掉不需要的依赖项，同时可以将依赖项更新到当前版本。</p><p>使用起来这是一个很简单过程，只需要几个命令，你便可以知道依赖的版本信息，以及自由选择安装的版本，一切都变得这么简单。</p><h3 id="删除未使用的依赖项"><a href="#删除未使用的依赖项" class="headerlink" title="删除未使用的依赖项"></a>删除未使用的依赖项</h3><p>如果你在项目过程需要移除一些不需要的依赖，可以使用下面的命令来执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br></pre></td></tr></table></figure><h3 id="命令备忘"><a href="#命令备忘" class="headerlink" title="命令备忘"></a>命令备忘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go mod</span><br><span class="line">The commands are:</span><br><span class="line">    download    download modules to <span class="built_in">local</span> cache</span><br><span class="line">    edit        edit go.mod from tools or scripts</span><br><span class="line">    graph       <span class="built_in">print</span> module requirement graph</span><br><span class="line">    init        initialize new module <span class="keyword">in</span> current directory</span><br><span class="line">    tidy        add missing and remove unused modules</span><br><span class="line">    vendor      make vendored copy of dependencies</span><br><span class="line">    verify      verify dependencies have expected content</span><br><span class="line">    why         explain why packages or modules are needed</span><br></pre></td></tr></table></figure><h2 id="包管理命令-1"><a href="#包管理命令-1" class="headerlink" title="包管理命令"></a>包管理命令</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>如果要想先下载依赖，那么可以直接像以前那样 <code>go get</code> 即可，不过 gomod 下可以跟语义化版本号，比如 <code>go get foo@v1.2.3</code>，也可以跟 git 的分支或 tag，比如<code>go get foo@master</code>，当然也可以跟 git 提交哈希，比如 <code>go get foo@e3702bed2</code>。需要特别注意的是，gomod 除了遵循语义化版本原则外，还遵循最小版本选择原则，也就是说如果当前版本是 v1.1.0，只会下载不超过这个最大版本号。如果使用 <code>go get foo@master</code>，下次在下载只会和第一次的一样，无论 master 分支是否更新了代码，如下所示，使用包含当前最新提交哈希的虚拟版本号替代直接的 <code>master</code> 版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go get golang.org/x/crypto/sha3@master</span><br><span class="line">go: finding golang.org/x/crypto/sha3 latest</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com/adesight/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果下载所有依赖可以使用 <code>go mod download</code> 命令。</p><h3 id="升级依赖"><a href="#升级依赖" class="headerlink" title="升级依赖"></a>升级依赖</h3><p>查看所有以升级依赖版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go list -u -m all</span><br><span class="line">go: finding golang.org/x/sys latest</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">github.com/adesight/<span class="built_in">test</span></span><br><span class="line">golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a [v0.0.0-20190316082340-a2f829d7f35f]</span><br><span class="line">golang.org/x/text v0.3.0</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.99.99</span><br></pre></td></tr></table></figure><p>升级次级或补丁版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u rsc.io&#x2F;quote</span><br></pre></td></tr></table></figure><p>仅升级补丁版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u&#x3D;patch rscio&#x2F;quote</span><br></pre></td></tr></table></figure><p>升降级版本号，可以使用比较运算符控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get foo@&#39;&lt;v1.6.2&#39;</span><br></pre></td></tr></table></figure><h3 id="移除依赖"><a href="#移除依赖" class="headerlink" title="移除依赖"></a>移除依赖</h3><p>当前代码中不需要了某些包，删除相关代码片段后并没有在 <code>go.mod</code> 文件中自动移出。</p><p>运行下面命令可以移出所有代码中不需要的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>如果仅仅修改 <code>go.mod</code> 配置文件的内容，那么可以运行 <code>go mod edit --droprequire=path</code>，比如要移出 <code>golang.org/x/crypto</code> 包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit --droprequire&#x3D;golang.org&#x2F;x&#x2F;crypto</span><br></pre></td></tr></table></figure><h3 id="查看依赖包"><a href="#查看依赖包" class="headerlink" title="查看依赖包"></a>查看依赖包</h3><p>可以直接查看 <code>go.mod</code> 文件，或者使用命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ go list -m all</span><br><span class="line">github.com&#x2F;adesight&#x2F;test</span><br><span class="line">golang.org&#x2F;x&#x2F;crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">golang.org&#x2F;x&#x2F;sys v0.0.0-20190215142949-d0b11bdaac8a</span><br><span class="line">golang.org&#x2F;x&#x2F;text v0.3.0</span><br><span class="line">rsc.io&#x2F;quote v1.5.2</span><br><span class="line">rsc.io&#x2F;sampler v1.99.99</span><br><span class="line">$ go list -m -json all # json 格式输出</span><br><span class="line">&#123;</span><br><span class="line">        &quot;Path&quot;: &quot;golang.org&#x2F;x&#x2F;text&quot;,</span><br><span class="line">        &quot;Version&quot;: &quot;v0.3.0&quot;,</span><br><span class="line">        &quot;Time&quot;: &quot;2017-12-14T13:08:43Z&quot;,</span><br><span class="line">        &quot;Indirect&quot;: true,</span><br><span class="line">        &quot;Dir&quot;: &quot;&#x2F;Users&#x2F;lishude&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;golang.org&#x2F;x&#x2F;text@v0.3.0&quot;,</span><br><span class="line">        &quot;GoMod&quot;: &quot;&#x2F;Users&#x2F;lishude&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;cache&#x2F;download&#x2F;golang.org&#x2F;x&#x2F;text&#x2F;@v&#x2F;v0.3.0.mod&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        &quot;Path&quot;: &quot;rsc.io&#x2F;quote&quot;,</span><br><span class="line">        &quot;Version&quot;: &quot;v1.5.2&quot;,</span><br><span class="line">        &quot;Time&quot;: &quot;2018-02-14T15:44:20Z&quot;,</span><br><span class="line">        &quot;Dir&quot;: &quot;&#x2F;Users&#x2F;lishude&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;rsc.io&#x2F;quote@v1.5.2&quot;,</span><br><span class="line">        &quot;GoMod&quot;: &quot;&#x2F;Users&#x2F;lishude&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;cache&#x2F;download&#x2F;rsc.io&#x2F;quote&#x2F;@v&#x2F;v1.5.2.mod&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块配置文本格式化"><a href="#模块配置文本格式化" class="headerlink" title="模块配置文本格式化"></a>模块配置文本格式化</h3><p>由于可手动修改 go.mod 文件，所以可能此文件并没有被格式化，使用下面命令进行文本格式化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure><h3 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h3><p>发布包新版本和其它包管理工具基本一致，可以直接打标签，不过打标签之前需要在 go.mod 中写入相应的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go mod edit --module&#x3D;github.com&#x2F;islishude&#x2F;gomodtest&#x2F;v2</span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com&#x2F;islishude&#x2F;gomodtest&#x2F;v2</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">golang.org&#x2F;x&#x2F;crypto v0.0.0-20190313024323-a1f597ede03a &#x2F;&#x2F; indirect</span><br><span class="line">rsc.io&#x2F;quote v1.5.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>官方推荐将上述过程在一个新分支来避免混淆，那么类如上述例子可以创建一个 v2 分支，但这个不是强制要求的。</p><p>还有一种方式发布新版本，那就是在主线版本种加入 v2 文件夹，相应的也需要内置 go.mod 这个文件。</p><p>比如上述我们引入的 <a href="https://link.zhihu.com/?target=http%3A//rsc.io/quote" rel="external nofollow noopener noreferrer" target="_blank">http://rsc.io/quote</a> 包，其中 v3 版本是用内置文件夹，而 v2 使用的是 tag。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── buggy</span><br><span class="line">│   └── buggy_test.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── quote.go</span><br><span class="line">├── quote_test.go</span><br><span class="line">└── v3</span><br><span class="line">    ├── go.mod</span><br><span class="line">    ├── go.sum</span><br><span class="line">    └── quote.go</span><br><span class="line">$ git tag -a</span><br><span class="line">bad</span><br><span class="line">v1.0.0</span><br><span class="line">v1.1.0</span><br><span class="line">v1.2.0</span><br><span class="line">v1.2.1</span><br><span class="line">v1.3.0</span><br><span class="line">v1.4.0</span><br><span class="line">v1.5.0</span><br><span class="line">v1.5.1</span><br><span class="line">v1.5.2</span><br><span class="line">v1.5.3-pre1</span><br><span class="line">v2.0.0</span><br><span class="line">v2.0.1</span><br><span class="line">v3.0.0</span><br><span class="line">v3.1.0</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>根据上面的说明，想必你会看到一个问题，当我们升级主版本号的时候，要更改 module 名称，也就是上面所说的加上版本号，这就存在一个问题，如果我们要更新到主版本号的依赖就没有这么简单了，因为升级的依赖包路径都需要修改，<strong>这个在其它语言包管理以及 Go 第三方包管理工具都不存在的一点</strong>。</p><p>如下所示，升级 <code>rsc.io/quote</code> 到 v3 版本。注意一点，作为例子这里包作者对函数也加上了版本，其实大部分人是不会加的。这个模式叫做 <code>semantic import versioning</code>，也是备受争议，大多数人认为这个没有特别大的作用，而维护者则认为这是为了 Go 下一个十年的必要条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&quot;rsc.io&#x2F;quote&#x2F;v3&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(quote.HelloV3())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于内部开发我觉得还挺好，让大家都了解，不要随意加入破坏性更新。</p><p>不过由于这个不讨喜功能，不同版本可以存在同一个包了。补充一句，对于 v0 和 v1 版本并不需要加入到 import path 内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">q1 &quot;rsc.io&#x2F;quote&quot;</span><br><span class="line">&quot;rsc.io&#x2F;quote&#x2F;v3&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(quote.HelloV3())</span><br><span class="line">fmt.Println(q1.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从老项目迁移"><a href="#从老项目迁移" class="headerlink" title="从老项目迁移"></a>从老项目迁移</h3><p>从很多第三方的包管理工具迁移到 gomod 特别简单，直接运行 <code>go mod init</code> 即可。</p><p>如果没有使用任何第三方包管理工具，除了运行 <code>go mod init</code> 初始化以外，还要使用 <code>go get ./...</code> 下载安装所有依赖包，并更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</p><p>默认情况下，<code>go get</code> 命令使用 <code>@latest</code> 版本控制符对所有依赖进行下载，如果想要更改某一个包的版本，可以使用 <code>go mod edit --require</code> 命令，比如要更新 <code>rsc.io/quote</code> 到 v3.1.0 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit --require&#x3D;rsc.io&#x2F;quote@v3.1.0</span><br></pre></td></tr></table></figure><h3 id="GOSUMDB"><a href="#GOSUMDB" class="headerlink" title="GOSUMDB"></a>GOSUMDB</h3><p>它的值是一个 Go checksum database，用于使 Go 在拉取模块版本时(无论是从源站拉取还是通过 Go module proxy 拉取)保证拉取到的模块版本数据未经篡改，也可以是“off”即禁止 Go 在后续操作中校验模块版本</p><ul><li>格式 1：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt;</code>。</li><li>格式 2：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt; &lt;SUMDB_URL&gt;</code>。</li><li>拥有默认值：<code>sum.golang.org</code> (之所以没有按照上面的格式是因为 Go 对默认值做了特殊处理)。</li><li>可被 Go module proxy 代理 (详见：Proxying a Checksum Database)。</li><li><code>sum.golang.org</code> 在中国无法访问，故而更加建议将 GOPROXY 设置为 <code>goproxy.cn</code>，因为 <code>goproxy.cn</code> 支持代理 <code>sum.golang.org</code>。</li></ul><h3 id="Go-Checksum-Database"><a href="#Go-Checksum-Database" class="headerlink" title="Go Checksum Database"></a>Go Checksum Database</h3><p>Go checksum database 主要用于保护 Go 不会从任何源头拉到被篡改过的非法 Go 模块版本，其作用（左）和工作机制（右）如下图：</p><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76259e2243468?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>如果有兴趣的小伙伴可以看看 <a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#proxying-a-checksum-database" target="_blank" rel="external nofollow noopener noreferrer">Proposal: Secure the Public Go Module Ecosystem</a>，有详细介绍其算法机制，如果想简单一点，查看 <code>go help module-auth</code> 也是一个不错的选择。</p><h3 id="GONOPROXY-GONOSUMDB-GOPRIVATE"><a href="#GONOPROXY-GONOSUMDB-GOPRIVATE" class="headerlink" title="GONOPROXY/GONOSUMDB/GOPRIVATE"></a>GONOPROXY/GONOSUMDB/GOPRIVATE</h3><p>这三个环境变量都是用在当前项目依赖了私有模块，也就是依赖了由 GOPROXY 指定的 Go module proxy 或由 GOSUMDB 指定 Go checksum database 无法访问到的模块时的场景</p><ul><li>它们三个的值都是一个以英文逗号 “,” 分割的模块路径前缀，匹配规则同 path.Match。</li><li>其中 GOPRIVATE 较为特殊，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是只是用 GOPRIVATE。</li></ul><p>在使用上来讲，比如 <code>GOPRIVATE=*.corp.example.com</code> 表示所有模块路径以 <code>corp.example.com</code> 的下一级域名 (如 <code>team1.corp.example.com</code>) 为前缀的模块版本都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 <code>corp.example.com</code> 本身。</p><h3 id="Global-Caching"><a href="#Global-Caching" class="headerlink" title="Global Caching"></a>Global Caching</h3><p>这个主要是针对 Go modules 的全局缓存数据说明，如下：</p><ul><li>同一个模块版本的数据只缓存一份，所有其他模块共享使用。</li><li>目前所有模块版本数据均缓存在 <code>$GOPATH/pkg/mod</code>和 <code>$GOPATH/pkg/sum</code> 下，未来或将移至 <code>$GOCACHE/mod</code>和<code>$GOCACHE/sum</code> 下( 可能会在当 <code>$GOPATH</code> 被淘汰后)。</li><li>可以使用 <code>go clean -modcache</code> 清理所有已缓存的模块版本数据。</li></ul><p>另外在 Go1.11 之后 GOCACHE 已经不允许设置为 off 了，我想着这也是为了模块数据缓存移动位置做准备，因此大家应该尽快做好适配。</p><h2 id="快速迁移项目至-Go-Modules"><a href="#快速迁移项目至-Go-Modules" class="headerlink" title="快速迁移项目至 Go Modules"></a>快速迁移项目至 Go Modules</h2><ul><li>第一步: 升级到 Go 1.13。</li><li>第二步: 让 GOPATH 从你的脑海中完全消失，早一步踏入未来。<ul><li>修改 GOBIN 路径（可选）：<code>go env -w GOBIN=$HOME/bin</code>。</li><li>打开 Go modules：<code>go env -w GO111MODULE=on</code>。</li><li>设置 GOPROXY：<code>go env -w GOPROXY=https://goproxy.cn,direct</code> # 在中国是必须的，因为它的默认值被墙了。</li></ul></li><li>第三步(可选): 按照你喜欢的目录结构重新组织你的所有项目。</li><li>第四步: 在你项目的根目录下执行 <code>go mod init &lt;OPTIONAL_MODULE_PATH&gt;</code> 以生成 go.mod 文件。</li><li>第五步: 想办法说服你身边所有的人都去走一下前四步。</li></ul><h2 id="迁移后-go-get-行为的改变"><a href="#迁移后-go-get-行为的改变" class="headerlink" title="迁移后 go get 行为的改变"></a>迁移后 go get 行为的改变</h2><ul><li><p>用 <code>go help module-get</code> 和 <code>go help gopath-get</code>分别去了解 Go modules 启用和未启用两种状态下的 go get 的行为</p></li><li><p>用 </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span></span><br></pre></td></tr></table></figure><p> 拉取新的依赖</p><ul><li>拉取最新的版本(优先择取 tag)：<code>go get golang.org/x/text@latest</code></li><li>拉取 <code>master</code> 分支的最新 commit：<code>go get golang.org/x/text@master</code></li><li>拉取 tag 为 v0.3.2 的 commit：<code>go get golang.org/x/text@v0.3.2</code></li><li>拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：<code>go get golang.org/x/text@342b2e</code></li><li>用 <code>go get -u</code> 更新现有的依赖</li><li>用 <code>go mod download</code> 下载 go.mod 文件中指明的所有依赖</li><li>用 <code>go mod tidy</code> 整理现有的依赖</li><li>用 <code>go mod graph</code> 查看现有的依赖结构</li><li>用 <code>go mod init</code> 生成 go.mod 文件 (Go 1.13 中唯一一个可以生成 go.mod 文件的子命令)</li></ul></li><li><p>用 <code>go mod edit</code> 编辑 go.mod 文件</p></li><li><p>用 <code>go mod vendor</code> 导出现有的所有依赖 (事实上 Go modules 正在淡化 Vendor 的概念)</p></li><li><p>用 <code>go mod verify</code> 校验一个模块是否被篡改过</p></li></ul><p>这里我们注意到有两点比较特别，分别是：</p><ul><li>第一点：为什么 “拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2” 呢。这是因为虽然我们设置了拉取 @342b2e commit，但是因为 Go modules 会与 tag 进行对比，若发现对应的 commit 与 tag 有关联，则进行转换。</li><li>第二点：为什么不建议使用 <code>go mod vendor</code>，因为 Go modules 正在淡化 Vendor 的概念，很有可能 Go2 就去掉了。</li></ul><h2 id="使用-Go-Modules-时常遇见的坑"><a href="#使用-Go-Modules-时常遇见的坑" class="headerlink" title="使用 Go Modules 时常遇见的坑"></a>使用 Go Modules 时常遇见的坑</h2><h3 id="坑-1-判断项目是否启用了-Go-Modules"><a href="#坑-1-判断项目是否启用了-Go-Modules" class="headerlink" title="坑 1: 判断项目是否启用了 Go Modules"></a>坑 1: 判断项目是否启用了 Go Modules</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76259e244d232?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="坑-2-管理-Go-的环境变量"><a href="#坑-2-管理-Go-的环境变量" class="headerlink" title="坑 2: 管理 Go 的环境变量"></a>坑 2: 管理 Go 的环境变量</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76260c9b62f20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这里主要是提到 Go1.13 新增了 <code>go env -w</code> 用于写入环境变量，而写入的地方是 <code>os.UserConfigDir</code> 所返回的路径，需要注意的是 <code>go env -w</code> 不会覆写。</p><h3 id="坑-3-从-dep、glide-等迁移至-Go-Modules"><a href="#坑-3-从-dep、glide-等迁移至-Go-Modules" class="headerlink" title="坑 3: 从 dep、glide 等迁移至 Go Modules"></a>坑 3: 从 dep、glide 等迁移至 Go Modules</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7626035b57218?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这里主要是指从旧有的依赖包管理工具（dep/glide 等）进行迁移时，因为 BUG 的原因会导致不经过 GOPROXY 的代理，解决方法有如下两个：</p><ul><li>手动创建一个 go.mod 文件，再执行 go mod tidy 进行补充。</li><li>上代理，相当于不使用 GOPROXY 了。</li></ul><h3 id="坑-4-拉取私有模块"><a href="#坑-4-拉取私有模块" class="headerlink" title="坑 4:拉取私有模块"></a>坑 4:拉取私有模块</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625ca879e03a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这里主要想涉及两块知识点，如下：</p><ul><li>GOPROXY 是无权访问到任何人的私有模块的，所以你放心，安全性没问题。</li><li>GOPROXY 除了设置模块代理的地址以外，还需要增加 “direct” 特殊标识才可以成功拉取私有库。</li></ul><h3 id="坑-5-更新现有的模块"><a href="#坑-5-更新现有的模块" class="headerlink" title="坑 5:更新现有的模块"></a>坑 5:更新现有的模块</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76270adc1426d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="坑-6-主版本号"><a href="#坑-6-主版本号" class="headerlink" title="坑 6:主版本号"></a>坑 6:主版本号</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625ce242f466?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="Go-Module-Proxy-简介"><a href="#Go-Module-Proxy-简介" class="headerlink" title="Go Module Proxy 简介"></a>Go Module Proxy 简介</h2><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625db94698c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在这里再次强调了 Go Module Proxy 的作用（图左），以及其对应的协议交互流程（图右），有兴趣的小伙伴可以认真看一下。</p><h2 id="Goproxy-中国-goproxy-cn"><a href="#Goproxy-中国-goproxy-cn" class="headerlink" title="Goproxy 中国(goproxy.cn)"></a>Goproxy 中国(goproxy.cn)</h2><p>在这块主要介绍了  Goproxy 的实践操作以及 goproxy.cn 的一些 Q&amp;A 和 近况，如下：</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q：如果中国 Go 语言社区没有咱们自己家的 Go Module Proxy 会怎么样？</strong></p><p><strong>A：</strong>在 Go 1.13 中 GOPROXY 和 GOSUMDB 这两个环境变量都有了在中国无法 访问的默认值，尽管我在 golang.org/issue/31755 里努力尝 试过，但最终仍然无法为咱们中国的 Go 语言开发者谋得一个完美的解决方案。所以从今以后咱 们中国的所有 Go 语言开发者，只要是 使用了 Go modules 的，那么都必须先修改 GOPROXY 和 GOSUMDB 才能正常使用 Go 做开发，否则可能连一个最简单的程序都跑不起 来(只要它有依 赖第三方模 块)。</p><p><strong>Q： 我创建 Goproxy 中国(goproxy.cn)的主要原因？</strong></p><p><strong>A：</strong>其实更早的时候，也就是今年年初我也曾 试图在 golang.org/issue/31020 中请求 Go team 能想办法避免那时的 GOPROXY 即将拥有的默认值可以在中国正常访问，但 Go team 似乎也无能为力，为此我才坚定了创建 goproxy.cn 的信念。既然别人没法儿帮忙，那咱们就 得自己动手，不为别的，就为了让大家以后能够更愉快地使用 Go 语言配合 Go modules 做开发。</p><p>最初我先是和七牛云的 许叔(七牛云的 创始人兼 CEO 许式伟)提出了我打算 创建 goproxy.cn 的想法，本是抱着 试试看的目的，但没想 到 许叔几乎是没有超过一分钟的考虑便认可了我的想法并表示愿意一起推 动。那一阵子刚好赶上我在写毕业论文，所以项目开发完后就 一直没和七牛云做交接，一直跑在我的个人服 务器上。直到有一次 goproxy.cn 被攻击了，一下午的功夫 烧了我一百多美元，然后我才 意识到这种项目真不能个人来做。个人来做不靠 谱，万一依赖这个项目的人多了，项目再出什么事儿，那就会给大家􏰁成不必要的损 失。所以我赶紧和七牛云做了交接，把 goproxy.cn 完全交给了七牛云，甚至连域名都过户了去。</p><h3 id="近况"><a href="#近况" class="headerlink" title="近况"></a>近况</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625e53fc7ff9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><ul><li>Goproxy 中国 (goproxy.cn) 是目前中国最可靠的 Go module proxy (真不是在自卖自夸)。</li><li>为中国 Go 语言开发者量身打􏰁，支持代理 GOSUMDB 的默认值，经过全球 CDN 加速，高可用，可 应用进公司复杂的开发环境中，亦可用作上游代理。</li><li>由中国倍受信赖的云服务提供商七牛云无偿提供基础设施支持的开源的非营利性项目。</li><li>目标是为中国乃至全世界的 Go 语言开发者提供一个免 费的、可靠的、持 续在线的且经过 CDN 加􏰀的 Go module proxy。</li><li>域名已由七牛云进行了备案 (沪ICP备11037377号-56)。</li></ul><h3 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625dbdfb4f03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>此处呈现的是存储大小，主要是针对模块包代码，而一般来讲代码并不会有多大，0-10MB，10-50MB 占最大头，也是能够理解，但是大于 100MB 的模块包代码就比较夸张了。</p><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625f82db3eba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>此时主要是展示了一下近期 goproxy.cn 的网络数据情况，我相信未来是会越来越高的，值得期待。</p><h2 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>Q：如何解决 Go 1.13 在从 GitLab 拉取模块版本时遇到的，Go 错误地按照非期望值的路径寻找目标模块版本结果致使最终目标模块拉取失败的问题？</strong></p><p><strong>A：</strong>GitLab 中配合 goget 而设置的 <code>&lt;meta&gt;</code> 存在些许问题，导致 Go 1.13 错误地识别了模块的具体路径，这是个 Bug，据说在 GitLab 的新版本中已经被修复了，详细内容可以看 <a href="https://github.com/golang/go/issues/34094" target="_blank" rel="external nofollow noopener noreferrer">github.com/golang/go/i…</a> 这个 Issue。然后目前的解决办法的话除了升级 GitLab 的版本外，还可以参考 <a href="https://github.com/developer-learning/night-reading-go/issues/468#issuecomment-535850154" target="_blank" rel="external nofollow noopener noreferrer">github.com/developer-l…</a> 这条回复。</p><p><strong>Q：使用 Go modules 时可以同时依赖同一个模块的不同的两个或者多个小版本（修订版本号不同）吗？</strong></p><p><strong>A：</strong>不可以的，Go modules 只可以同时依赖一个模块的不同的两个或者多个大版本（主版本号不同）。比如可以同时依赖 <code>example.com/foobar@v1.2.3</code> 和 <code>example.com/foobar/v2@v2.3.4</code>，因为他们的模块路径（module path）不同，Go modules 规定主版本号不是 v0 或者 v1 时，那么主版本号必须显式地出现在模块路径的尾部。但是，同时依赖两个或者多个小版本是不支持的。比如如果模块 A 同时直接依赖了模块 B 和模块 C，且模块 A 直接依赖的是模块 C 的 v1.0.0 版本，然后模块 B 直接依赖的是模块 C 的 v1.0.1 版本，那么最终 Go modules 会为模块 A 选用模块 C 的 v1.0.1 版本而不是模块 A 的 go.mod 文件中指明的 v1.0.0 版本。</p><p>这是因为 Go modules 认为只要主版本号不变，那么剩下的都可以直接升级采用最新的。但是如果采用了最新的结果导致项目 Break 掉了，那么 Go modules 就会 Fallback 到上一个老的版本，比如在前面的例子中就会 Fallback 到 v1.0.0 版本。</p><p><strong>Q：在 go.sum 文件中的一个模块版本的 Hash 校验数据什么情况下会成对出现，什么情况下只会存在一行？</strong></p><p><strong>A：</strong>通常情况下，在 go.sum 文件中的一个模块版本的 Hash 校验数据会有两行，前一行是该模块的 ZIP 文件的 Hash 校验数据，后一行是该模块的 go.mod 文件的 Hash 校验数据。但是也有些情况下只会出现一行该模块的 go.mod 文件的 Hash 校验数据，而不包含该模块的 ZIP 文件本身的 Hash 校验数据，这个情况发生在 Go modules 判定为你当前这个项目完全用不到该模块，根本也不会下载该模块的 ZIP 文件，所以就没必要对其作出 Hash 校验保证，只需要对该模块的 go.mod 文件作出 Hash 校验保证即可，因为 go.mod 文件是用得着的，在深入挖取项目依赖的时候要用。</p><p><strong>Q：能不能更详细地讲解一下 go.mod 文件中的 replace 动词的行为以及用法？</strong></p><p><strong>A：</strong>这个 replace 动词的作用是把一个“模块版本”替换为另外一个“模块版本”，这是“模块版本”和“模块版本（module path）”之间的替换，“=&gt;”标识符前面的内容是待替换的“模块版本”的“模块路径”，后面的内容是要替换的目标“模块版本”的所在地，即路径，这个路径可以是一个本地磁盘的相对路径，也可以是一个本地磁盘的绝对路径，还可以是一个网络路径，但是这个目标路径并不会在今后你的项目代码中作为你“导入路径（import path）”出现，代码里的“导入路径”还是得以你替换成的这个目标“模块版本”的“模块路径”作为前缀。</p><p>另外需要注意，Go modules 是不支持在 “导入路径” 里写相对路径的。举个例子，如果项目 A 依赖了模块 B，比如模块 B 的“模块路径”是 <code>example.com/b</code>，然后它在的磁盘路径是 <code>~/b</code>，在项目 A 里的 go.mod 文件中你有一行 <code>replace example.com/b=&gt;~/b</code>，然后在项目 A 里的代码中的“导入路基”就是 <code>import&quot;example.com/b&quot;</code>，而不是 <code>import&quot;~/b&quot;</code>，剩下的工作是 Go modules 帮你自动完成了的。</p><p>然后就是我在分享中也提到了， exclude 和 replace 这两个动词只作用于当前主模块，也就是当前项目，它所依赖的那些其他模块版本中如果出现了你待替换的那个模块版本的话，Go modules 还是会为你依赖的那个模块版本去拉取你的这个待替换的模块版本。</p><p>举个例子，比如项目 A 直接依赖了模块 B 和模块 C，然后模块 B 也直接依赖了模块 C，那么你在项目 A 中的 go.mod 文件里的 <code>replace c=&gt;~/some/path/c</code> 是只会影响项目 A 里写的代码中，而模块 B 所用到的还是你 replace 之前的那个 c，并不是你替换成的 <code>~/some/path/c</code> 这个。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.youtube.com/watch?v=F8nrpe0XWRg&amp;list=PLq2Nv-Sh8EbbIjQgDzapOFeVfv5bGOoPE&amp;index=3&amp;t=0s" target="_blank" rel="external nofollow noopener noreferrer">Russ Cox 介绍 go module背后的设计哲学</a></li><li><a href="https://go.googlesource.com/proposal/+/master/design/24301-versioned-go.md" target="_blank" rel="external nofollow noopener noreferrer">Go Module Proposal</a></li><li><a href="https://research.swtch.com/vgo" target="_blank" rel="external nofollow noopener noreferrer">vgo博客系列</a> </li><li><a href="https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/" target="_blank" rel="external nofollow noopener noreferrer">https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;/assets/js/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;包管理机制&quot;&gt;&lt;a href=&quot;#包管理机制&quot; class=&quot;headerlink&quot; title=&quot;包管理机制&quot;&gt;&lt;/a&gt;包管理机制&lt;/h2&gt;&lt;p&gt;Go 的包管理方式是逐渐演进的， 最初是 monorepo 模式，所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包，不过这种包管理显然是有问题，由于包依赖可能会引入破坏性更新，生产环境和测试环境会出现运行不一致的问题。&lt;/p&gt;&lt;p&gt;从 v1.5 开始开始引入 vendor 包模式，如果项目目录下有 vendor 目录，那么 go 工具链会优先使用 vendor 内的包进行编译、测试等，这之后第三方的包管理思路都是通过这种方式来实现，比如说由社区维护准官方包管理工具 dep。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="包管理系统" scheme="http://houmin.cc/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】同步原语</title>
    <link href="http://houmin.cc/posts/77ffac6b/"/>
    <id>http://houmin.cc/posts/77ffac6b/</id>
    <published>2020-08-05T04:18:30.000Z</published>
    <updated>2020-08-22T08:35:03.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Go 语言作为一个原生支持用户态进程（Goroutine）的语言，当提到并发编程、多线程编程时，往往都离不开锁这一概念。锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题。</p><p>本节会介绍 Go 语言中常见的同步原语 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 以及扩展原语 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>semaphore.Weighted</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>singleflight.Group</code></a> 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。</p><a id="more"></a><h2 id="基本原语"><a href="#基本原语" class="headerlink" title="基本原语"></a>基本原语</h2><p>Go 语言在 <a href="https://golang.org/pkg/sync/" target="_blank" rel="external nofollow noopener noreferrer"><code>sync</code></a> 包中提供了用于同步的一些基本原语，包括常见的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a>：</p><p><img alt="golang-basic-sync-primitives" data-src="https://img.draveness.me/2020-01-23-15797104327981-golang-basic-sync-primitives.png"></p><p>这些基本原语提高了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级的更高的 Channel 实现同步。</p><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Go 语言的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 由两个字段 <code>state</code> 和 <code>sema</code> 组成。其中 <code>state</code> 表示当前互斥锁的状态，而 <code>sema</code> 是用于控制锁状态的信号量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="keyword">int32</span></span><br><span class="line">sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放：</p><p><img alt="golang-mutex-state" data-src="https://img.draveness.me/2020-01-23-15797104328010-golang-mutex-state.png"></p><p>在默认情况下，互斥锁的所有状态位都是 <code>0</code>，<code>int32</code> 中的不同位分别表示了不同的状态：</p><ul><li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li><li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li><li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li><li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</li></ul><h4 id="正常模式和饥饿模式"><a href="#正常模式和饥饿模式" class="headerlink" title="正常模式和饥饿模式"></a>正常模式和饥饿模式</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么，它们有什么样的关系。</p><p>在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被「饿死」。</p><p><img alt="golang-mutex-mode" data-src="https://img.draveness.me/2020-01-23-15797104328020-golang-mutex-mode.png"></p><p>饥饿模式是在 Go 语言 <a href="https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be" target="_blank" rel="external nofollow noopener noreferrer">1.9</a> 版本引入的优化<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>，引入的目的是保证互斥锁的公平性（Fairness）。</p><p>在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。</p><p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p><h4 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h4><p>我们在这一节中将分别介绍互斥锁的加锁和解锁过程，它们分别使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 方法。</p><p>互斥锁的加锁是靠 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 完成的，最新的 Go 语言源代码中已经将 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 方法进行了简化，方法的主干只保留最常见、简单的情况 — 当锁的状态是 0 时，将 <code>mutexLocked</code> 位置成 1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果互斥锁的状态不是 0 时就会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L84-L171" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.lockSlow</code></a> 尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将该方法分成几个部分介绍获取锁的过程：</p><ol><li>判断当前 Goroutine 能否进入自旋；</li><li>通过自旋等待互斥锁的释放；</li><li>计算互斥锁的最新状态；</li><li>更新互斥锁的状态并获取锁；</li></ol><p>我们先来介绍互斥锁是如何判断当前 Goroutine 能否进入自旋等互斥锁的释放：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">starving := <span class="literal">false</span></span><br><span class="line">awoke := <span class="literal">false</span></span><br><span class="line">iter := <span class="number">0</span></span><br><span class="line">old := m.state</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line"><span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">runtime_doSpin()</span><br><span class="line">iter++</span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p><ol><li><p>互斥锁只有在普通模式才能进入自旋；</p></li><li><p><code>sync.runtime_canSpin</code></p></li></ol><p>   需要返回</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>   ：</p><ol><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ol><p>一旦当前 Goroutine 能够进入自旋就会调用<a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L5356-L5358" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_doSpin</code></a> 和 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L593-L599" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.procyield</code></a> 并执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">MOVLcycles+<span class="number">0</span>(FP), AX</span><br><span class="line">again:</span><br><span class="line">PAUSE</span><br><span class="line">SUBL$<span class="number">1</span>, AX</span><br><span class="line">JNZagain</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line"><span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算了新的互斥锁状态之后，就会使用 CAS 函数 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L75" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.CompareAndSwapInt32</code></a> 更新该状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// 通过 CAS 函数获取了锁</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们没有通过 CAS 获得锁，会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 使用信号量保证资源不会被两个 Goroutine 获取。<a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 会在方法中不断调用尝试获取锁并休眠当前 Goroutine 等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 方法的剩余代码也会继续执行。</p><ul><li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li></ul><p>互斥锁的解锁过程 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 与加锁过程相比就很简单，该过程会先使用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>AddInt32</code></a> 函数快速解锁，这时会发生下面的两种情况：</p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，这段代码会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L194-L226" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.unlockSlow</code></a> 方法开始慢速解锁：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L194-L226" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.unlockSlow</code></a> 方法首先会校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了就会直接抛出异常 <code>sync: unlock of unlocked mutex</code> 中止当前程序。</p><p>在正常情况下会根据当前互斥锁的状态，分别处理正常模式和饥饿模式下的互斥锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 正常模式</span></span><br><span class="line">old := <span class="built_in">new</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 饥饿模式</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在正常模式下，这段代码会分别处理以下两种情况处理；<ul><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法就可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒等待者并移交锁的所有权；</li></ul></li><li>在饥饿模式下，上述代码会直接调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 方法将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们已经从多个方面分析了互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 的实现原理，在这里我们从加锁和解锁两个方面总结一下结论和注意事项。</p><p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，就会直接通过置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 并且在普通模式下工作，就会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 函数将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒当前 Goroutine；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，当前 Goroutine 会将互斥锁切换回正常模式；</li></ul><p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p><ul><li>当互斥锁已经被解锁时，那么调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，会直接将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，就会直接返回；在其他情况下会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li></ul><h3 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h3><p>读写互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行。</p><div class="table-container"><table><thead><tr><th></th><th>读</th><th>写</th></tr></thead><tbody><tr><td>读</td><td>Y</td><td>N</td></tr><tr><td>写</td><td>N</td><td>N</td></tr></tbody></table></div><p>一个常见的服务对资源的读写比例会非常高，因为大多数的读请求之间不会相互影响，所以我们可以读写资源操作的分离，在类似场景下提高服务的性能。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 中总共包含以下 5 个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">w           Mutex</span><br><span class="line">writerSem   <span class="keyword">uint32</span></span><br><span class="line">readerSem   <span class="keyword">uint32</span></span><br><span class="line">readerCount <span class="keyword">int32</span></span><br><span class="line">readerWait  <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>w</code> — 复用互斥锁提供的能力；</li><li><code>writerSem</code> 和 <code>readerSem</code> — 分别用于写等待读和读等待写：</li><li><code>readerCount</code> 存储了当前正在执行的读操作的数量；</li><li><code>readerWait</code> 表示当写操作被阻塞时等待的读操作个数；</li></ul><p>我们会依次分析获取写锁和读锁的实现原理，其中：</p><ul><li>写操作使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L92-L110" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Lock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 方法；</li><li>读操作使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L43-L56" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RLock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 方法；</li></ul><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><p>当资源的使用者想要获取写锁时，需要调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L92-L110" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Lock</code></a> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rw.w.Lock()</span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用结构体持有的</li></ol><p>   <code>sync.Mutex</code></p><p>   的</p><p>   <code>sync.Mutex.Lock</code></p><p>   方法阻塞后续的写操作；</p><ul><li>因为互斥锁已经被获取，其他 Goroutine 在获取写锁时就会进入自旋或者休眠；</li></ul><ol><li><p>调用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 方法阻塞后续的读操作：</p></li><li><p>如果仍然有其他 Goroutine 持有互斥锁的读锁（r != 0），该 Goroutine 会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 进入休眠状态等待所有读锁所有者执行结束后释放 <code>writerSem</code> 信号量将当前协程唤醒。</p></li></ol><p>写锁的释放会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line"><span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与加锁的过程正好相反，写锁的释放分以下几个执行：</p><ol><li>调用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 函数将变回正数，释放读锁；</li><li>通过 for 循环触发所有由于获取读锁而陷入等待的 Goroutine：</li><li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 方法释放写锁；</li></ol><p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作『饿死』。</p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><p>读锁的加锁方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L43-L56" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RLock</code></a> 很简单，该方法会通过 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 将 <code>readerCount</code> 加一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 陷入休眠等待锁的释放；</li><li>如果该方法的结果为非负数 — 没有 Goroutine 获得写锁，当前方法就会成功返回；</li></ol><p>当 Goroutine 想要释放读锁时，会调用如下所示的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">rw.rUnlockSlow(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会先减少正在读资源的 <code>readerCount</code> 整数，根据 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 的返回值不同会分别进行处理：</p><ul><li>如果返回值大于等于零 — 读锁直接解锁成功；</li><li>如果返回值小于零 — 有一个正在执行的写操作，在这时会调用<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L77-L87" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.rUnlockSlow</code></a> 方法；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">throw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L77-L87" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.rUnlockSlow</code></a> 会减少获取锁的写操作等待的读操作数 <code>readerWait</code> 并在所有读操作都被释放之后触发写操作的信号量 <code>writerSem</code>，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>读写互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 虽然提供的功能非常复杂，不过因为它建立在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 上，所以整体的实现上会简单很多。我们总结一下读锁和写锁的关系：</p><ul><li>调用</li></ul><p>  <code>sync.RWMutex.Lock</code></p><p>  尝试获取写锁时；</p><ul><li>每次 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 都会将 <code>readerWait</code> 其减一，当它归零时该 Goroutine 就会获得写锁；<ul><li>将 <code>readerCount</code> 减少 <code>rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li></ul></li></ul><ul><li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li></ul><p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">    &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>我们可以通过 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 将原本顺序执行的代码在多个 Goroutine 中并发执行，加快程序处理的速度。</p><p><img alt="golang-syncgroup" data-src="https://img.draveness.me/2020-01-23-15797104328028-golang-syncgroup.png"></p><h4 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 结构体中的成员变量非常简单，其中只包含两个成员变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line">state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>noCopy</code> — 保证 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 不会被开发者通过再赋值的方式拷贝；</li><li><code>state1</code> — 存储着状态和信号量；</li></ul><p><a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 是一个特殊的私有结构体，<a href="http://golang.so/pkg/cmd/vendor/golang.org/x/tools/go/analysis/passes/copylock/" target="_blank" rel="external nofollow noopener noreferrer"><code>tools/go/analysis/passes/copylock</code></a> 包中的分析器会在编译期间检查被拷贝的变量中是否包含 <a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 结构体，如果包含该结构体就会在运行时报出以下错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">yawg := wg</span><br><span class="line">fmt.Println(wg, yawg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> vet proc.<span class="keyword">go</span></span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">10</span>: assignment copies lock value to yawg: sync.WaitGroup</span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">14</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">18</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br></pre></td></tr></table></figure><p>这段代码会因为变量赋值或者调用函数时发生值拷贝导致分析器报错。</p><p>除了 <a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 字段之外，<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>` 结构体中还包含一个总共占用 12 字节的数组，这个数组会存储当前结构体的状态，在 64 位与 32 位的机器上表现也非常不同。</p><p><img alt="golang-waitgroup-state" data-src="https://img.draveness.me/2020-01-23-15797104328035-golang-waitgroup-state.png"></p><p><strong>图 6-9 WaitGroup 在 64 位和 32 位机器的不同状态</strong></p><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 提供的私有方法 <a href="https://github.com/golang/go/blob/4c3f26076b6a9853bcc3c7d7e43726c044ac028a/src/sync/waitgroup.go#L32-L38" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.state</code></a> 能够帮我们从 <code>state1</code> 字段中取出它的状态和信号量。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 对外暴露了三个方法 — <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a>。</p><p>因为其中的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 只是向 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入了 -1，所以我们重点分析另外两个方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">statep, semap := wg.state()</span><br><span class="line">state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">w := <span class="keyword">uint32</span>(state)</span><br><span class="line"><span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync: negative WaitGroup counter"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">*statep = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法可以更新 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 中的计数器 <code>counter</code>。虽然 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入的参数可以为负数，但是计数器只能是非负数，一旦出现负数就会发生程序崩溃。当调用计数器归零，也就是所有任务都执行完成时，就会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒处于等待状态的所有 Goroutine。</p><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的另一个方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L55-L57" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semacquire</code></a> 陷入睡眠状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">statep, semap := wg.state()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">state := atomic.LoadUint64(statep)</span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">runtime_Semacquire(semap)</span><br><span class="line"><span class="keyword">if</span> +statep != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync: WaitGroup is reused before previous Wait has returned"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的计数器归零时，当陷入睡眠状态的 Goroutine 就被唤醒，上述方法会立刻返回。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>通过对 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的分析和研究，我们能够得出以下结论：</p><ul><li><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 必须在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li><li><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 只是对 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；</li><li>可以同时有多个 Goroutine 等待当前 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li></ul><h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>Go 语言标准库中 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 可以保证在 Go 程序运行期间的某段代码只会执行一次。在运行如下所示的代码时，我们会看到如下所示的运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"only once"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">only once</span><br></pre></td></tr></table></figure><h4 id="结构体-2"><a href="#结构体-2" class="headerlink" title="结构体"></a>结构体</h4><p>每一个 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体中都只包含一个用于标识代码块是否执行过的 <code>done</code> 以及一个互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">done <span class="keyword">uint32</span></span><br><span class="line">m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 是 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体对外唯一暴露的方法，该方法会接收一个入参为空的函数：</p><ul><li>如果传入的函数已经执行过，就会直接返回；</li><li>如果传入的函数没有执行过，就会调用 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L61-L68" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.doSlow</code></a> 执行传入的函数：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">o.doSlow(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">o.m.Lock()</span><br><span class="line"><span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line"><span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为当前 Goroutine 获取互斥锁；</li><li>执行传入的无入参函数；</li><li>运行延迟函数调用，将成员变量 <code>done</code> 更新成 1；</li></ol><p><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 就会通过成员变量 <code>done</code> 确保函数不会执行第二次。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>作为用于保证函数执行次数的 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体，它使用互斥锁和 <a href="https://github.com/golang/go/tree/master/src/sync/atomic" target="_blank" rel="external nofollow noopener noreferrer"><code>sync/atomic</code></a> 包提供的方法实现了某个函数在程序运行期间只能执行一次的语义。在使用该结构体时，我们也需要注意以下的问题：</p><ul><li><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li><li>两次调用 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 方法传入不同的函数也只会执行第一次调用的函数；</li></ul><h3 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h3><p>Go 语言标准库中的 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 一个条件变量，它可以让一系列的 Goroutine 都在满足特定条件时被唤醒。每一个 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 结构体在初始化时都需要传入一个互斥锁，我们可以通过下面的例子了解它的使用方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> listen(c)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line"><span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(ch, os.Interrupt)</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line">c.Broadcast()</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line">c.Wait()</span><br><span class="line">fmt.Println(<span class="string">"listen"</span>)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">listen</span><br><span class="line">...</span><br><span class="line">listen</span><br></pre></td></tr></table></figure><p>上述代码同时运行了 11 个 Goroutine，这 11 个 Goroutine 分别做了不同事情：</p><ul><li>10 个 Goroutine 通过 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 等待特定条件的满足；</li><li>1 个 Goroutine 会调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法通知所有陷入等待的 Goroutine；</li></ul><p>调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法后，上述代码会打印出 10 次 “listen” 并结束调用。</p><p><img alt="golang-cond-broadcast" data-src="https://img.draveness.me/2020-01-23-15797104328042-golang-cond-broadcast.png"></p><h4 id="结构体-3"><a href="#结构体-3" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 的结构体中包含以下 4 个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy  noCopy</span><br><span class="line">L       Locker</span><br><span class="line">notify  notifyList</span><br><span class="line">checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>noCopy</code> — 用于保证结构体不会在编译期间拷贝；</li><li><code>copyChecker</code> — 用于禁止运行期间发生的拷贝；</li><li><code>L</code> — 用于保护内部的 <code>notify</code> 字段，<code>Locker</code> 接口类型的变量；</li><li><code>notify</code> — 一个 Goroutine 的链表，它是实现同步机制的核心结构；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait <span class="keyword">uint32</span></span><br><span class="line">notify <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">lock mutex</span><br><span class="line">head *sudog</span><br><span class="line">tail *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/golang/go/blob/41cb0aedffdf4c5087de82710c4d016a3634b4ac/src/sync/runtime.go#L33-L39" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.notifyList</code></a> 结构体中，<code>head</code> 和 <code>tail</code> 分别指向的链表的头和尾，<code>wait</code> 和 <code>notify</code> 分别表示当前正在等待的和已经通知到的 Goroutine，我们通过这两个变量就能确认当前待通知和已通知的 Goroutine。</p><h4 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 对外暴露的 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 方法会将当前 Goroutine 陷入休眠状态，它的执行过程分成以下两个步骤：</p><ol><li>调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L479-L483" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListAdd</code></a> 将等待计数器加一并解锁；</li><li>调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L488-L518" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListWait</code></a> 等待其他 Goroutine 的唤醒并加锁：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">t := runtime_notifyListAdd(&amp;c.notify) <span class="comment">// runtime.notifyListAdd 的链接名</span></span><br><span class="line">c.L.Unlock()</span><br><span class="line">runtime_notifyListWait(&amp;c.notify, t) <span class="comment">// runtime.notifyListWait 的链接名</span></span><br><span class="line">c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L488-L518" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListWait</code></a> 函数会获取当前 Goroutine 并将它追加到 Goroutine 通知链表的最末端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">s := acquireSudog()</span><br><span class="line">s.g = getg()</span><br><span class="line">s.ticket = t</span><br><span class="line"><span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">l.head = s</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l.tail.next = s</span><br><span class="line">&#125;</span><br><span class="line">l.tail = s</span><br><span class="line">goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了将当前 Goroutine 追加到链表的末端之外，我们还会调用 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L309-L311" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goparkunlock</code></a> 将当前 Goroutine 陷入休眠状态，该函数也是在 Go 语言切换 Goroutine 时经常会使用的方法，它会直接让出当前处理器的使用权并等待调度器的唤醒。</p><p><img alt="golang-cond-notifylist" data-src="https://img.draveness.me/2020-01-23-15797104328049-golang-cond-notifylist.png"></p><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 和 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法就是用来唤醒调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 陷入休眠的 Goroutine，它们两个的实现有一些细微差别：</p><ul><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 方法会唤醒队列最前面的 Goroutine；</li><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法会唤醒队列中全部的 Goroutine；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L554-L604" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListNotifyOne</code></a> 函数只会从 <a href="https://github.com/golang/go/blob/41cb0aedffdf4c5087de82710c4d016a3634b4ac/src/sync/runtime.go#L33-L39" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.notifyList</code></a> 链表中找到满足 <code>sudog.ticket == l.notify</code> 条件的 Goroutine 并通过 <code>readyWithTime</code> 唤醒：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">t := l.notify</span><br><span class="line">atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line"><span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">n := s.next</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">p.next = n</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l.head = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">l.tail = p</span><br><span class="line">&#125;</span><br><span class="line">s.next = <span class="literal">nil</span></span><br><span class="line">readyWithTime(s, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L522-L550" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListNotifyAll</code></a> 会依次通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L79-L84" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.readyWithTime</code></a> 函数唤醒链表中 Goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">s := l.head</span><br><span class="line">l.head = <span class="literal">nil</span></span><br><span class="line">l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">next := s.next</span><br><span class="line">s.next = <span class="literal">nil</span></span><br><span class="line">readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">s = next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Goroutine 的唤醒顺序也是按照加入队列的先后顺序，先加入的会先被唤醒，而后加入的 Goroutine 需要等待调度器的调度。</p><p>在一般情况下，我们都会先调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 陷入休眠等待满足期望条件，当满足唤醒条件时，就可以选择使用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 或者 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 唤醒一个或者全部的 Goroutine。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 不是一个常用的同步机制，在遇到长时间条件无法满足时，与使用 <code>for {}</code> 进行忙碌等待相比，<a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 能够让出处理器的使用权。在使用的过程中我们需要注意以下问题：</p><ul><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 方法在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 方法唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 会按照一定顺序广播通知等待的全部 Goroutine；</li></ul><h2 id="扩展原语"><a href="#扩展原语" class="headerlink" title="扩展原语"></a>扩展原语</h2><p>除了标准库中提供的同步原语之外，Go 语言还在子仓库 <a href="https://github.com/golang/sync" target="_blank" rel="external nofollow noopener noreferrer">sync</a> 中提供了四种扩展原语，<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/syncmap/go19.go#L17" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/syncmap.Map</code></a>，其中的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/syncmap/go19.go#L17" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/syncmap.Map</code></a> 在 1.9 版本中被移植到了标准库中。</p><p><img alt="golang-extension-sync-primitives" data-src="https://img.draveness.me/2020-01-23-15797104328056-golang-extension-sync-primitives.png"></p><p>本节会介绍 Go 语言在扩展包中提供的三种同步原语，也就是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a>。</p><h3 id="ErrGroup"><a href="#ErrGroup" class="headerlink" title="ErrGroup"></a>ErrGroup</h3><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 就为我们在一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能，我们可以使用如下所示的方式并行获取网页的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"http://www.golang.org/"</span>,</span><br><span class="line">    <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">    <span class="string">"http://www.somestupidname.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    url := urls[i]</span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        resp, err := http.Get(url)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            resp.Body.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Successfully fetched all URLs."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L51-L66" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Go</code></a> 方法能够创建一个 Goroutine 并在其中执行传入的函数，而 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L39-L45" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Wait</code></a> 会等待所有 Goroutine 全部返回，该方法的不同返回结果也有不同的含义：</p><ul><li>如果返回错误 — 这一组 Goroutine 最少返回一个错误；</li><li>如果返回空值 — 所有 Goroutine 都成功执行；</li></ul><h4 id="结构体-4"><a href="#结构体-4" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体同时由三个比较重要的部分组成：</p><ol><li><code>cancel</code> — 创建 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 时返回的取消函数，用于在多个 Goroutine 之间同步取消信号；</li><li><code>wg</code> — 用于等待一组 Goroutine 完成子任务的同步原语；</li><li><code>errOnce</code> — 用于保证只接收一个子任务返回的错误；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">errOnce sync.Once</span><br><span class="line">err     error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些字段共同组成了 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体并为我们提供同步、错误传播以及上下文取消等功能。</p><h4 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h4><p>我们能通过 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L32-L35" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.WithContext</code></a> 构造器创建新的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span> <span class="params">(*Group, context.Context)</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">return</span> &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行新的并行子任务需要使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L51-L66" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Go</code></a> 方法，这个方法的执行过程如下：</p><ol><li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 增加待处理的任务；</li><li>创建一个新的 Goroutine 并在 Goroutine 内部运行子任务；</li><li>返回错误时及时调用 <code>cancel</code> 并对 <code>err</code> 赋值，只有最早返回的错误才会被上游感知到，后续的错误都会被舍弃：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Go</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">g.wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := f(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">g.errOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.err = err</span><br><span class="line"><span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">g.cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Wait</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">g.wg.Wait()</span><br><span class="line"><span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">g.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> g.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个用于等待的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L39-L45" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Wait</code></a> 方法只是调用了 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a>，在子任务全部完成时取消 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 并返回可能出现的错误。</p><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 的实现没有涉及底层和运行时包中的 API，它只是对基本同步语义进行了封装以提供更加复杂的功能。在使用时，我们也需要注意以下的几个问题：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 在出现错误或者等待结束后都会调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 的 <code>cancel</code> 方法同步取消信号；</li><li>只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃；</li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量是在并发编程中常见的一种同步机制，在需要控制访问资源的进程数量时就会用到信号量，它会保证持有的计数器在 0 到初始化的权重之间波动。</p><ul><li>每次获取资源时都会将信号量中的计数器减去对应的数值，在释放时重新加回来；</li><li>当遇到计数器大于信号量大小时就会进入休眠等待其他线程释放信号；</li></ul><p>Go 语言的扩展包中就提供了带权重的信号量 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a>，我们可以按照不同的权重对资源的访问进行管理，这个结构体对外也只暴露了四个方法：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L21-L24" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.NewWeighted</code></a> 用于创建新的信号量；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 阻塞地获取指定权重的资源，如果当前没有空闲资源，就会陷入休眠等待；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 非阻塞地获取指定权重的资源，如果当前没有空闲资源，就会直接返回 <code>false</code>；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 用于释放指定权重的资源；</li></ul><h4 id="结构体-5"><a href="#结构体-5" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L21-L24" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.NewWeighted</code></a> 方法能根据传入的信号量最大权重创建一个 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 结构体指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWeighted</span><span class="params">(n <span class="keyword">int64</span>)</span> *<span class="title">Weighted</span></span> &#123;</span><br><span class="line">w := &amp;Weighted&#123;size: n&#125;</span><br><span class="line"><span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">size    <span class="keyword">int64</span></span><br><span class="line">cur     <span class="keyword">int64</span></span><br><span class="line">mu      sync.Mutex</span><br><span class="line">waiters list.List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 结构体中包含一个 <code>waiters</code> 列表，其中存储着等待获取资源的 Goroutine，除此之外它还包含当前信号量的上限以及一个计数器 <code>cur</code>，这个计数器的范围就是 [0, size]：</p><p><img alt="golang-semaphore" data-src="https://img.draveness.me/2020-01-23-15797104328063-golang-semaphore.png"></p><p><strong>图 6-11 权重信号量</strong></p><p>信号量中的计数器会随着用户对资源的访问和释放进行改变，引入的权重概念能够提供更细粒度的资源的访问控制，尽可能满足常见的用例。</p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 方法能用于获取指定权重的资源，这个方法总共由三个不同的情况组成：</p><ol><li>当信号量中剩余的资源大于获取的资源并且没有等待的 Goroutine 时就会直接获取信号量；</li><li>当需要获取的信号量大于 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 的上限时，由于不可能满足条件就会直接返回错误；</li><li>遇到其他情况时会将当前 Goroutine 加入到等待列表并通过 <code>select</code> 等待调度器唤醒当前 Goroutine，Goroutine 被唤醒后就会获取信号量；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Acquire</span><span class="params">(ctx context.Context, n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span> &#123;</span><br><span class="line">s.cur += n</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">w := waiter&#123;n: n, ready: ready&#125;</span><br><span class="line">elem := s.waiters.PushBack(w)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">err := ctx.Err()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ready:</span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">s.waiters.Remove(elem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"><span class="keyword">case</span> &lt;-ready:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个用于获取信号量的方法 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 只会非阻塞地判断当前信号量是否有充足的资源，如果有充足的资源就会直接立刻返回 <code>true</code>，否则就会返回 <code>false</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">TryAcquire</span><span class="params">(n <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">s.mu.Lock()</span><br><span class="line">success := s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> success &#123;</span><br><span class="line">s.cur += n</span><br><span class="line">&#125;</span><br><span class="line">s.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 不会等待资源的释放，所以可能更适用于一些延时敏感、用户需要立刻感知结果的场景。</p><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>当我们要释放信号量时，<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法会从头到尾遍历 <code>waiters</code> 列表中全部的等待者，如果释放资源后的信号量有充足的剩余资源就会通过 Channel 唤起指定的 Goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Release</span><span class="params">(n <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">s.mu.Lock()</span><br><span class="line">s.cur -= n</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">next := s.waiters.Front()</span><br><span class="line"><span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">w := next.Value.(waiter)</span><br><span class="line"><span class="keyword">if</span> s.size-s.cur &lt; w.n &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">s.cur += w.n</span><br><span class="line">s.waiters.Remove(next)</span><br><span class="line"><span class="built_in">close</span>(w.ready)</span><br><span class="line">&#125;</span><br><span class="line">s.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可能会出现剩余资源无法唤起 Goroutine 的情况，在这时当前方法就会释放锁后直接返回。</p><p>通过对 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法的分析我们能发现，如果一个信号量需要的占用的资源非常多，它可能会长时间无法获取锁，这也是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 方法引入上下文参数的原因，为信号量的获取设置超时时间。</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>带权重的信号量确实有着更多的应用场景，这也是 Go 语言对外提供的唯一一种信号量实现，在使用的过程中我们需要注意以下的几个问题：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 方法都可以用于获取资源，前者会阻塞地获取信号量，后者会非阻塞地获取信号量；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法会按照 FIFO 的顺序唤醒可以被唤醒的 Goroutine；</li><li>如果一个 Goroutine 获取了较多地资源，由于 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 的释放策略可能会等待比较长的时间；</li></ul><h3 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h3><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 是 Go 语言扩展包中提供了另一种同步原语，它能够在一个服务中抑制对下游的多次重复请求。一个比较常见的使用场景是 — 我们在使用 Redis 对数据库中的数据进行缓存，发生缓存击穿时，大量的流量都会打到数据库上进而影响服务的尾延时。</p><p><img alt="golang-query-without-single-flight" data-src="https://img.draveness.me/2020-01-23-15797104328070-golang-query-without-single-flight.png"></p><p><strong>图 6-12 Redis 缓存击穿问题</strong></p><p>但是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 能有效地解决这个问题，它能够限制对同一个 <code>Key</code> 的多次重复请求，减少对下游的瞬时流量。</p><p><img alt="golang-extension-single-flight" data-src="https://img.draveness.me/2020-01-23-15797104328078-golang-extension-single-flight.png"></p><p><strong>图 6-13 缓解缓存击穿问题</strong></p><p>在资源的获取非常昂贵时（例如：访问缓存、数据库），就很适合使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 对服务进行优化。我们来了解一下它的使用方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    requestGroup singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">handleRequest</span><span class="params">(ctx context.Context, request Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    v, err, _ := requestGroup.Do(request.Hash(), <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        rows, err := <span class="comment">// select * from tables</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response&#123;</span><br><span class="line">        rows: rows,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为请求的哈希在业务上一般表示相同的请求，所以上述代码使用它作为请求的键。当然，我们也可以选择其他的唯一字段作为 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 方法的第一个参数减少重复的请求。</p><h4 id="结构体-6"><a href="#结构体-6" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 结构体由一个互斥锁<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 和一个映射表组成，每一个 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体都保存了当前调用对应的信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line">m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err error</span><br><span class="line"></span><br><span class="line">dups  <span class="keyword">int</span></span><br><span class="line">chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体中的 <code>val</code> 和 <code>err</code> 字段都只会在执行传入的函数时赋值一次并在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 返回时被读取；<code>dups</code> 和 <code>chans</code> 两个字段分别存储了抑制的请求数量以及用于同步结果的 Channel。</p><h4 id="接口-4"><a href="#接口-4" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 提供了两个用于抑制相同请求的方法：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> — 同步等待的方法 <code>Do</code>；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> — 返回 Channel 异步等待的方法；</li></ul><p>这两个方法在功能上没有太多的区别，只是在接口的表现上稍有不同。</p><p>每次调用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 方法时都会获取互斥锁，随后判断是否已经存在 <code>key</code> 对应的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体：</p><ol><li>当不存在对应的</li></ol><p>   <code>x/sync/singleflight.call</code></p><p>   时：</p><ol><li>初始化一个新的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体指针；</li><li>增加 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 持有的计数器；</li><li>将 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体指针添加到映射表；</li><li>释放持有的互斥锁；</li><li>阻塞地调用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 方法等待结果的返回；</li></ol><ol><li>当存在对应的</li></ol><p>   <code>x/sync/singleflight.call</code></p><p>   时；</p><ol><li>增加 <code>dups</code> 计数器，它表示当前重复的调用次数；</li><li>释放持有的互斥锁；</li><li>通过 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 等待请求的返回；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(v <span class="keyword">interface</span>&#123;&#125;, err error, shared <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">c.dups++</span><br><span class="line">g.mu.Unlock()</span><br><span class="line">c.wg.Wait()</span><br><span class="line"><span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">c := <span class="built_in">new</span>(call)</span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line">g.m[key] = c</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">g.doCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>val</code> 和 <code>err</code> 两个字段都只会在 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 方法中赋值，所以当 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 返回时，函数调用的结果和错误都会返回给 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 函数的调用者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">doCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line">c.val, c.err = fn()</span><br><span class="line">c.wg.Done()</span><br><span class="line"></span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="built_in">delete</span>(g.m, key)</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>运行传入的函数 <code>fn</code>，该函数的返回值就会赋值给 <code>c.val</code> 和 <code>c.err</code>；</li><li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 方法通知所有等待结果的 Goroutine — 当前函数已经执行完成，可以从 <code>call</code> 结构体中取出返回值并返回了；</li><li>获取持有的互斥锁并通过管道将信息同步给使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 方法的 Goroutine；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">DoChan</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) &lt;-<span class="title">chan</span> <span class="title">Result</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">c.dups++</span><br><span class="line">c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line">g.m[key] = c</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 方法分别提供了同步和异步的调用方式，这让我们使用起来也更加灵活。</p><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>当我们需要减少对下游的相同请求时，就可以使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 来增加吞吐量和服务质量，不过在使用的过程中我们也需要注意以下的几个问题：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 一个用于同步阻塞调用传入的函数，一个用于异步调用传入的参数并通过 Channel 接收函数的返回值；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L113-L120" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Forget</code></a> 方法可以通知 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 在持有的映射表中删除某个键，接下来对该键的调用就不会等待前面的函数返回了；</li><li>一旦调用的函数返回了错误，所有在等待的 Goroutine 也都会接收到同样的错误；</li></ul><h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>我们在这一节中介绍了 Go 语言标准库中提供的基本原语以及扩展包中的扩展原语，这些并发编程的原语能够帮助我们更好地利用 Go 语言的特性构建高吞吐量、低延时的服务、解决并发带来的问题。</p><p>在设计同步原语时，我们不仅要考虑 API 接口的易用、解决并发编程中可能遇到的线程竞争问题，还需要对尾延时进行、优化保证公平性，理解同步原语也是我们理解并发编程无法跨越的一个步骤。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li>“sync: allow inlining the Mutex.Lock fast path” <a href="https://github.com/golang/go/commit/41cb0aedffdf4c5087de82710c4d016a3634b4ac" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/commit/41cb0aedffdf4c5087de82710c4d016a3634b4ac</a></li><li>“sync: allow inlining the Mutex.Unlock fast path” <a href="https://github.com/golang/go/commit/4c3f26076b6a9853bcc3c7d7e43726c044ac028a#diff-daec021895d1400f2c064a3e851c0d2c" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/commit/4c3f26076b6a9853bcc3c7d7e43726c044ac028a#diff-daec021895d1400f2c064a3e851c0d2c</a></li><li>“runtime: fall back to fair locks after repeated sleep-acquire failures” <a href="https://github.com/golang/go/issues/13086" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/issues/13086</a></li><li>Go Team. May 2014. “The Go Memory Model” <a href="https://golang.org/ref/mem" target="_blank" rel="external nofollow noopener noreferrer">https://golang.org/ref/mem</a></li><li>Chris. May 2017. “The X-Files: Exploring the Golang Standard Library Sub-Repositories” <a href="https://rodaine.com/2017/05/x-files-intro/" target="_blank" rel="external nofollow noopener noreferrer">https://rodaine.com/2017/05/x-files-intro/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言作为一个原生支持用户态进程（Goroutine）的语言，当提到并发编程、多线程编程时，往往都离不开锁这一概念。锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题。&lt;/p&gt;
&lt;p&gt;本节会介绍 Go 语言中常见的同步原语 &lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.Mutex&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.RWMutex&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.WaitGroup&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/once.go#L12-L20&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.Once&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/cond.go#L21-L29&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.Cond&lt;/code&gt;&lt;/a&gt; 以及扩展原语 &lt;a href=&quot;https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;errgroup.Group&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;semaphore.Weighted&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;singleflight.Group&lt;/code&gt;&lt;/a&gt; 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="并发" scheme="http://houmin.cc/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】调度策略</title>
    <link href="http://houmin.cc/posts/b130e91a/"/>
    <id>http://houmin.cc/posts/b130e91a/</id>
    <published>2020-08-03T06:39:15.000Z</published>
    <updated>2020-08-21T08:11:30.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文分析了Kubernetes内置的各种调度策略。</p><a id="more"></a><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><h3 id="整体梳理"><a href="#整体梳理" class="headerlink" title="整体梳理"></a>整体梳理</h3><div class="table-container"><table><thead><tr><th>策略名称</th><th>策略算法</th><th>备注</th></tr></thead><tbody><tr><td>CheckNodeUnschedulable</td><td>在 Node 节点上有一个 NodeUnschedulable 的标记，那这个节点就不会被调度了</td><td></td></tr><tr><td>CheckVolumeBinding</td><td>在 pvc 和 pv 的 binding 过程中对其进行逻辑校验</td><td></td></tr><tr><td>GeneralPredicates</td><td>是 PodFitsHostPorts，PodFitsResources，HostName，MatchNodeSelector这四个的组合</td><td></td></tr><tr><td>MatchInterPodAffinity</td><td>亲和性检查，当Node上所有正在运行的Pod与待调度的Pod不互相排斥时，则可调度</td><td></td></tr><tr><td>MaxAzureDiskVolumeCount</td><td>当Node上被挂载的Azure Disk Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>MaxCSIVolumeCountPred</td><td>当Node上被挂载的CSI Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>MaxEBSVolumeCount</td><td>当Node上被挂载的AWS EBS Volume超过默认限制39，该Node不可调度</td><td></td></tr><tr><td>MaxGCEPDVolumeCount</td><td>当Node上被挂载的GCD Persistent Disk超过默认限制16，该Node不可调度</td><td></td></tr><tr><td>MaxQcloudCbsVolumeCount</td><td>当Node上被挂载的Qcloud CBS Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>NoDiskConflict</td><td>当Node上所有Pod使用的卷和待调度Pod使用的卷存在冲突，该Node不可调度</td><td></td></tr><tr><td>NoVolumeZoneConflict</td><td>当Node上的zone-lable包含Pod中PV卷下的zone-label时，可以调度。当Node上没有zone-label，表示没有zone限制，也可调度</td><td></td></tr><tr><td>PodToleratesNodeTaints</td><td>当Pod可以容忍Node上所有的taint时，该Node才可以调度</td><td></td></tr><tr><td>PodFitsHostPorts</td><td>当待调度Pod中所有容器所用到的HostPort与Node上已使用的Port存在冲突，则无法调度</td><td></td></tr><tr><td>PodFitsResources</td><td>当总资源-Node中所有Pod对资源的request总量 &lt; 待调度的Pod request总量，则无法调度</td><td></td></tr><tr><td>HostName</td><td>如果待调度的Pod制定了pod.Spec.Host，则调度到该主机上</td><td></td></tr><tr><td>MatchNodeSelector</td><td>校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配</td><td></td></tr><tr><td>CheckNodeMemoryPressure</td><td>当Node剩余内存紧张时，BestEffort类型的Pod无法调度到该主机</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>CheckNodeDiskPressure</td><td>当Node剩余磁盘空间紧张时，无法调度到该主机</td><td></td></tr><tr><td>PodFitsHostPorts</td><td>当待调度Pod中所有容器所用到的HostPort与Node上已使用的Port存在冲突，则无法调度</td><td></td></tr><tr><td>PodFitsResources</td><td>当总资源-Node中所有Pod对资源的request总量 &lt; 待调度的Pod request总量，则无法调度</td><td></td></tr><tr><td>HostName</td><td>如果待调度的Pod制定了pod.Spec.Host，则调度到该主机上</td><td></td></tr><tr><td>EvenPodsSpread</td><td>在1.18版本默认启动，符合条件的一组 Pod 在指定 TopologyKey 上的打散要求</td><td></td></tr><tr><td>CheckNodeLabelPresence</td><td>主要用于检查指定的Label是否在Node上存在</td><td></td></tr><tr><td>CheckServiceAffinityPred</td><td>根据当前POD对象所属的service已有的其他POD对象所运行的节点进行调度，其目的在于将相同service的POD 对象放置与同一个或同一类节点上以提高效率，此预选此类试图将那些在其节点选择器中带有特定标签的POD资源调度至拥有同样标签的节点上，具体的标签则取决于用户的定义。</td></tr></tbody></table></div><h3 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h3><h4 id="NoVolumeZoneConflictPred"><a href="#NoVolumeZoneConflictPred" class="headerlink" title="NoVolumeZoneConflictPred"></a>NoVolumeZoneConflictPred</h4><p>当在 k8s 集群中使用 zone 时，所有的Node都会被标记上 zone label，下面四种是常见的lable的key：</p><figure class="highlight go"><figcaption><span>k8s.io/api/core/v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LabelZoneFailureDomain       = <span class="string">"failure-domain.beta.kubernetes.io/zone"</span></span><br><span class="line">LabelZoneRegion              = <span class="string">"failure-domain.beta.kubernetes.io/region"</span></span><br><span class="line">LabelZoneFailureDomainStable = <span class="string">"topology.kubernetes.io/zone"</span></span><br><span class="line">LabelZoneRegionStable        = <span class="string">"topology.kubernetes.io/region"</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.28</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">node.alpha.kubernetes.io/ttl:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">volumes.kubernetes.io/controller-managed-attach-detach:</span> <span class="string">"true"</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2020-07-20T12:11:34Z"</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"334106446"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/nodes/10.0.1.28</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">5943d3fc-0841-43f2-b519-c32af755c1c5</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/instance-type:</span> <span class="string">QCLOUD</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">    <span class="attr">cloud.tencent.com/node-instance-id:</span> <span class="string">ins-r3gy6izp</span></span><br><span class="line">    <span class="attr">failure-domain.beta.kubernetes.io/region:</span> <span class="string">bj</span></span><br><span class="line">    <span class="attr">failure-domain.beta.kubernetes.io/zone:</span> <span class="string">"800002"</span></span><br><span class="line">    <span class="attr">topology.kubernetes.io/region:</span> <span class="string">bj</span></span><br><span class="line">    <span class="attr">topology.kubernetes.io/zone:</span> <span class="string">"800002"</span></span><br><span class="line">    <span class="attr">kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.28</span></span><br><span class="line">    <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podCIDR:</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.128</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">podCIDRs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.128</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">providerID:</span> <span class="string">qcloud:///800002/ins-r3gy6izp</span></span><br></pre></td></tr></table></figure><p>当一个Pod有存储卷要求时，需要检查该存储卷的zone调度约束是否与Node的zone限制存在冲突。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/volumezone/volume_zone.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> pv.ObjectMeta.Labels &#123;</span><br><span class="line"><span class="keyword">if</span> !volumeZoneLabels.Has(k) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">nodeV, _ := nodeConstraints[k]</span><br><span class="line">volumeVSet, err := volumehelpers.LabelZonesToSet(v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">"Failed to parse label for %q: %q. Ignoring the label. err=%v. "</span>, k, v, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !volumeVSet.Has(nodeV) &#123;</span><br><span class="line">klog.V(<span class="number">10</span>).Infof(<span class="string">"Won't schedule pod %q onto node %q due to volume %q (mismatch on %q)"</span>, pod.Name, node.Name, pvName, k)</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonConflict)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过检查的条件是：属于该Pod的所有volumes都必须与Node上的zone label完全匹配。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(NoVolumeZoneConflictPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumezone.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckVolumeBindingPred"><a href="#CheckVolumeBindingPred" class="headerlink" title="CheckVolumeBindingPred"></a>CheckVolumeBindingPred</h4><p>在 pvc 和 pv 的 binding 过程中对其进行逻辑校验，里头的逻辑写的比较复杂，主要都是如何复用 pv；</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckVolumeBindingPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Reserve = appendToPluginSet(plugins.Reserve, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreBind = appendToPluginSet(plugins.PreBind, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NoDiskConflictPred"><a href="#NoDiskConflictPred" class="headerlink" title="NoDiskConflictPred"></a>NoDiskConflictPred</h4><p>SCSI 存储不会被重复的 volume, 检查在此主机上是否存在卷冲突。如果这个主机已经挂载了卷，其它同样使用这个卷的Pod不能调度到这个主机上，不同的存储后端具体规则不同</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(NoDiskConflictPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumerestrictions.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MaxCSIVolumeCountPred"><a href="#MaxCSIVolumeCountPred" class="headerlink" title="MaxCSIVolumeCountPred"></a>MaxCSIVolumeCountPred</h4><p>一个Pod请求Volumes的时候，节点上可能已经有Volumes，需要检查加上这个Pod之后的Volumes是否超过Node最大允许的Volumes限制。MaxCSIVolumeCountPred 用来校验 pvc 上指定的 Provision 在 CSI plugin 上的单机最大 pv 数限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> volumeLimitKey, count := <span class="keyword">range</span> newVolumeCount &#123;</span><br><span class="line">maxVolumeLimit, ok := nodeVolumeLimits[v1.ResourceName(volumeLimitKey)]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">currentVolumeCount := attachedVolumeCount[volumeLimitKey]</span><br><span class="line"><span class="keyword">if</span> currentVolumeCount+count &gt; <span class="keyword">int</span>(maxVolumeLimit) &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonMaxVolumeCountExceeded)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxCSIVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.CSIName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MaxNonCSIVolumeCountPred"><a href="#MaxNonCSIVolumeCountPred" class="headerlink" title="MaxNonCSIVolumeCountPred"></a>MaxNonCSIVolumeCountPred</h4><p>对于不是CSI标准的存储插件，也需要满足最大PV数限制，整体逻辑类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> numExistingVolumes+numNewVolumes &gt; maxAttachLimit &#123;</span><br><span class="line"><span class="comment">// violates MaxEBSVolumeCount or MaxGCEPDVolumeCount</span></span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonMaxVolumeCountExceeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MaxEBSVolumeCountPred"><a href="#MaxEBSVolumeCountPred" class="headerlink" title="MaxEBSVolumeCountPred"></a>MaxEBSVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxEBSVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.EBSName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxGCEPDVolumeCountPred"><a href="#MaxGCEPDVolumeCountPred" class="headerlink" title="MaxGCEPDVolumeCountPred"></a>MaxGCEPDVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxGCEPDVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.GCEPDName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxAzureDiskVolumeCountPred"><a href="#MaxAzureDiskVolumeCountPred" class="headerlink" title="MaxAzureDiskVolumeCountPred"></a>MaxAzureDiskVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxAzureDiskVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.AzureDiskName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxCinderVolumeCountPred"><a href="#MaxCinderVolumeCountPred" class="headerlink" title="MaxCinderVolumeCountPred"></a>MaxCinderVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxCinderVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.CinderName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-与-Node-匹配相关"><a href="#Pod-与-Node-匹配相关" class="headerlink" title="Pod 与 Node 匹配相关"></a>Pod 与 Node 匹配相关</h3><ul><li>CheckNodeCondition：校验节点是否准备好被调度，校验node.condition的condition type ：Ready为true和NetworkUnavailable为false以及Node.Spec.Unschedulable为false；</li><li></li><li>PodFitsHostPorts：校验 Pod 上的 Container 声明的 Ports 是否正在被 Node 上已经分配的 Pod 使用；</li><li>MatchNodeSelector: 校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配。</li></ul><h4 id="PodFitsHostPortsPred"><a href="#PodFitsHostPortsPred" class="headerlink" title="PodFitsHostPortsPred"></a>PodFitsHostPortsPred</h4><p><code>PodFitsHostPorts</code>策略主要用于校验 Pod 上的 Container 声明的 Ports 是否正在被 Node 上已经分配的 Pod 使用。</p><p>在 PreFilter 阶段，获取当前 Pod 对应的所有容器的Port，并且写入cycleState。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreFilter invoked at the prefilter extension point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePorts)</span> <span class="title">PreFilter</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">s := getContainerPorts(pod)</span><br><span class="line">cycleState.Write(preFilterStateKey, preFilterState(s))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Filter 阶段，从Cycle拿到当前Pod请求的Port，对比当前系统中已使用的 Port，看是否会发生冲突。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePorts)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">wantPorts, err := getPreFilterState(cycleState)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fits := fitsPorts(wantPorts, nodeInfo)</span><br><span class="line"><span class="keyword">if</span> !fits &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodFitsHostPortsPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="PodFitsResourcesPred"><a href="#PodFitsResourcesPred" class="headerlink" title="PodFitsResourcesPred"></a>PodFitsResourcesPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodFitsResourcesPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeResourcesFitArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.FitName, Args: args.NodeResourcesFitArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="PodToleratesNodeTaintsPred"><a href="#PodToleratesNodeTaintsPred" class="headerlink" title="PodToleratesNodeTaintsPred"></a>PodToleratesNodeTaintsPred</h4><p><code>PodToleratesNodeTaints</code>策略校验 Node 的 Taints 是否被 Pod Tolerates 包含。这里主要检查 <code>NoSchedule</code> 和 <code>NoExecute</code> 这两个 taint，如果不容忍，那么返回错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"invalid nodeInfo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filterPredicate := <span class="function"><span class="keyword">func</span><span class="params">(t *v1.Taint)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// PodToleratesNodeTaints is only interested in NoSchedule and NoExecute taints.</span></span><br><span class="line"><span class="keyword">return</span> t.Effect == v1.TaintEffectNoSchedule || t.Effect == v1.TaintEffectNoExecute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taint, isUntolerated := v1helper.FindMatchingUntoleratedTaint(nodeInfo.Node().Spec.Taints, pod.Spec.Tolerations, filterPredicate)</span><br><span class="line"><span class="keyword">if</span> !isUntolerated &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errReason := fmt.Sprintf(<span class="string">"node(s) had taint &#123;%s: %s&#125;, that the pod didn't tolerate"</span>,</span><br><span class="line">taint.Key, taint.Value)</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, errReason)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodToleratesNodeTaintsPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, tainttoleration.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="HostNamePred"><a href="#HostNamePred" class="headerlink" title="HostNamePred"></a>HostNamePred</h4><p><code>NodeNamePred</code>策略主要用于检查Pod Spec声明的Node Name是否与Node实际的Name匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filter invoked at the filter extension point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeName)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !Fits(pod, nodeInfo) &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fits actually checks if the pod fits the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fits</span><span class="params">(pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> || pod.Spec.NodeName == nodeInfo.Node().Name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(HostNamePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodename.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MatchNodeSelectorPred"><a href="#MatchNodeSelectorPred" class="headerlink" title="MatchNodeSelectorPred"></a>MatchNodeSelectorPred</h4><p><code>MatchNodeSelectorPred</code>策略用于校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PodMatchesNodeSelectorAndAffinityTerms</span><span class="params">(pod *v1.Pod, node *v1.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// Check if node.Labels match pod.Spec.NodeSelector.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeSelector) &gt; <span class="number">0</span> &#123;</span><br><span class="line">selector := labels.SelectorFromSet(pod.Spec.NodeSelector)</span><br><span class="line"><span class="keyword">if</span> !selector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. nil NodeSelector matches all nodes (i.e. does not filter out any nodes)</span></span><br><span class="line"><span class="comment">// 2. nil []NodeSelectorTerm (equivalent to non-nil empty NodeSelector) matches no nodes</span></span><br><span class="line"><span class="comment">// 3. zero-length non-nil []NodeSelectorTerm matches no nodes also, just for simplicity</span></span><br><span class="line"><span class="comment">// 4. nil []NodeSelectorRequirement (equivalent to non-nil empty NodeSelectorTerm) matches no nodes</span></span><br><span class="line"><span class="comment">// 5. zero-length non-nil []NodeSelectorRequirement matches no nodes also, just for simplicity</span></span><br><span class="line"><span class="comment">// 6. non-nil empty NodeSelectorRequirement is not allowed</span></span><br><span class="line">nodeAffinityMatches := <span class="literal">true</span></span><br><span class="line">affinity := pod.Spec.Affinity</span><br><span class="line"><span class="keyword">if</span> affinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity != <span class="literal">nil</span> &#123;</span><br><span class="line">nodeAffinity := affinity.NodeAffinity</span><br><span class="line"><span class="comment">// if no required NodeAffinity requirements, will do no-op, means select all nodes.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Replace next line with subsequent commented-out line when implement RequiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="keyword">if</span> nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// if nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution == nil &amp;&amp; nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == nil &#123;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match node selector for requiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Uncomment this block when implement RequiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="comment">// if nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution != nil &#123;</span></span><br><span class="line"><span class="comment">// nodeSelectorTerms := nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution.NodeSelectorTerms</span></span><br><span class="line"><span class="comment">// klog.V(10).Infof("Match for RequiredDuringSchedulingRequiredDuringExecution node selector terms %+v", nodeSelectorTerms)</span></span><br><span class="line"><span class="comment">// nodeAffinityMatches = nodeMatchesNodeSelectorTerms(node, nodeSelectorTerms)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Match node selector for requiredDuringSchedulingIgnoredDuringExecution.</span></span><br><span class="line"><span class="keyword">if</span> nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution != <span class="literal">nil</span> &#123;</span><br><span class="line">nodeSelectorTerms := nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms</span><br><span class="line">nodeAffinityMatches = nodeAffinityMatches &amp;&amp; nodeMatchesNodeSelectorTerms(node, nodeSelectorTerms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodeAffinityMatches</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个典型的Node亲和性示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">pod: &amp;v1.Pod&#123;</span><br><span class="line">Spec: v1.PodSpec&#123;</span><br><span class="line">Affinity: &amp;v1.Affinity&#123;</span><br><span class="line">NodeAffinity: &amp;v1.NodeAffinity&#123;</span><br><span class="line">RequiredDuringSchedulingIgnoredDuringExecution: &amp;v1.NodeSelector&#123;</span><br><span class="line">NodeSelectorTerms: []v1.NodeSelectorTerm&#123;</span><br><span class="line">&#123;</span><br><span class="line">MatchExpressions: []v1.NodeSelectorRequirement&#123;</span><br><span class="line">&#123;</span><br><span class="line">Key:      <span class="string">"kernel-version"</span>,</span><br><span class="line">Operator: v1.NodeSelectorOpGt,</span><br><span class="line">Values:   []<span class="keyword">string</span>&#123;<span class="string">"0204"</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">labels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="comment">// We use two digit to denote major version and two digit for minor version.</span></span><br><span class="line"><span class="string">"kernel-version"</span>: <span class="string">"0206"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">name: <span class="string">"Pod with matchExpressions using Gt operator that matches the existing node"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MatchNodeSelectorPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="GeneralPred"><a href="#GeneralPred" class="headerlink" title="GeneralPred"></a>GeneralPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(GeneralPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// GeneralPredicate is a combination of predicates.</span></span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeResourcesFitArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.FitName, Args: args.NodeResourcesFitArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodename.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckNodeUnschedulablePred"><a href="#CheckNodeUnschedulablePred" class="headerlink" title="CheckNodeUnschedulablePred"></a>CheckNodeUnschedulablePred</h4><p><code>CheckNodeUnschedulable</code> 在 node 节点上有一个 NodeUnschedulable 的标记，那这个节点就不会被调度了，形如这种。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node: &amp;v1.Node&#123;</span><br><span class="line">   Spec: v1.NodeSpec&#123;</span><br><span class="line">     Unschedulable: <span class="literal">true</span>,</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>在 1.16 的版本里，这个 Unschedulable 已经变成了一个 Taints。也就是说需要校验一下 Pod 上打上的 Tolerates 是不是可以容忍这个 Taints。如果容忍了这个不可调度的taint，那么它也可以容忍 NodeSpec的不可调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeUnschedulable)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonUnknownCondition)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If pod tolerate unschedulable taint, it's also tolerate `node.Spec.Unschedulable`.</span></span><br><span class="line">podToleratesUnschedulable := v1helper.TolerationsTolerateTaint(pod.Spec.Tolerations, &amp;v1.Taint&#123;</span><br><span class="line">Key:    v1.TaintNodeUnschedulable,</span><br><span class="line">Effect: v1.TaintEffectNoSchedule,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TODO (k82cn): deprecates `node.Spec.Unschedulable` in 1.13.</span></span><br><span class="line"><span class="keyword">if</span> nodeInfo.Node().Spec.Unschedulable &amp;&amp; !podToleratesUnschedulable &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonUnschedulable)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckNodeUnschedulablePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeunschedulable.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckNodeLabelPresencePred"><a href="#CheckNodeLabelPresencePred" class="headerlink" title="CheckNodeLabelPresencePred"></a>CheckNodeLabelPresencePred</h4><p><code>CheckNodeLablePresencePred</code>策略主要用于检查指定的Label是否在Node上存在。这里检查的是两种情况：</p><ul><li>一种检查Node上面是否有指定Label。比如有时候通过 <code>region/zone/racks</code> 这种label来划分空间，想要把Pod调度到有特定region/zone/racks的Node。</li><li>一种是检查Node上面是否没有指定的Label。比如有的Node被打上 <code>retiring</code> 的 label，想要制定Pod不调度到这些Node上。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeLabel)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line">nodeLabels := labels.Set(node.Labels)</span><br><span class="line">check := <span class="function"><span class="keyword">func</span><span class="params">(labels []<span class="keyword">string</span>, presence <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> labels &#123;</span><br><span class="line">exists := nodeLabels.Has(label)</span><br><span class="line"><span class="keyword">if</span> (exists &amp;&amp; !presence) || (!exists &amp;&amp; presence) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> check(pl.args.PresentLabels, <span class="literal">true</span>) &amp;&amp; check(pl.args.AbsentLabels, <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonPresenceViolated)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个策略，需要在注册的时候设定策略插件的参数。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckNodeLabelPresencePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodelabel.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-与-Pod-匹配相关"><a href="#Pod-与-Pod-匹配相关" class="headerlink" title="Pod 与 Pod 匹配相关"></a>Pod 与 Pod 匹配相关</h3><h4 id="MatchInterPodAffinityPred"><a href="#MatchInterPodAffinityPred" class="headerlink" title="MatchInterPodAffinityPred"></a>MatchInterPodAffinityPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MatchInterPodAffinityPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line">registry.registerPredicateConfigProducer(CheckNodeLabelPresencePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodelabel.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-服务打散相关"><a href="#Pod-服务打散相关" class="headerlink" title="Pod 服务打散相关"></a>Pod 服务打散相关</h3><h4 id="EvenPodsSpread"><a href="#EvenPodsSpread" class="headerlink" title="EvenPodsSpread"></a>EvenPodsSpread</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(EvenPodsSpreadPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckServiceAffinity"><a href="#CheckServiceAffinity" class="headerlink" title="CheckServiceAffinity"></a>CheckServiceAffinity</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckServiceAffinityPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, serviceaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.ServiceAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: serviceaffinity.Name, Args: args.ServiceAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, serviceaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h2><h3 id="整体梳理-1"><a href="#整体梳理-1" class="headerlink" title="整体梳理"></a>整体梳理</h3><div class="table-container"><table><thead><tr><th>策略名称</th><th>策略算法</th><th>权重</th></tr></thead><tbody><tr><td>BalancedResourceAllocation</td><td>CPU和内存利用率越接近，得分越高</td><td>1</td></tr><tr><td>ImageLocalityPriority</td><td>待调度的Pod会使用一些镜像，拥有这些镜像越多的节点，得分越高</td><td>1</td></tr><tr><td>InterPodAffinityPriority</td><td>Pod与Node上正运行的其他Pod亲和性匹配度越高，得分越高</td><td>1</td></tr><tr><td>LeastRequestedPriority</td><td>剩余资源越多，得分越高</td><td>1</td></tr><tr><td>NodeAffinityPriority</td><td>Pod与Node亲和性匹配度越高，得分越高</td><td>1</td></tr><tr><td>NodePreferAvoidPodsPriority</td><td>该Node的annotation scheduler.alpha.kubernetes.io/preferAvoidPods被设置时，说明该Node不希望被调度，得分低。</td><td>10000</td></tr><tr><td>SelectorSpreadPriority</td><td>相同service/rc的Pods越分散，得分越高</td><td>1</td></tr><tr><td>TaintTolerationPriority</td><td>Pod对Node的taint容忍度越高，得分越高</td><td>1</td></tr><tr><td>ServiceSpreadingPriority</td><td>相同Service的Pods越分散，得分越高，被 SelectorSpreadPriority取代，保留在系统中并不使用</td><td>1</td></tr><tr><td>EqualPriority</td><td>所有机器得分一样</td><td>1</td></tr><tr><td>MostRequestPriority</td><td>Request资源越多，得分越高，与LeastRequestPriority相反</td><td>1</td></tr><tr><td>EvenPodsSpreadPriority</td><td>在1.18版本默认启动，用来指定一组符合条件的 Pod 在某个拓扑结构上的打散需求，这样是比较灵活、比较定制化的一种方式，使用起来也是比较复杂的一种方式</td><td>2</td></tr><tr><td>RequestedToCapacityRatioName</td><td>允许用户对于CPU、内存和扩展加速卡等资源实现bin packing</td><td></td></tr><tr><td>NodeLabel</td><td>主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配。</td><td></td></tr><tr><td>ServiceAffinity</td><td>是为了支持 Service 下的 Pod 的分布要按照 Node 的某个 label 的值进行均衡。</td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><p>打分算法主要解决的问题就是集群的碎片、容灾、水位、亲和、反亲和等，可以分为以下四个大类。</p><h3 id="资源水位"><a href="#资源水位" class="headerlink" title="资源水位"></a>资源水位</h3><ul><li>资源水位公式的概念：Request：Node 已经分配的资源；Allocatable：Node 的可调度的资源。</li><li>优先打散：把 Pod 分到资源空闲率最高的节点上，而非空闲资源最大的节点，公式：资源空闲率 = (Allocatable - Request) / Allocatable，当这个值越大，表示分数越高，优先分配到高分数的节点。其中 (Allocatable - Request) 表示为 Pod 分配到这个节点之后空闲的资源数。</li><li>优先堆叠：把 Pod 分配到资源使用率最高的节点上，公式:资源使用率 = Request / Allocatable ，资源使用率越高，表示得分越高，会优先分配到高分数的节点。</li><li>碎片率：是指 Node 上的多种资源之间的资源使用率的差值，目前支持 CPU/Mem/Disk 三类资源, 假如仅考虑 CPU/Mem，那么碎片率的公式 = Abs[CPU(Request / Allocatable) - Mem(Request / Allocatable)] 。举一个例子，当 CPU 的分配率是 99%，内存的分配率是 50%，那么碎片率 = 99% - 50% = 50%，那么这个例子中剩余 1% CPU, 50% Mem，很难有这类规格的容器能用完 Mem。得分 = 1 - 碎片率，碎片率越高得分低。</li><li>指定比率：可以在 Scheduler 启动的时候，为每一个资源使用率设置得分，从而实现控制集群上 node 资源分配分布曲线。</li></ul><h4 id="LeastRequestedPriority"><a href="#LeastRequestedPriority" class="headerlink" title="LeastRequestedPriority"></a>LeastRequestedPriority</h4><p><code>LeastRequestedPriority</code> 策略对于那些使用率越低的Node的优先级越高。通过这种算法，可以使得各个节点的资源得到均衡利用。</p><p>计算公式如下：</p><script type="math/tex; mode=display">(cpu((capacity-sum(requested))*MaxNodeScore/capacity) + memory((capacity-sum(requested))*MaxNodeScore/capacity))/weightSum</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(LeastRequestedPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.LeastAllocatedName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MostRequestedPriority"><a href="#MostRequestedPriority" class="headerlink" title="MostRequestedPriority"></a>MostRequestedPriority</h4><p><code>MostRequestedPriority</code> 策略对于那些使用率更高的Node的优先级更高。这种算法在动态伸缩集群环境比较适用，会优先调度pod到使用率最高的主机节点，这样在伸缩集群时，就会腾出空闲机器，从而进行停机处理。</p><p>其计算公式如下：</p><script type="math/tex; mode=display">(cpu(MaxNodeScore * sum(requested) / capacity) + memory(MaxNodeScore * sum(requested) / capacity)) / weightSum</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(MostRequestedPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.MostAllocatedName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="BalancedResourceAllocation"><a href="#BalancedResourceAllocation" class="headerlink" title="BalancedResourceAllocation"></a>BalancedResourceAllocation</h4><p>BalancedResourceAllocation：尽量选择在部署Pod后各项资源更均衡的机器。BalancedResourceAllocation不能单独使用，而且必须和LeastRequestedPriority同时使用，它分别计算主机上的cpu和memory的比重，主机的分值由cpu比重和memory比重的“距离”决定。</p><p>计算公式如下：</p><script type="math/tex; mode=display">score = (1 - variance(cpuFraction,memoryFraction,volumeFraction)) * MaxNodeScore</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(BalancedResourceAllocation,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.BalancedAllocationName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="RequestedToCapacityRatioPriority"><a href="#RequestedToCapacityRatioPriority" class="headerlink" title="RequestedToCapacityRatioPriority"></a>RequestedToCapacityRatioPriority</h4><p><code>RequestedToCapacityRatioPriority</code>允许用户对于CPU、内存和扩展加速卡等资源实现bin packing。</p><p>所谓 <a href="https://en.wikipedia.org/wiki/Bin_packing_problem" target="_blank" rel="external nofollow noopener noreferrer">Bin Packing</a> ，又称装箱问题，是运筹学中的一个经典问题。问题的背景是，现有若干个小盒子，想要把它们装进有限个给定大小的箱子中，如何既能够装的多油装的快，使得尽可能每个箱子都装满，从而减少箱子的使用数目。BinPack问题有很多变种，当限制箱子的数目为1，每个盒子给定value和weight，binpack问题就变成了背包问题。</p><p>Kubernetes默认开启的资源调度策略是Spread的策略，资源尽量打散，但是会导致较多的资源碎片，使得整体资源利用率下降。通过RequestedToCapacityRatioPriority配置支持CPU、内存和GPU等扩展卡的权重，在打分阶段计算对应资源的利用率，通过利用率进行排序，优先打满一个节点后再向后调度，从而实现bin packing。</p><p><code>RequestedToCapacityRatioResourceAllocation</code> 优先级函数的行为可以通过名为 <code>requestedToCapacityRatioArguments</code> 的配置选项进行控制。 该标志由两个参数 <code>shape</code> 和 <code>resources</code> 组成。 shape 允许用户根据 <code>utilization</code> 和 <code>score</code> 值将函数调整为最少请求（least requested）或 最多请求（most requested）计算。 resources 由 <code>name</code> 和 <code>weight</code> 组成，<code>name</code> 指定评分时要考虑的资源，<code>weight</code> 指定每种资源的权重。</p><p>以下是一个配置示例，该配置将 <code>requestedToCapacityRatioArguments</code> 设置为对扩展资源 <code>intel.com/foo</code> 和 <code>intel.com/bar</code> 的装箱行为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kind"</span> : <span class="string">"Policy"</span>,</span><br><span class="line">    <span class="attr">"apiVersion"</span> : <span class="string">"v1"</span>,</span><br><span class="line">    ...</span><br><span class="line">    "priorities" : [</span><br><span class="line">       ...</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"RequestedToCapacityRatioPriority"</span>,</span><br><span class="line">        <span class="attr">"weight"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"argument"</span>: &#123;</span><br><span class="line">          <span class="attr">"requestedToCapacityRatioArguments"</span>: &#123;</span><br><span class="line">            <span class="attr">"shape"</span>: [</span><br><span class="line">              &#123;<span class="attr">"utilization"</span>: <span class="number">0</span>, <span class="attr">"score"</span>: <span class="number">0</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">"utilization"</span>: <span class="number">100</span>, <span class="attr">"score"</span>: <span class="number">10</span>&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"resources"</span>: [</span><br><span class="line">              &#123;<span class="attr">"name"</span>: <span class="string">"intel.com/foo"</span>, <span class="attr">"weight"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">"name"</span>: <span class="string">"intel.com/bar"</span>, <span class="attr">"weight"</span>: <span class="number">5</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际上，这里的shape参数定义的是不同utilization下对应的得分，是对 <code>LeastRequestedPriority</code> 和 <code>MostRequestedPriority</code> 的进一步抽象。</p><p>这种配置对应的是<code>LeastRequestedPriority</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">0</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">10</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">100</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">0</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这种配置对应的是<code>MostRequestedPriority</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">0</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">0</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">100</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">10</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(noderesources.RequestedToCapacityRatioName,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.RequestedToCapacityRatioName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">if</span> args.RequestedToCapacityRatioArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.RequestedToCapacityRatioName, Args: args.RequestedToCapacityRatioArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-打散"><a href="#Pod-打散" class="headerlink" title="Pod 打散"></a>Pod 打散</h3><p>Pod打散目的是支持符合条件的一组 Pod 在不同 topology 上部署的 spread 需求。</p><h4 id="ServiceSpreadingPriority"><a href="#ServiceSpreadingPriority" class="headerlink" title="ServiceSpreadingPriority"></a>ServiceSpreadingPriority</h4><p>ServiceSpreadingPriority：官方注释上说大概率会用来替换 SelectorSpreadPriority，为什么呢？我个人理解：Service 代表一组服务，我们只要能做到服务的打散分配就足够了。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(EvenPodsSpreadPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="EvenPodsSpread-1"><a href="#EvenPodsSpread-1" class="headerlink" title="EvenPodsSpread"></a>EvenPodsSpread</h4><p>EvenPodsSpreadPriority：用来指定一组符合条件的 Pod 在某个拓扑结构上的打散需求，这样是比较灵活、比较定制化的一种方式，使用起来也是比较复杂的一种方式。因为这个使用方式可能会一直变化，我们假设这个拓扑结构是这样的：Spec 是要求在 node 上进行分布的，我们就可以按照上图中的计算公式，计算一下在这个 node 上满足 Spec 指定 labelSelector 条件的 pod 数量，然后计算一下最大的差值，接着计算一下 Node 分配的权重，如果说这个值越大，表示这个值越优先。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(EvenPodsSpreadPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, podtopologyspread.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckServiceAffinity-1"><a href="#CheckServiceAffinity-1" class="headerlink" title="CheckServiceAffinity"></a>CheckServiceAffinity</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(serviceaffinity.Name,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// If there are n ServiceAffinity priorities in the policy, the weight for the corresponding</span></span><br><span class="line"><span class="comment">// score plugin is n*weight (note that the validation logic verifies that all ServiceAffinity</span></span><br><span class="line"><span class="comment">// priorities specified in Policy have the same weight).</span></span><br><span class="line">weight := args.Weight * <span class="keyword">int32</span>(<span class="built_in">len</span>(args.ServiceAffinityArgs.AntiAffinityLabelsPreference))</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, serviceaffinity.Name, &amp;weight)</span><br><span class="line"><span class="keyword">if</span> args.ServiceAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: serviceaffinity.Name, Args: args.ServiceAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="SelectorSpreadPriority"><a href="#SelectorSpreadPriority" class="headerlink" title="SelectorSpreadPriority"></a>SelectorSpreadPriority</h4><p>SelectorSpreadPriority：用于实现 Pod 所属的 Controller 下所有的 Pod 在 Node 上打散的要求。实现方式是这样的：它会依据待分配的 Pod 所属的 controller，计算该 controller 下的所有 Pod,假设总数为 T，对这些 Pod 按照所在的 Node 分组统计；假设为 N (表示为某个 Node 上的统计值)，那么对 Node上的分数统计为  (T-N)/T 的分数，值越大表示这个节点的 controller 部署的越少，分数越高，从而达到 workload 的 pod 打散需求。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(SelectorSpreadPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, selectorspread.Name, &amp;args.Weight)</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, selectorspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-亲和-反亲和"><a href="#Pod-亲和-反亲和" class="headerlink" title="Pod 亲和/反亲和"></a>Pod 亲和/反亲和</h3><h4 id="InterPodAffinityPriority"><a href="#InterPodAffinityPriority" class="headerlink" title="InterPodAffinityPriority"></a>InterPodAffinityPriority</h4><p>InterPodAffinityPriority：先介绍一下使用场景：第一个例子，比如说应用 A 提供数据，应用 B 提供服务，A 和 B 部署在一起可以走本地网络，优化网络传输；第二个例子，如果应用 A 和应用 B 之间都是 CPU 密集型应用，而且证明它们之间是会互相干扰的，那么可以通过这个规则设置尽量让它们不在一个节点上。pod亲和性选择策略，类似NodeAffinityPriority，提供两种选择器支持：requiredDuringSchedulingIgnoredDuringExecution（保证所选的主机必须满足所有Pod对主机的规则要求）、preferresDuringSchedulingIgnoredDuringExecution（调度器会尽量但不保证满足NodeSelector的所有要求），两个子策略：podAffinity和podAntiAffinity</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(InterPodAffinityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, interpodaffinity.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">if</span> args.InterPodAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: interpodaffinity.Name, Args: args.InterPodAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Node-亲和-反亲和"><a href="#Node-亲和-反亲和" class="headerlink" title="Node 亲和/反亲和"></a>Node 亲和/反亲和</h3><ul><li>NodeAffinityPriority，这个是为了满足 Pod 和 Node 的亲和 &amp; 反亲和；</li><li>ServiceAntiAffinity，是为了支持 Service 下的 Pod 的分布要按照 Node 的某个 label 的值进行均衡。比如：集群的节点有云上也有云下两组节点，我们要求服务在云上云下均衡去分布，假设 Node 上有某个 label，那我们就可以用这个 ServiceAntiAffinity 进行打散分布；</li><li>NodeLabelPrioritizer，主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配;</li><li>ImageLocalityPriority，节点亲和主要考虑的是镜像下载的速度。如果节点里面存在镜像的话，优先把 Pod 调度到这个节点上，这里还会去考虑镜像的大小，比如这个 Pod 有好几个镜像，镜像越大下载速度越慢，它会按照节点上已经存在的镜像大小优先级亲和。</li></ul><h4 id="NodePreferAvoidPodsPriority"><a href="#NodePreferAvoidPodsPriority" class="headerlink" title="NodePreferAvoidPodsPriority"></a>NodePreferAvoidPodsPriority</h4><p><code>NodePreferAvoidPodsPriority</code>策略用于实现某些 controller 尽量不分配到某些节点上的能力；通过在 node 上加 annotation 声明哪些 controller 不要分配到 Node 上，如果不满足就优先。</p><p>具体实现就是会在Node上加上Annotation，形如这种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">annotations1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">v1.PreferAvoidPodsAnnotationKey: <span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "preferAvoidPods": [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "podSignature": &#123;</span></span><br><span class="line"><span class="string">                "podController": &#123;</span></span><br><span class="line"><span class="string">                    "apiVersion": "v1",</span></span><br><span class="line"><span class="string">                    "kind": "ReplicationController",</span></span><br><span class="line"><span class="string">                    "name": "foo",</span></span><br><span class="line"><span class="string">                    "uid": "abcdef123456",</span></span><br><span class="line"><span class="string">                    "controller": true</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "reason": "some reason",</span></span><br><span class="line"><span class="string">            "message": "some message"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在检查的时候，对于那些不被 <code>ReplicaSet</code> 和 <code>ReplicationController</code> 拥有的 Pod，直接跳过，给予最高分。如果和 <code>annotation</code> 中标记的相同，那么给予最低分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePreferAvoidPods)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v"</span>, nodeName, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">controllerRef := metav1.GetControllerOf(pod)</span><br><span class="line"><span class="keyword">if</span> controllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Ignore pods that are owned by other controller than ReplicationController</span></span><br><span class="line"><span class="comment">// or ReplicaSet.</span></span><br><span class="line"><span class="keyword">if</span> controllerRef.Kind != <span class="string">"ReplicationController"</span> &amp;&amp; controllerRef.Kind != <span class="string">"ReplicaSet"</span> &#123;</span><br><span class="line">controllerRef = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> controllerRef == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avoids, err := v1helper.GetAvoidPodsFromNodeAnnotations(node.Annotations)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If we cannot get annotation, assume it's schedulable there.</span></span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> avoids.PreferAvoidPods &#123;</span><br><span class="line">avoid := &amp;avoids.PreferAvoidPods[i]</span><br><span class="line"><span class="keyword">if</span> avoid.PodSignature.PodController.Kind == controllerRef.Kind &amp;&amp; avoid.PodSignature.PodController.UID == controllerRef.UID &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(NodePreferAvoidPodsPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodepreferavoidpods.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NodeAffinityPriority"><a href="#NodeAffinityPriority" class="headerlink" title="NodeAffinityPriority"></a>NodeAffinityPriority</h4><p><code>NodeAffinityPriority</code>策略用于满足Pod与Node之间的亲和与反亲和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">affinity := pod.Spec.Affinity</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="comment">// A nil element of PreferredDuringSchedulingIgnoredDuringExecution matches no objects.</span></span><br><span class="line"><span class="comment">// An element of PreferredDuringSchedulingIgnoredDuringExecution that refers to an</span></span><br><span class="line"><span class="comment">// empty PreferredSchedulingTerm matches all objects.</span></span><br><span class="line"><span class="keyword">if</span> affinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Match PreferredDuringSchedulingIgnoredDuringExecution term by term.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution &#123;</span><br><span class="line">preferredSchedulingTerm := &amp;affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i]</span><br><span class="line"><span class="keyword">if</span> preferredSchedulingTerm.Weight == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Avoid computing it for all nodes if this becomes a performance problem.</span></span><br><span class="line">nodeSelector, err := v1helper.NodeSelectorRequirementsAsSelector(preferredSchedulingTerm.Preference.MatchExpressions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nodeSelector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line">count += <span class="keyword">int64</span>(preferredSchedulingTerm.Weight)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(NodeAffinityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodeaffinity.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="TaintTolerationPriority"><a href="#TaintTolerationPriority" class="headerlink" title="TaintTolerationPriority"></a>TaintTolerationPriority</h4><p><code>TaintTolerationPriority</code> 策略，Pod 对 Node 的 taint 容忍程度越高，优先级越大。</p><p>在 <code>PreScore</code> 阶段，拿到所有 <code>all Tolerations with Effect PreferNoSchedule or with no effect</code>，并将其写到cycleState。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">PreScore</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodes []*v1.Node)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">tolerationsPreferNoSchedule := getAllTolerationPreferNoSchedule(pod.Spec.Tolerations)</span><br><span class="line">state := &amp;preScoreState&#123;</span><br><span class="line">tolerationsPreferNoSchedule: tolerationsPreferNoSchedule,</span><br><span class="line">&#125;</span><br><span class="line">cycleState.Write(preScoreStateKey, state)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>在 <code>Score</code> 阶段，具体算法就是Pod不能容忍的taint越多，那么得分就越高（之后会在Normalize处正则化，将得分逆序），也就是其优先级越低。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v"</span>, nodeName, err))</span><br><span class="line">&#125;</span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"></span><br><span class="line">s, err := getPreScoreState(state)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">score := <span class="keyword">int64</span>(countIntolerableTaintsPreferNoSchedule(node.Spec.Taints, s.tolerationsPreferNoSchedule))</span><br><span class="line"><span class="keyword">return</span> score, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(TaintTolerationPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, tainttoleration.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, tainttoleration.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ImageLocalityPriority"><a href="#ImageLocalityPriority" class="headerlink" title="ImageLocalityPriority"></a>ImageLocalityPriority</h4><p><code>ImageLocalityPriority</code>策略主要考虑的是镜像下载的速度。如果节点里面存在镜像的话，优先把 Pod 调度到这个节点上，这里还会去考虑镜像的大小，比如这个 Pod 有好几个镜像，镜像越大下载速度越慢，它会按照节点上已经存在的镜像大小优先级亲和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumImageScores</span><span class="params">(nodeInfo *framework.NodeInfo, containers []v1.Container, totalNumNodes <span class="keyword">int</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> _, container := <span class="keyword">range</span> containers &#123;</span><br><span class="line"><span class="keyword">if</span> state, ok := nodeInfo.ImageStates[normalizedImageName(container.Image)]; ok &#123;</span><br><span class="line">sum += scaledImageScore(state, totalNumNodes)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(ImageLocalityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, imagelocality.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NodeLabel"><a href="#NodeLabel" class="headerlink" title="NodeLabel"></a>NodeLabel</h4><p><code>NodeLabel</code>策略主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeLabel)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v, node is nil: %v"</span>, nodeName, err, nodeInfo.Node() == <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line">score := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> pl.args.PresentLabelsPreference &#123;</span><br><span class="line"><span class="keyword">if</span> labels.Set(node.Labels).Has(label) &#123;</span><br><span class="line">score += framework.MaxNodeScore</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> pl.args.AbsentLabelsPreference &#123;</span><br><span class="line"><span class="keyword">if</span> !labels.Set(node.Labels).Has(label) &#123;</span><br><span class="line">score += framework.MaxNodeScore</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Take average score for each label to ensure the score doesn't exceed MaxNodeScore.</span></span><br><span class="line">score /= <span class="keyword">int64</span>(<span class="built_in">len</span>(pl.args.PresentLabelsPreference) + <span class="built_in">len</span>(pl.args.AbsentLabelsPreference))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> score, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(nodelabel.Name,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// If there are n LabelPreference priorities in the policy, the weight for the corresponding</span></span><br><span class="line"><span class="comment">// score plugin is n*weight (note that the validation logic verifies that all LabelPreference</span></span><br><span class="line"><span class="comment">// priorities specified in Policy have the same weight).</span></span><br><span class="line">weight := args.Weight * <span class="keyword">int32</span>(<span class="built_in">len</span>(args.NodeLabelArgs.PresentLabelsPreference)+<span class="built_in">len</span>(args.NodeLabelArgs.AbsentLabelsPreference))</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodelabel.Name, &amp;weight)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文分析了Kubernetes内置的各种调度策略。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="scheduler" scheme="http://houmin.cc/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Make 与 New</title>
    <link href="http://houmin.cc/posts/9e0b725c/"/>
    <id>http://houmin.cc/posts/9e0b725c/</id>
    <published>2020-08-03T04:16:08.000Z</published>
    <updated>2020-08-21T08:11:30.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — <code>make</code> 和 <code>new</code>。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>，但是它们两者能够初始化的却有较大的不同。</p><ul><li><code>make</code> 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>；</li><li><code>new</code> 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>；</li></ul><a id="more"></a><p>我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">10</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ol><li><code>slice</code> 是一个包含 <code>data</code>、<code>cap</code> 和 <code>len</code> 的私有结构体 <a href="https://github.com/golang/go/blob/a5026af57c7934f0856cfd4b539a7859d85a0474/src/internal/reflectlite/value.go#L389-L393" target="_blank" rel="external nofollow noopener noreferrer"><code>internal/reflectlite.sliceHeader</code></a>；</li><li><code>hash</code> 是一个指向 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L115-L129" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hmap</code></a> 结构体的指针；</li><li><code>ch</code> 是一个指向 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L32-L51" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 结构体的指针；</li></ol><p>相比与复杂的 <code>make</code> 关键字，<code>new</code> 的功能就很简单了，它只能接收一个类型作为参数然后返回一个指向该类型的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">int</span></span><br><span class="line">i := &amp;v</span><br></pre></td></tr></table></figure><p>上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 <code>int</code> 零值的指针。</p><p><img alt="golang-make-and-ne" data-src="https://img.draveness.me/golang-make-and-new.png"></p><p>接下来我们将分别介绍 <code>make</code> 和 <code>new</code> 在初始化不同数据结构时的过程，我们会从编译期间和运行时两个不同阶段理解这两个关键字的原理，不过由于前面的章节已经详细地分析过 <code>make</code> 的原理，所以这里会将重点放在另一个关键字 <code>new</code> 上。</p><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>在前面的章节中我们已经谈到过 <code>make</code> 在创建切片、哈希表和 Channel 的具体过程，所以在这一小节，我们只是会简单提及 <code>make</code> 相关的数据结构的初始化原理。</p><p><img alt="golang-make-typecheck" data-src="https://img.draveness.me/golang-make-typecheck.png"></p><p>在编译期间的<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/" target="_blank" rel="external nofollow noopener noreferrer">类型检查</a>阶段，Go 语言就将代表 <code>make</code> 关键字的 <code>OMAKE</code> 节点根据参数类型的不同转换成了 <code>OMAKESLICE</code>、<code>OMAKEMAP</code> 和 <code>OMAKECHAN</code> 三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>编译器会在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">中间代码生成</a>阶段通过以下两个函数处理该关键字：</p><ol><li><p><a href="https://github.com/golang/go/blob/316fd8cc4a7fab2e1bb45848bc30ea8b8a0b231a/src/cmd/compile/internal/gc/walk.go#L1930-L1940" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.callnew</code></a> 函数会将关键字转换成 <code>ONEWOBJ</code> 类型的节点<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>；</p></li><li><p><code>cmd/compile/internal/gc.state.expr</code></p></li></ol><p>   函数会根据申请空间的大小分两种情况处理：</p><ol><li>如果申请的空间为 0，就会返回一个表示空指针的 <code>zerobase</code> 变量；</li><li>在遇到其他情况时会将关键字转换成 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 函数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callnew</span><span class="params">(t *types.Type)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">n := nod(ONEWOBJ, typename(t), <span class="literal">nil</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> ONEWOBJ:</span><br><span class="line"><span class="keyword">if</span> n.Type.Elem().Size() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s.newValue1A(ssa.OpAddr, n.Type, zerobaseSym, s.sb)</span><br><span class="line">&#125;</span><br><span class="line">typ := s.expr(n.Left)</span><br><span class="line">vv := s.rtcall(newobject, <span class="literal">true</span>, []*types.Type&#123;n.Type&#125;, typ)</span><br><span class="line"><span class="keyword">return</span> vv[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，无论是直接使用 <code>new</code>，还是使用 <code>var</code> 初始化变量，它们在编译器看来就是 <code>ONEWOBJ</code> 和 <code>ODCL</code> 节点。这些节点在这一阶段都会被 <a href="https://github.com/golang/go/blob/316fd8cc4a7fab2e1bb45848bc30ea8b8a0b231a/src/cmd/compile/internal/gc/walk.go#L115-L1532" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkstmt</code></a> 转换成通过 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 函数在堆上申请内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkstmt</span><span class="params">(n *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> ODCL:</span><br><span class="line">v := n.Left</span><br><span class="line"><span class="keyword">if</span> v.Class() == PAUTOHEAP &#123;</span><br><span class="line"><span class="keyword">if</span> prealloc[v] == <span class="literal">nil</span> &#123;</span><br><span class="line">prealloc[v] = callnew(v.Type)</span><br><span class="line">&#125;</span><br><span class="line">nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])</span><br><span class="line">nn.SetColas(<span class="literal">true</span>)</span><br><span class="line">nn = typecheck(nn, ctxStmt)</span><br><span class="line"><span class="keyword">return</span> walkstmt(nn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ONEW:</span><br><span class="line"><span class="keyword">if</span> n.Esc == EscNone &#123;</span><br><span class="line">r := temp(n.Type.Elem())</span><br><span class="line">r = nod(OAS, r, <span class="literal">nil</span>)</span><br><span class="line">r = typecheck(r, ctxStmt)</span><br><span class="line">init.Append(r)</span><br><span class="line">r = nod(OADDR, r.Left, <span class="literal">nil</span>)</span><br><span class="line">r = typecheck(r, ctxExpr)</span><br><span class="line">n = r</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">n = callnew(n.Type.Elem())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这也不是绝对的，如果通过 <code>var</code> 或者 <code>new</code> 创建的变量不需要在当前作用域外生存，例如不用作为返回值返回给调用方，那么就不需要初始化在堆上。</p><p><a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 函数会是获取传入类型占用空间的大小，调用 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L889-L1132" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mallocgc</code></a> 在堆上申请一片内存空间并返回指向这片内存空间的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L889-L1132" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mallocgc</code></a> 函数的实现大概有 200 多行代码，我们会在后面的章节中详细分析 Go 语言的内存管理机制。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到了最后，简单总结一下 Go 语言中 <code>make</code> 和 <code>new</code> 关键字的实现原理，<code>make</code> 关键字的作用是创建切片、哈希表和 Channel 等内置的数据结构，而 <code>new</code> 的作用是为类型申请一片内存空间，并返回指向这片内存的指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — &lt;code&gt;make&lt;/code&gt; 和 &lt;code&gt;new&lt;/code&gt;。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑&lt;a href=&quot;https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;1&lt;/a&gt;，但是它们两者能够初始化的却有较大的不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt; 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel&lt;a href=&quot;https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:2&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;2&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针&lt;a href=&quot;https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:3&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;3&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="make" scheme="http://houmin.cc/tags/make/"/>
    
      <category term="new" scheme="http://houmin.cc/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Panic/Recover</title>
    <link href="http://houmin.cc/posts/ecc392db/"/>
    <id>http://houmin.cc/posts/ecc392db/</id>
    <published>2020-08-02T04:15:58.000Z</published>
    <updated>2020-08-19T12:13:20.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本节将分析两个经常成对出现的关键字 <code>panic</code> 和 <code>recover</code>。这两个关键字都与 <code>defer</code> 有千丝万缕的联系，也都是 Go 语言中的内置函数，但是提供的功能却是互补的：</p><ul><li><code>panic</code> 能够改变程序的控制流，函数调用<code>panic</code> 时会立刻停止执行函数的其他代码，并在执行结束后在当前 Goroutine 中递归执行调用方的延迟函数调用 <code>defer</code>；</li><li><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃。它是一个只能在 <code>defer</code> 中发挥作用的函数，在其他作用域中调用不会发挥任何作用；</li></ul><a id="more"></a><p><img alt="golang-panic" data-src="https://img.draveness.me/2020-01-19-15794253208982-golang-panic.png"></p><p>Andrew Gerrand 写过的一篇名为 <a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="external nofollow noopener noreferrer">Defer, Panic, and Recover</a> 的博客很好地介绍了这三个关键字的不同作用以及它们的关系<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>我们先通过几个例子了解一下使用 <code>panic</code> 和 <code>recover</code> 关键字时遇到的一些现象，部分现象也与上一节分析的 <code>defer</code> 关键字有关：</p><ul><li><code>panic</code> 只会触发当前 Goroutine 的延迟函数调用；</li><li><code>recover</code> 只有在 <code>defer</code> 函数中调用才会生效；</li><li><code>panic</code> 允许在 <code>defer</code> 中嵌套多次调用；</li></ul><h3 id="跨协程失效"><a href="#跨协程失效" class="headerlink" title="跨协程失效"></a>跨协程失效</h3><p>首先要展示的例子就是 <code>panic</code> 只会触发当前 Goroutine 的延迟函数调用。这里有一段简单的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">"in main"</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">"in goroutine"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">""</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">in goroutine</span><br><span class="line"><span class="built_in">panic</span>:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当我们运行这段代码时会发现 <code>main</code> 函数中的 <code>defer</code> 语句并没有执行，执行的只有当前 Goroutine 中的 <code>defer</code>。</p><p>上一节我们曾经介绍过 <code>defer</code> 关键字对应的 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 会将延迟调用函数与调用方所在 Goroutine 进行关联。所以当程序发生崩溃时只会调用当前 Goroutine 的延迟调用函数也是非常合理的。</p><p><img alt="golang-panic-and-defers" data-src="https://img.draveness.me/2020-01-19-15794253176199-golang-panic-and-defers.png"></p><p>如上图所示，多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 <code>panic</code> 时也不应该执行其他 Goroutine 的延迟函数。</p><h3 id="失效的崩溃恢复"><a href="#失效的崩溃恢复" class="headerlink" title="失效的崩溃恢复"></a>失效的崩溃恢复</h3><p>初学 Go 语言的读者可能会写出下面的代码，在主程序中调用 <code>recover</code> 试图中止程序的崩溃，但是从运行的结果中我们也能看出，如下所示的程序依然没有正常退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"in main"</span>)</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"unknown err"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">in main</span><br><span class="line"><span class="built_in">panic</span>: unknown err</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">...</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure><p>仔细分析一下这个过程就能理解这种现象背后的原因，<code>recover</code> 只有在发生 <code>panic</code> 之后调用才会生效。然而在上面的控制流中，<code>recover</code> 是在 <code>panic</code> 之前调用的，并不满足生效的条件，所以我们需要在 <code>defer</code> 中使用 <code>recover</code> 关键字。</p><h3 id="嵌套崩溃"><a href="#嵌套崩溃" class="headerlink" title="嵌套崩溃"></a>嵌套崩溃</h3><p>Go 语言中的 <code>panic</code> 是可以多次嵌套调用的。一些熟悉 Go 语言的读者很可能也不知道这个知识点，如下所示的代码就展示了如何在 <code>defer</code> 函数中多次调用 <code>panic</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"in main"</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic again and again"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic again"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic once"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">in main</span><br><span class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span> once</span><br><span class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span> again</span><br><span class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span> again and again</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">...</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure><p>从上述程序的输出，我们可以确定程序多次调用 <code>panic</code> 也不会影响 <code>defer</code> 函数的正常执行。所以使用 <code>defer</code> 进行收尾的工作一般来说都是安全的。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>panic</code> 关键字在 Go 语言的源代码是由数据结构 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 表示的。每当我们调用 <code>panic</code> 都会创建一个如下所示的数据结构存储相关信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">argp      unsafe.Pointer</span><br><span class="line">arg       <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">link      *_panic</span><br><span class="line">recovered <span class="keyword">bool</span></span><br><span class="line">aborted   <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">pc        <span class="keyword">uintptr</span></span><br><span class="line">sp        unsafe.Pointer</span><br><span class="line">goexit    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>argp</code> 是指向 <code>defer</code> 调用时参数的指针；</li><li><code>arg</code> 是调用 <code>panic</code> 时传入的参数；</li><li><code>link</code> 指向了更早调用的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 结构；</li><li><code>recovered</code> 表示当前 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 是否被 <code>recover</code> 恢复；</li><li><code>aborted</code> 表示当前的 <code>panic</code> 是否被强行终止；</li></ol><p>从数据结构中的 <code>link</code> 字段我们就可以推测出以下的结论 — <code>panic</code> 函数可以被连续多次调用，它们之间通过 <code>link</code> 的关联形成一个链表。</p><p>结构体中的 <code>pc</code>、<code>sp</code> 和 <code>goexit</code> 三个字段都是为了修复 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L581-L656" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.Goexit</code></a> 的问题引入的<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>。该函数能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 <code>defer</code> 中的 <code>panic</code> 和 <code>recover</code> 取消<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>，引入这三个字段的目的就是为了解决这个问题。</p><h2 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h2><p>首先了解一下 <code>panic</code> 函数是如何终止程序的。编译器会将关键字 <code>panic</code> 转换成 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L887-L1062" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopanic</code></a>，该函数的执行过程包含以下几个步骤：</p><ol><li>创建新的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 结构并添加到所在 Goroutine <code>_panic</code> 链表的最前面；</li><li>在循环中不断从当前 Goroutine 的 <code>_defer</code> 中链表获取 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 并调用 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L496-L526" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.reflectcall</code></a> 运行延迟调用函数；</li><li>调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1185-L1220" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.fatalpanic</code></a> 中止整个程序；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopanic</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> p _panic</span><br><span class="line">p.arg = e</span><br><span class="line">p.link = gp._panic</span><br><span class="line">gp._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">d := gp._defer</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line"></span><br><span class="line">reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line"></span><br><span class="line">d._panic = <span class="literal">nil</span></span><br><span class="line">d.fn = <span class="literal">nil</span></span><br><span class="line">gp._defer = d.link</span><br><span class="line"></span><br><span class="line">freedefer(d)</span><br><span class="line"><span class="keyword">if</span> p.recovered &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fatalpanic(gp._panic)</span><br><span class="line">*(*<span class="keyword">int</span>)(<span class="literal">nil</span>) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，我们在上述函数中省略了三部分比较重要的代码：</p><ol><li><p>恢复程序的 <code>recover</code> 分支中的代码；</p></li><li><p>通过内联优化</p></li></ol>   <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">defer</span></span><br></pre></td></tr></table></figure><p>   调用性能的代码</p><p>   <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/#fn:4" target="_blank" rel="external nofollow noopener noreferrer">4</a></p><p>   ；</p><ul><li><a href="https://github.com/golang/go/commit/be64a19d99918c843f8555aad580221207ea35bc" target="_blank" rel="external nofollow noopener noreferrer">runtime: make defers low-cost through inline code and extra funcdata</a></li></ul><ol><li>修复</li></ol><p>   <code>runtime.Goexit</code></p><p>   异常情况的代码；</p><ul><li><a href="https://github.com/golang/go/commit/7dcd343ed641d3b70c09153d3b041ca3fe83b25e" target="_blank" rel="external nofollow noopener noreferrer">runtime: ensure that Goexit cannot be aborted by a recursive panic/recover</a></li></ul><p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1185-L1220" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.fatalpanic</code></a> 实现了无法被恢复的程序崩溃，它在中止程序之前会通过 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L679-L695" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.printpanics</code></a> 打印出全部的 <code>panic</code> 消息以及调用时传入的参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fatalpanic</span><span class="params">(msgs *_panic)</span></span> &#123;</span><br><span class="line">pc := getcallerpc()</span><br><span class="line">sp := getcallersp()</span><br><span class="line">gp := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> startpanic_m() &amp;&amp; msgs != <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.Xadd(&amp;runningPanicDefers, <span class="number">-1</span>)</span><br><span class="line">printpanics(msgs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dopanic_m(gp, pc, sp) &#123;</span><br><span class="line">crash()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 <code>panic</code> 消息之后会通过 <a href="https://github.com/golang/go/blob/cbaa666682386fe5350bf87d7d70171704c90fe4/src/runtime/sys_darwin.go#L231-L233" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.exit</code></a> 退出当前程序并返回错误码 2，而程序的正常退出也是通过 <a href="https://github.com/golang/go/blob/cbaa666682386fe5350bf87d7d70171704c90fe4/src/runtime/sys_darwin.go#L231-L233" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.exit</code></a> 函数实现的。</p><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>到这里我们已经掌握了 <code>panic</code> 退出程序的过程，接下来将分析 <code>defer</code> 中的 <code>recover</code> 是如何中止程序崩溃的。编译器会将关键字 <code>recover</code> 转换成 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1080-L1094" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gorecover</code></a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gorecover</span><span class="params">(argp <span class="keyword">uintptr</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">p := gp._panic</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.recovered &amp;&amp; argp == <span class="keyword">uintptr</span>(p.argp) &#123;</span><br><span class="line">p.recovered = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> p.arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的实现非常简单，如果当前 Goroutine 没有调用 <code>panic</code>，那么该函数会直接返回 <code>nil</code>，这也是崩溃恢复在非 <code>defer</code> 中调用会失效的原因。</p><p>在正常情况下，它会修改 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 结构体的 <code>recovered</code> 字段，<a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1080-L1094" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gorecover</code></a> 函数本身不包含恢复程序的逻辑，程序的恢复也是由 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L887-L1062" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopanic</code></a> 函数负责的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopanic</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 执行延迟调用函数，可能会设置 p.recovered = true</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pc := d.pc</span><br><span class="line">sp := unsafe.Pointer(d.sp)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> p.recovered &#123;</span><br><span class="line">gp._panic = p.link</span><br><span class="line"><span class="keyword">for</span> gp._panic != <span class="literal">nil</span> &amp;&amp; gp._panic.aborted &#123;</span><br><span class="line">gp._panic = gp._panic.link</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp._panic == <span class="literal">nil</span> &#123;</span><br><span class="line">gp.sig = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">gp.sigcode0 = <span class="keyword">uintptr</span>(sp)</span><br><span class="line">gp.sigcode1 = pc</span><br><span class="line">mcall(recovery)</span><br><span class="line">throw(<span class="string">"recovery failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这段代码也省略了 <code>defer</code> 的内联优化，它从 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体中取出了程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1132-L1151" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recovery</code></a> 函数触发 Goroutine 的调度，调度之前会准备好 <code>sp</code>、<code>pc</code> 以及函数的返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recovery</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">sp := gp.sigcode0</span><br><span class="line">pc := gp.sigcode1</span><br><span class="line"></span><br><span class="line">gp.sched.sp = sp</span><br><span class="line">gp.sched.pc = pc</span><br><span class="line">gp.sched.lr = <span class="number">0</span></span><br><span class="line">gp.sched.ret = <span class="number">1</span></span><br><span class="line">gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在调用 <code>defer</code> 关键字时，调用时的栈指针 <code>sp</code> 和程序计数器 <code>pc</code> 就已经存储到了 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体中，这里的 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/asm_386.s#L301-L314" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gogo</code></a> 函数会跳回 <code>defer</code> 关键字调用的位置。</p><p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1132-L1151" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recovery</code></a> 在调度过程中会将函数的返回值设置成 1。从 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 的注释中我们会发现，当 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数的返回值是 1 时，编译器生成的代码会直接跳转到调用方函数返回之前并执行 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// deferproc returns 0 normally.</span></span><br><span class="line"><span class="comment">// a deferred func that stops a panic</span></span><br><span class="line"><span class="comment">// makes the deferproc return 1.</span></span><br><span class="line"><span class="comment">// the code the compiler generates always</span></span><br><span class="line"><span class="comment">// checks the return value and jumps to the</span></span><br><span class="line"><span class="comment">// end of the function if deferproc returns != 0.</span></span><br><span class="line">return0()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转到 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 函数之后，程序就已经从 <code>panic</code> 中恢复了并执行正常的逻辑，而 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1080-L1094" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gorecover</code></a> 函数也能从 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 结构体中取出了调用 <code>panic</code> 时传入的 <code>arg</code> 参数并返回给调用方。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析程序的崩溃和恢复过程比较棘手，代码不是特别容易理解。我们在本节的最后还是简单总结一下程序崩溃和恢复的过程：</p><ol><li><p>编译器会负责做转换关键字的工作；</p><ol><li>将 <code>panic</code> 和 <code>recover</code> 分别转换成 <code>runtime.gopanic</code> 和 <code>runtime.gorecover</code>；</li><li>将 <code>defer</code> 转换成 <code>deferproc</code> 函数；</li><li>在调用 <code>defer</code> 的函数末尾调用 <code>deferreturn</code> 函数；</li></ol></li><li><p>在运行过程中遇到 <code>gopanic</code> 方法时，会从 Goroutine 的链表依次取出 <code>_defer</code> 结构体并执行；</p></li><li><p>如果调用延迟执行函数时遇到了</p></li></ol>   <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gorecover</span></span><br></pre></td></tr></table></figure><p>   就会将</p>   <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">_panic</span>.</span></span>recovered</span><br></pre></td></tr></table></figure><p>   标记成</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>   并返回</p>   <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">panic</span></span><br></pre></td></tr></table></figure><p>   的参数；</p><ol><li>在这次调用结束之后，<code>gopanic</code> 会从 <code>_defer</code> 结构体中取出程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并调用 <code>recovery</code> 函数进行恢复程序；</li><li><code>recovery</code> 会根据传入的 <code>pc</code> 和 <code>sp</code> 跳转回 <code>deferproc</code>；</li><li>编译器自动生成的代码会发现 <code>deferproc</code> 的返回值不为 0，这时会跳回 <code>deferreturn</code> 并恢复到正常的执行流程；</li></ol><ol><li>如果没有遇到 <code>gorecover</code> 就会依次遍历所有的 <code>_defer</code> 结构，并在最后调用 <code>fatalpanic</code> 中止程序、打印 <code>panic</code> 的参数并返回错误码 <code>2</code>；</li></ol><p>分析的过程涉及了很多语言底层的知识，源代码阅读起来也比较晦涩，其中充斥着反常规的控制流程，通过程序计数器来回跳转，不过对于我们理解程序的执行流程还是很有帮助。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="http://hustcat.github.io/dive-into-stack-defer-panic-recover-in-go/" target="_blank" rel="external nofollow noopener noreferrer">Dive into stack and defer/panic/recover in go</a></li><li><a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="external nofollow noopener noreferrer">Defer, Panic, and Recover</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节将分析两个经常成对出现的关键字 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt;。这两个关键字都与 &lt;code&gt;defer&lt;/code&gt; 有千丝万缕的联系，也都是 Go 语言中的内置函数，但是提供的功能却是互补的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;panic&lt;/code&gt; 能够改变程序的控制流，函数调用&lt;code&gt;panic&lt;/code&gt; 时会立刻停止执行函数的其他代码，并在执行结束后在当前 Goroutine 中递归执行调用方的延迟函数调用 &lt;code&gt;defer&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recover&lt;/code&gt; 可以中止 &lt;code&gt;panic&lt;/code&gt; 造成的程序崩溃。它是一个只能在 &lt;code&gt;defer&lt;/code&gt; 中发挥作用的函数，在其他作用域中调用不会发挥任何作用；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://img.draveness.me/2020-01-19-15794253208982-golang-panic.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="panic" scheme="http://houmin.cc/tags/panic/"/>
    
      <category term="recover" scheme="http://houmin.cc/tags/recover/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Defer</title>
    <link href="http://houmin.cc/posts/540e2781/"/>
    <id>http://houmin.cc/posts/540e2781/</id>
    <published>2020-08-01T04:15:45.000Z</published>
    <updated>2020-08-21T08:11:30.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很多现代的编程语言中都有 <code>defer</code> 关键字，Go 语言的 <code>defer</code> 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。在这一节中我们就会深入 Go 语言的源代码介绍 <code>defer</code> 关键字的实现原理，相信读者读完这一节会对 <code>defer</code> 的数据结构、实现以及调用过程有着更清晰的理解。</p><a id="more"></a><p>作为一个编程语言中的关键字，<code>defer</code> 的实现一定是由编译器和运行时共同完成的，不过在深入源码分析它的实现之前我们还是需要了解 <code>defer</code> 关键字的常见使用场景以及使用时的注意事项。</p><p>使用 <code>defer</code> 的最常见场景就是在函数调用结束后完成一些收尾工作，例如在 <code>defer</code> 中回滚数据库的事务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPost</span><span class="params">(db *gorm.DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    tx := db.Begin()</span><br><span class="line">    <span class="keyword">defer</span> tx.Rollback()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := tx.Create(&amp;Post&#123;Author: <span class="string">"Draveness"</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tx.Commit().Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用数据库事务时，我们可以使用如上所示的代码在创建事务之后就立刻调用 <code>Rollback</code> 保证事务一定会回滚。哪怕事务真的执行成功了，那么调用 <code>tx.Commit()</code> 之后再执行 <code>tx.Rollback()</code> 也不会影响已经提交的事务。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>我们在 Go 语言中使用 <code>defer</code> 时会遇到两个比较常见的问题，这里会介绍具体的场景并分析这两个现象背后的设计原理：</p><ul><li><code>defer</code> 关键字的调用时机以及多次调用 <code>defer</code> 时执行顺序是如何确定的；</li><li><code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果；</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>向 <code>defer</code> 关键字传入的函数会在函数返回之前运行。假设我们在 <code>for</code> 循环中多次调用 <code>defer</code> 关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>运行上述代码会倒序执行所有向 <code>defer</code> 关键字中传入的表达式，最后一次 <code>defer</code> 调用传入了 <code>fmt.Println(4)</code>，所以会这段代码会优先打印 4。我们可以通过下面这个简单例子强化对 <code>defer</code> 执行时机的理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">"defer runs"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"block ends"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"main ends"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">block ends</span><br><span class="line">main ends</span><br><span class="line"><span class="keyword">defer</span> runs</span><br></pre></td></tr></table></figure><p>从上述代码的输出我们会发现，<code>defer</code> 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。</p><h3 id="预计算参数"><a href="#预计算参数" class="headerlink" title="预计算参数"></a>预计算参数</h3><p>Go 语言中所有的函数调用都是传值的，<code>defer</code> 虽然是关键字，但是也继承了这个特性。假设我们想要计算 <code>main</code> 函数运行的时间，可能会写出以下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">startedAt := time.Now()</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(time.Since(startedAt))</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span>s</span><br></pre></td></tr></table></figure><p>然而上述代码的运行结果并不符合我们的预期，这个现象背后的原因是什么呢？经过分析，我们会发现调用 <code>defer</code> 关键字会立刻对函数中引用的外部参数进行拷贝，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出 0s。</p><p>想要解决这个问题的方法非常简单，我们只需要向 <code>defer</code> 关键字传入匿名函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">startedAt := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(time.Since(startedAt)) &#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">1</span>s</span><br></pre></td></tr></table></figure><p>虽然调用 <code>defer</code> 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 <code>time.Since(startedAt)</code> 会在 <code>main</code> 函数返回前被调用并打印出符合预期的结果。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在介绍 <code>defer</code> 函数的执行过程与实现原理之前，我们首先来了解一下 <code>defer</code> 关键字在 Go 语言源代码中对应的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">siz     <span class="keyword">int32</span></span><br><span class="line">started <span class="keyword">bool</span></span><br><span class="line">sp      <span class="keyword">uintptr</span></span><br><span class="line">pc      <span class="keyword">uintptr</span></span><br><span class="line">fn      *funcval</span><br><span class="line">_panic  *_panic</span><br><span class="line">link    *_defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体是延迟调用链表上的一个元素，所有的结构体都会通过 <code>link</code> 字段串联成链表。</p><p><img alt="golang-defer-link" data-src="https://img.draveness.me/2020-01-19-15794017184603-golang-defer-link.png"></p><p><strong>图 5-10 延迟调用链表</strong></p><p>我们简单介绍一下 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体中的几个字段：</p><ul><li><code>siz</code> 是参数和结果的内存大小；</li><li><code>sp</code> 和 <code>pc</code> 分别代表栈指针和调用方的程序计数器；</li><li><code>fn</code> 是 <code>defer</code> 关键字中传入的函数；</li><li><code>_panic</code> 是触发延迟调用的结构体，可能为空；</li></ul><p>除了上述的这些字段之外，<a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 中还包含一些垃圾回收机制使用的字段，这里为了减少理解的成本就都省去了。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>中间代码生成阶段执行的被 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023-L1502" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.stmt</code></a> 函数会处理 <code>defer</code> 关键字。从下面截取的这段代码中，我们会发现编译器调用了 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L4324-L4517" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.call</code></a> 函数，这表示 <code>defer</code> 在编译器看来也是函数调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">stmt</span><span class="params">(n *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> ODEFER:</span><br><span class="line">s.call(n.Left, callDefer)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L4324-L4517" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.call</code></a> 函数会负责了为所有函数和方法调用生成中间代码，它的工作包括以下内容：</p><ol><li>获取需要执行的函数名、闭包指针、代码指针和函数调用的接收方；</li><li>获取栈地址并将函数或者方法的参数写入栈中；</li><li>使用 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L764-L766" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.newValue1A</code></a> 以及相关函数生成函数调用的中间代码；</li><li>如果当前调用的函数是 <code>defer</code>，那么就会单独生成相关的结束代码块；</li><li>获取函数的返回值地址并结束当前调用；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">call</span><span class="params">(n *Node, k callKind)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> call *ssa.Value</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> k == callDefer:</span><br><span class="line">call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, deferproc, s.mem())</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">call.AuxInt = stksize</span><br><span class="line">s.vars[&amp;memVar] = call</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中我们能看到，<code>defer</code> 关键字在运行期间会调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数，这个函数接收了参数的大小和闭包所在的地址两个参数。</p><p>编译器不仅将 <code>defer</code> 关键字都转换成 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数，它还会通过以下三个步骤为所有调用 <code>defer</code> 的函数末尾插入 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 的函数调用：</p><ol><li><a href="https://github.com/golang/go/blob/316fd8cc4a7fab2e1bb45848bc30ea8b8a0b231a/src/cmd/compile/internal/gc/walk.go#L115-L351" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkstmt</code></a> 在遇到 <code>ODEFER</code> 节点时会执行 <code>Curfn.Func.SetHasDefer(true)</code> 设置当前函数的 <code>hasdefer</code>；</li><li><a href="https://github.com/golang/go/blob/98d2717499575afe13d9f815d46fcd6e384efb0c/src/cmd/compile/internal/gc/ssa.go#L281-L451" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.buildssa</code></a> 会执行 <code>s.hasdefer = fn.Func.HasDefer()</code> 更新 <code>state</code> 的 <code>hasdefer</code>；</li><li><a href="https://github.com/golang/go/blob/98d2717499575afe13d9f815d46fcd6e384efb0c/src/cmd/compile/internal/gc/ssa.go#L1511-L1552" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.exit</code></a> 会根据 <code>state</code> 的 <code>hasdefer</code> 在函数返回之前插入 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 的函数调用；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">exit</span><span class="params">()</span> *<span class="title">ssa</span>.<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.hasdefer &#123;</span><br><span class="line">s.rtcall(Deferreturn, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言的编译器不仅将 <code>defer</code> 转换成了 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 的函数调用，还在所有调用 <code>defer</code> 的函数结尾插入了 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>，接下来我们就需要了解这两个运行时方法的实现原理了。</p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><code>defer</code> 关键字的运行时实现分成两个部分：</p><ul><li><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数负责创建新的延迟调用；</li><li><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 函数负责在函数调用结束时执行所有的延迟调用；</li></ul><p>这两个函数是 <code>defer</code> 关键字运行时机制的入口，我们从它们开始分别介绍这两个函数的执行过程。</p><h3 id="创建延迟调用"><a href="#创建延迟调用" class="headerlink" title="创建延迟调用"></a>创建延迟调用</h3><p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 会为 <code>defer</code> 创建一个新的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体、设置它的函数指针 <code>fn</code>、程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并将相关的参数拷贝到相邻的内存空间中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">sp := getcallersp()</span><br><span class="line">argp := <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line"></span><br><span class="line">d := newdefer(siz)</span><br><span class="line"><span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"deferproc: d.panic != nil after newdefer"</span>)</span><br><span class="line">&#125;</span><br><span class="line">d.fn = fn</span><br><span class="line">d.pc = callerpc</span><br><span class="line">d.sp = sp</span><br><span class="line"><span class="keyword">switch</span> siz &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(deferArgs(d)) = *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(argp))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">memmove(deferArgs(d), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(siz))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return0()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用的 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1320-L1322" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.return0</code></a> 函数的作用是避免无限递归调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>，它是唯一一个不会触发由延迟调用的函数了。</p><p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 中 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L383-L430" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newdefer</code></a> 的作用就是想尽办法获得一个 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体，办法总共有三个：</p><ol><li>从调度器的延迟调用缓存池 <code>sched.deferpool</code> 中取出结构体并将该结构体追加到当前 Goroutine 的缓存池中；</li><li>从 Goroutine 的延迟调用缓存池 <code>pp.deferpool</code> 中取出结构体；</li><li>通过 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L889-L1132" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mallocgc</code></a> 创建一个新的结构体；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newdefer</span><span class="params">(siz <span class="keyword">int32</span>)</span> *_<span class="title">defer</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d *_defer</span><br><span class="line">sc := deferclass(<span class="keyword">uintptr</span>(siz))</span><br><span class="line">gp := getg()</span><br><span class="line"><span class="keyword">if</span> sc &lt; <span class="keyword">uintptr</span>(<span class="built_in">len</span>(p&#123;&#125;.deferpool)) &#123;</span><br><span class="line">pp := gp.m.p.ptr()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pp.deferpool[sc]) == <span class="number">0</span> &amp;&amp; sched.deferpool[sc] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(pp.deferpool[sc]) &lt; <span class="built_in">cap</span>(pp.deferpool[sc])/<span class="number">2</span> &amp;&amp; sched.deferpool[sc] != <span class="literal">nil</span> &#123;</span><br><span class="line">d := sched.deferpool[sc]</span><br><span class="line">sched.deferpool[sc] = d.link</span><br><span class="line">pp.deferpool[sc] = <span class="built_in">append</span>(pp.deferpool[sc], d)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n := <span class="built_in">len</span>(pp.deferpool[sc]); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">d = pp.deferpool[sc][n<span class="number">-1</span>]</span><br><span class="line">pp.deferpool[sc][n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">pp.deferpool[sc] = pp.deferpool[sc][:n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">total := roundupsize(totaldefersize(<span class="keyword">uintptr</span>(siz)))</span><br><span class="line">d = (*_defer)(mallocgc(total, deferType, <span class="literal">true</span>))</span><br><span class="line">&#125;</span><br><span class="line">d.siz = siz</span><br><span class="line">d.link = gp._defer</span><br><span class="line">gp._defer = d</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论使用哪种方式获取 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a>，它都会被追加到所在的 Goroutine <code>_defer</code> 链表的最前面。</p><p><img alt="golang-new-defe" data-src="https://img.draveness.me/2020-01-19-15794017184614-golang-new-defer.png"></p><p><strong>图 5-11 追加新的延迟调用</strong></p><p><code>defer</code> 关键字插入时是从后向前的，而 <code>defer</code> 关键字执行是从前向后的，而这就是后调用的 <code>defer</code> 会优先执行的原因。</p><h3 id="执行延迟调用"><a href="#执行延迟调用" class="headerlink" title="执行延迟调用"></a>执行延迟调用</h3><p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 会从 Goroutine 的 <code>_defer</code> 链表中取出最前面的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体并调用 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L614-L624" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.jmpdefer</code></a> 函数传入需要执行的函数和参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">d := gp._defer</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sp := getcallersp()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> d.siz &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="keyword">uintptr</span>)(deferArgs(d))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="keyword">uintptr</span>(d.siz))</span><br><span class="line">&#125;</span><br><span class="line">fn := d.fn</span><br><span class="line">gp._defer = d.link</span><br><span class="line">freedefer(d)</span><br><span class="line">jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L614-L624" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.jmpdefer</code></a> 是一个用汇编语言实现的运行时函数，它的工作就是跳转 <code>defer</code> 所在的代码段并在执行结束之后跳转回 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·jmpdefer(SB), NOSPLIT, $<span class="number">0</span><span class="number">-8</span></span><br><span class="line">MOVLfv+<span class="number">0</span>(FP), DX<span class="comment">// fn</span></span><br><span class="line">MOVLargp+<span class="number">4</span>(FP), BX<span class="comment">// caller sp</span></span><br><span class="line">LEAL<span class="number">-4</span>(BX), SP<span class="comment">// caller sp after CALL</span></span><br><span class="line">#ifdef GOBUILDMODE_shared</span><br><span class="line">SUBL$<span class="number">16</span>, (SP)<span class="comment">// return to CALL again</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">SUBL$<span class="number">5</span>, (SP)<span class="comment">// return to CALL again</span></span><br><span class="line">#endif</span><br><span class="line">MOVL<span class="number">0</span>(DX), BX</span><br><span class="line">JMPBX<span class="comment">// but first run the deferred function</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 函数会多次判断当前 Goroutine 的 <code>_defer</code> 链表中是否有未执行的剩余结构，在所有的延迟函数调用都执行完成之后，该函数才会返回。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>defer</code> 关键字的实现主要依靠编译器和运行时的协作，我们总结一下本节提到的内容：</p><ul><li>编译期；<ul><li>将 <code>defer</code> 关键字被转换 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a>；</li><li>在调用 <code>defer</code> 关键字的函数返回之前插入 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>；</li></ul></li><li>运行时：<ul><li><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 会将一个新的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体追加到当前 Goroutine 的链表头；</li><li><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 会从 Goroutine 的链表中取出 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构并依次执行；</li></ul></li></ul><p>我们在本节前面提到的两个现象在这里也可以解释清楚了：</p><ul><li>后调用的</li></ul>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">defer</span></span><br></pre></td></tr></table></figure><p>  函数会先执行：</p><ul><li>后调用的 <code>defer</code> 函数会被追加到 Goroutine <code>_defer</code> 链表的最前面；</li><li>运行 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 时是从前到后依次执行；</li></ul><ul><li><p>函数的参数会被预先计算；</p><ul><li>调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；</li></ul></li></ul><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://blog.learngoprogramming.com/gotchas-of-defer-in-go-1-8d070894cb01" target="_blank" rel="external nofollow noopener noreferrer">5 Gotchas of Defer in Go — Part I</a></li><li><a href="https://stackoverflow.com/questions/28893586/golang-defer-clarification" target="_blank" rel="external nofollow noopener noreferrer">Golang defer clarification</a></li><li><a href="http://hustcat.github.io/dive-into-stack-defer-panic-recover-in-go/" target="_blank" rel="external nofollow noopener noreferrer">Dive into stack and defer/panic/recover in go</a></li><li><a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="external nofollow noopener noreferrer">Defer, Panic, and Recover</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多现代的编程语言中都有 &lt;code&gt;defer&lt;/code&gt; 关键字，Go 语言的 &lt;code&gt;defer&lt;/code&gt; 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。在这一节中我们就会深入 Go 语言的源代码介绍 &lt;code&gt;defer&lt;/code&gt; 关键字的实现原理，相信读者读完这一节会对 &lt;code&gt;defer&lt;/code&gt; 的数据结构、实现以及调用过程有着更清晰的理解。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="defer" scheme="http://houmin.cc/tags/defer/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Select</title>
    <link href="http://houmin.cc/posts/3d36166e/"/>
    <id>http://houmin.cc/posts/3d36166e/</id>
    <published>2020-07-31T04:15:34.000Z</published>
    <updated>2020-08-19T12:13:20.947Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很多 C 语言或者 Unix 开发者听到 <code>select</code> 想到的都是系统调用，而谈到 I/O 模型时最终大都会提到基于 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 等函数构建的 IO 多路复用模型。Go 语言的 <code>select</code> 与 C 语言中的 <code>select</code> 有着比较相似的功能。本节会介绍 Go 语言 <code>select</code> 常见的现象、数据结构以及四种不同情况下的实现原理。</p><a id="more"></a><p>C 语言中的 <code>select</code> 关键字可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 <code>select</code> 关键字也能够让 Goroutine 同时等待多个 Channel 的可读或者可写，在多个文件或者 Channel 发生状态改变之前，<code>select</code> 会一直阻塞当前线程或者 Goroutine。</p><p><img alt="Golang-Select-Channels" data-src="https://img.draveness.me/2020-01-19-15794018429532-Golang-Select-Channels.png"></p><p><code>select</code> 是一种与 <code>switch</code> 相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式必须都是 Channel 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 <code>select</code> 结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述控制结构会等待 <code>c &lt;- x</code> 或者 <code>&lt;-quit</code> 两个表达式中任意一个的返回。无论哪一个表达式返回都会立刻执行 <code>case</code> 中的代码，当 <code>select</code> 中的两个 <code>case</code> 同时被触发时，就会随机选择一个 <code>case</code> 执行。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>当我们在 Go 语言中使用 <code>select</code> 控制结构时，会遇到两个有趣的现象：</p><ol><li><code>select</code> 能在 Channel 上进行非阻塞的收发操作；</li><li><code>select</code> 在遇到多个 Channel 同时响应时会随机挑选 <code>case</code> 执行；</li></ol><p>这两个现象是学习 <code>select</code> 时经常会遇到的，我们来深入了解具体的场景并分析这两个现象背后的设计原理。</p><h3 id="非阻塞的收发"><a href="#非阻塞的收发" class="headerlink" title="非阻塞的收发"></a>非阻塞的收发</h3><p>在通常情况下，<code>select</code> 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 <code>select</code> 控制结构中包含 <code>default</code> 语句，那么这个 <code>select</code> 语句在执行时会遇到以下两种情况：</p><ol><li>当存在可以收发的 Channel 时，直接处理该 Channel 对应的 <code>case</code>；</li><li>当不存在可以收发的 Channel 是，执行 <code>default</code> 中的语句；</li></ol><p>当我们运行下面的代码时就不会阻塞当前的 Goroutine，它会直接执行 <code>default</code> 中的代码并返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">default</span></span><br></pre></td></tr></table></figure><p>只要我们稍微想一下，就会发现 Go 语言设计的这个现象就非常合理。<code>select</code> 的作用就是同时监听多个 <code>case</code> 是否可以执行，如果多个 Channel 都不能执行，那么运行 <code>default</code> 中的代码也是理所当然的。</p><p>非阻塞的 Channel 发送和接收操作还是很有必要的，在很多场景下我们不希望向 Channel 发送消息或者从 Channel 中接收消息会阻塞当前 Goroutine，我们只是想看看 Channel 的可读或者可写状态。下面就是一个常见的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="built_in">len</span>(tasks))</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(tasks))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := tasks[i].Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errCh &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err := &lt;-errCh:</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，我们不关心到底多少个任务执行失败了，只关心是否存在返回错误的任务，最后的 <code>select</code> 语句就能很好地完成这个任务。然而使用 <code>select</code> 的语法不是最原始的设计，它在最初版本使用 <code>x, ok := &lt;-c</code> 的语法实现非阻塞的收发，以下是与非阻塞收发的相关提交：</p><ol><li><a href="https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff" target="_blank" rel="external nofollow noopener noreferrer">select default</a> 提交支持了 <code>select</code> 语句中的 <code>default</code> 情况<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>；</li><li><a href="https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16" target="_blank" rel="external nofollow noopener noreferrer">gc: special case code for single-op blocking and non-blocking selects</a> 提交引入了基于 <code>select</code> 的非阻塞收发的特性<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>。</li><li><a href="https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059" target="_blank" rel="external nofollow noopener noreferrer">gc: remove non-blocking send, receive syntax</a> 提交将 <code>x, ok := &lt;-c</code> 语法删除删除<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>；</li><li><a href="https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c" target="_blank" rel="external nofollow noopener noreferrer">gc, runtime: replace closed(c) with x, ok := &lt;-c</a> 提交使用 <code>x, ok := &lt;-c</code> 语法替代 <code>closed(c)</code> 语法判断 Channel 的关闭状态<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:4" target="_blank" rel="external nofollow noopener noreferrer">4</a>；</li></ol><p>我们可以从上面的几个提交中看到非阻塞收发从最初到现在的演变。</p><h3 id="随机执行"><a href="#随机执行" class="headerlink" title="随机执行"></a>随机执行</h3><p>另一个使用 <code>select</code> 遇到的情况是同时有多个 <code>case</code> 就绪时，<code>select</code> 会选择那个 <code>case</code> 执行的问题，我们通过下面的代码可以简单了解一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">1</span> * time.Second) &#123;</span><br><span class="line">ch &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"case1"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"case2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">case1</span><br><span class="line">case2</span><br><span class="line">case1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上述代码输出的结果中我们可以看到，<code>select</code> 在遇到多个 <code>&lt;-ch</code> 同时满足可读或者可写条件时会随机选择一个 <code>case</code> 执行其中的代码。</p><p>这个设计是在十多年前被 <a href="https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d" target="_blank" rel="external nofollow noopener noreferrer">select</a> 提交<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:5" target="_blank" rel="external nofollow noopener noreferrer">5</a>引入并一直保留到现在的，虽然中间经历过一些修改<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:6" target="_blank" rel="external nofollow noopener noreferrer">6</a>，但是语义一直都没有改变。在上面的代码中，两个 <code>case</code> 都是同时满足执行条件的，如果我们按照顺序依次判断，那么后面的条件永远都会得不到执行，而随机的引入就是为了避免饥饿问题的发生。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>select</code> 在 Go 语言的源代码中不存在对应的结构体，但是 <code>select</code> 控制结构中的 <code>case</code> 却使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 结构体来表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">c           *hchan</span><br><span class="line">elem        unsafe.Pointer</span><br><span class="line">kind        <span class="keyword">uint16</span></span><br><span class="line">pc          <span class="keyword">uintptr</span></span><br><span class="line">releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为非默认的 <code>case</code> 中都与 Channel 的发送和接收有关，所以 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 结构体中也包含一个 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L32-L51" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 类型的字段存储 <code>case</code> 中使用的 Channel；除此之外，<code>elem</code> 是接收或者发送数据的变量地址、<code>kind</code> 表示 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 的种类，总共包含以下四种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">caseNil = <span class="literal">iota</span></span><br><span class="line">caseRecv</span><br><span class="line">caseSend</span><br><span class="line">caseDefault</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这四种常量分别表示不同类型的 <code>case</code>，相信它们的命名已经能够充分帮助我们理解它们的作用了，所以这里也不一一介绍了。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>select</code> 语句在编译期间会被转换成 <code>OSELECT</code> 节点。每一个 <code>OSELECT</code> 节点都会持有一组 <code>OCASE</code> 节点，如果 <code>OCASE</code> 的执行条件是空，那就意味着这是一个 <code>default</code> 节点:</p><p><img alt="golang-oselect-and-ocases" data-src="https://img.draveness.me/2020-01-18-15793463657473-golang-oselect-and-ocases.png"></p><p>上图展示的就是 <code>select</code> 语句在编译期间的结构，每一个 <code>OCASE</code> 既包含执行条件也包含满足条件后执行的代码。</p><p>编译器在中间代码生成期间会根据 <code>select</code> 中 <code>case</code> 的不同对控制语句进行优化，这一过程都发生在 <a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数中，我们在这里会分四种情况介绍处理的过程和结果：</p><ol><li><code>select</code> 不存在任何的 <code>case</code>；</li><li><code>select</code> 只存在一个 <code>case</code>；</li><li><code>select</code> 存在两个 <code>case</code>，其中一个 <code>case</code> 是 <code>default</code>；</li><li><code>select</code> 存在多个 <code>case</code>；</li></ol><p>上述的四种情况不仅会涉及编译器的重写和优化，还会涉及 Go 语言的运行时机制，我们会从编译期间和运行时两方面分析上述情况。</p><h3 id="直接阻塞"><a href="#直接阻塞" class="headerlink" title="直接阻塞"></a>直接阻塞</h3><p>首先介绍的是最简单的情况，也就是当 <code>select</code> 结构中不包含任何 <code>case</code> 时编译器是如何进行处理的，我们截取 <a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数的前几行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkselectcases</span><span class="params">(cases *Nodes)</span> []*<span class="title">Node</span></span> &#123;</span><br><span class="line">n := cases.Len()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []*Node&#123;mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常简单并且容易理解，它直接将类似 <code>select {}</code> 的空语句转换成调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.block</code></a> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block</span><span class="params">()</span></span> &#123;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonSelectNoCases, traceEvGoStop, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.block</code></a> 函数的实现非常简单，它会调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopark</code></a> 让出当前 Goroutine 对处理器的使用权，传入的等待原因是 <code>waitReasonSelectNoCases</code>。</p><p>简单总结一下，空的 <code>select</code> 语句会直接阻塞当前的 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p><h3 id="单一管道"><a href="#单一管道" class="headerlink" title="单一管道"></a>单一管道</h3><p>如果当前的 <code>select</code> 条件只包含一个 <code>case</code>，那么就会将 <code>select</code> 改写成 <code>if</code> 条件语句。下面展示了原始的 <code>select</code> 语句和被改写、优化后的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改写前</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok &lt;-ch: <span class="comment">// case ch &lt;- v</span></span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写后</span></span><br><span class="line"><span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-ch <span class="comment">// case ch &lt;- v</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkselectcases</code></a> 在处理单操作 <code>select</code> 语句时，会根据 Channel 的收发情况生成不同的语句。当 <code>case</code> 中的 Channel 是空指针时，就会直接挂起当前 Goroutine 并永久休眠。</p><h3 id="非阻塞操作"><a href="#非阻塞操作" class="headerlink" title="非阻塞操作"></a>非阻塞操作</h3><p>当 <code>select</code> 中仅包含两个 <code>case</code>，并且其中一个是 <code>default</code> 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。<a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数会对这种情况单独处理，不过在正式优化之前，该函数会将 <code>case</code> 中的所有 Channel 都转换成指向 Channel 的地址。我们会分别介绍非阻塞发送和非阻塞接收时，编译器进行的不同优化。</p><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>首先是 Channel 的发送过程，当 <code>case</code> 中表达式的类型是 <code>OSEND</code> 时，编译器会使用 <code>if/else</code> 语句和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbsend</code></a> 函数改写代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> selectnbsend(ch, i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中最重要的就是 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbsend</code></a> 函数，它为我们提供了向 Channel 非阻塞地发送数据的能力。我们在 <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/" target="_blank" rel="external nofollow noopener noreferrer">Channel</a> 一节介绍了向 Channel 发送数据的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 函数包含一个 <code>block</code> 参数，该参数会决定这一次的发送是不是阻塞的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们向 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 函数传入了 <code>false</code>，所以哪怕是不存在接收方或者缓冲区空间不足都不会阻塞当前 Goroutine 而是会直接返回。</p><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>由于从 Channel 中接收数据可能会返回一个或者两个值，所以接受数据的情况会比发送稍显复杂，不过改写的套路是差不多的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改写前</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v &lt;- ch: <span class="comment">// case v, ok &lt;- ch:</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写后</span></span><br><span class="line"><span class="keyword">if</span> selectnbrecv(&amp;v, ch) &#123; <span class="comment">// if selectnbrecv2(&amp;v, &amp;ok, ch) &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值数量不同会导致使用函数的不同，两个用于非阻塞接收消息的函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv2</code></a> 只是对 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a> 返回值的处理稍有不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">selected, _ = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv2</span><span class="params">(elem unsafe.Pointer, received *<span class="keyword">bool</span>, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">selected, *received = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为接收方不需要，所以 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv</code></a> 会直接忽略返回的布尔值，而 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv2</code></a> 会将布尔值回传给调用方。与 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 一样，<a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a> 也提供了一个 <code>block</code> 参数用于控制这一次接收是否阻塞。</p><h3 id="常见流程"><a href="#常见流程" class="headerlink" title="常见流程"></a>常见流程</h3><p>在默认的情况下，编译器会使用如下的流程处理 <code>select</code> 语句：</p><ol><li>将所有的 <code>case</code> 转换成包含 Channel 以及类型等信息的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 结构体；</li><li>调用运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 从多个准备就绪的 Channel 中选择一个可执行的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 结构体；</li><li>通过 <code>for</code> 循环生成一组 <code>if</code> 语句，在语句中判断自己是不是被选中的 <code>case</code></li></ol><p>一个包含三个 <code>case</code> 的正常 <code>select</code> 语句其实会被展开成如下所示的逻辑，我们可以看到其中处理的三个部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">selv := [<span class="number">3</span>]scase&#123;&#125;</span><br><span class="line">order := [<span class="number">6</span>]<span class="keyword">uint16</span></span><br><span class="line"><span class="keyword">for</span> i, cas := <span class="keyword">range</span> cases &#123;</span><br><span class="line">    c := scase&#123;&#125;</span><br><span class="line">    c.kind = ...</span><br><span class="line">    c.elem = ...</span><br><span class="line">    c.c = ...</span><br><span class="line">&#125;</span><br><span class="line">chosen, revcOK := selectgo(selv, order, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> chosen == <span class="number">0</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chosen == <span class="number">1</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chosen == <span class="number">2</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开后的代码片段中最重要的就是用于选择待执行 <code>case</code> 的运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a>，这也是我们要关注的重点。因为这个函数的实现比较复杂， 所以这里分两部分分析它的执行过程：</p><ol><li>执行一些必要的初始化操作并确定 <code>case</code> 的处理顺序；</li><li>在循环中根据 <code>case</code> 的类型做出不同的处理；</li></ol><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数首先会进行执行必要的初始化操作并决定处理 <code>case</code> 的两个顺序 — 轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class="line">order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0))</span><br><span class="line"></span><br><span class="line">scases := cas1[:ncases:ncases]</span><br><span class="line">pollorder := order1[:ncases:ncases]</span><br><span class="line">lockorder := order1[ncases:][:ncases:ncases]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">cas := &amp;scases[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>))</span><br><span class="line">pollorder[i] = pollorder[j]</span><br><span class="line">pollorder[j] = <span class="keyword">uint16</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Channel 的地址排序确定加锁顺序</span></span><br><span class="line">...</span><br><span class="line">sellock(scases, lockorder)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code> 分别是通过以下的方式确认的：</p><ul><li>轮询顺序：通过 <a href="https://github.com/golang/go/blob/383b447e0da5bd1fcdc2439230b5a1d3e3402117/src/runtime/stubs.go#L114-L118" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.fastrandn</code></a> 函数引入随机性；</li><li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序；</li></ul><p>随机的轮询顺序可以避免 Channel 的饥饿问题，保证公平性；而根据 Channel 的地址顺序确定加锁顺序能够避免死锁的发生。这段代码最后调用的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L45-L54" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sellock</code></a> 函数会按照之前生成的加锁顺序锁定 <code>select</code> 语句中包含所有的 Channel。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>当我们为 <code>select</code> 语句锁定了所有 Channel 之后就会进入 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数的主循环，它会分三个阶段查找或者等待某个 Channel 准备就绪：</p><ol><li>查找是否已经存在准备就绪的 Channel，即可以执行收发操作；</li><li>将当前 Goroutine 加入 Channel 对应的收发队列上并等待其他 Goroutine 的唤醒；</li><li>当前 Goroutine 被唤醒之后找到满足条件的 Channel 并进行处理；</li></ol><p><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数会根据不同情况通过 <code>goto</code> 跳转到函数内部的不同标签执行相应的逻辑，其中包括：</p><ul><li><code>bufrecv</code>：可以从缓冲区读取数据；</li><li><code>bufsend</code>：可以向缓冲区写入数据；</li><li><code>recv</code>：可以从休眠的发送方获取数据；</li><li><code>send</code>：可以向休眠的接收方发送数据；</li><li><code>rclose</code>：可以从关闭的 Channel 读取 EOF；</li><li><code>sclose</code>：向关闭的 Channel 发送数据；</li><li><code>retc</code>：结束调用并返回；</li></ul><p>我们先来分析循环执行的第一个阶段，查找已经准备就绪的 Channel。循环会遍历所有的 <code>case</code> 并找到需要被唤起的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构，在这个阶段，我们会根据 <code>case</code> 的四种类型分别处理：</p><ol><li>```<br>caseNil<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：当前</span><br></pre></td></tr></table></figure>case<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   不包含 Channel；</span><br><span class="line"></span><br><span class="line">   - 这种 `case` 会被跳过；</span><br><span class="line"></span><br><span class="line"><span class="attribute">2.</span></span><br></pre></td></tr></table></figure>caseRecv<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：当前</span><br></pre></td></tr></table></figure>case<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   会从 Channel 中接收数据；</span><br><span class="line"></span><br><span class="line">   - 如果当前 Channel 的 `sendq` 上有等待的 Goroutine，就会跳到 `recv` 标签并从缓冲区读取数据后将等待 Goroutine 中的数据放入到缓冲区中相同的位置；</span><br><span class="line">   - 如果当前 Channel 的缓冲区不为空，就会跳到 `bufrecv` 标签处从缓冲区获取数据；</span><br><span class="line">   - 如果当前 Channel 已经被关闭，就会跳到 `rclose` 做一些清除的收尾工作；</span><br><span class="line"></span><br><span class="line"><span class="attribute">3.</span></span><br></pre></td></tr></table></figure>caseSend<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：当前</span><br></pre></td></tr></table></figure>case<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   会向 Channel 发送数据；</span><br><span class="line"></span><br><span class="line">   - 如果当前 Channel 已经被关，闭就会直接跳到 `sclose` 标签，触发 `panic` 尝试中止程序；</span><br><span class="line">   - 如果当前 Channel 的 `recvq` 上有等待的 Goroutine，就会跳到 `send` 标签向 Channel 发送数据；</span><br><span class="line">   - 如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；</span><br><span class="line"></span><br><span class="line"><span class="attribute">4.</span></span><br></pre></td></tr></table></figure>caseDefault<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：当前</span><br></pre></td></tr></table></figure>case<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">为</span><br></pre></td></tr></table></figure>default<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   语句；</span><br><span class="line"></span><br><span class="line">   - 表示前面的所有 `case` 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 `select` 结构中的收发都是非阻塞的；</span><br><span class="line"></span><br><span class="line">![golang-runtime-selectgo](https://img.draveness.me/2020-01-18-15793463657488-golang-runtime-selectgo.png)</span><br><span class="line"></span><br><span class="line">**图 5-8 运行时 selectgo 函数**</span><br><span class="line"></span><br><span class="line">第一阶段的主要职责是查找所有 `case` 中 Channel 是否有可以立刻被处理的情况。无论是在包含等待的 Goroutine 还是缓冲区中存在数据，只要满足条件就会立刻处理，如果不能立刻找到活跃的 Channel 就会进入循环的下一阶段，按照需要将当前的 Goroutine 加入到 Channel 的 `sendq` 或者 `recvq` 队列中：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) &#123;</span><br><span class="line">...</span><br><span class="line">gp = getg()</span><br><span class="line">nextp = &amp;gp.waiting</span><br><span class="line">for _, casei := range lockorder &#123;</span><br><span class="line">casi = int(casei)</span><br><span class="line">cas = &amp;scases[casi]</span><br><span class="line">c = cas.c</span><br><span class="line">sg := acquireSudog()</span><br><span class="line">sg.g = gp</span><br><span class="line">sg.c = c</span><br><span class="line"></span><br><span class="line">switch cas.kind &#123;</span><br><span class="line">case caseRecv:</span><br><span class="line">c.recvq.enqueue(sg)</span><br><span class="line">case caseSend:</span><br><span class="line">c.sendq.enqueue(sg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>除了将当前 Goroutine 对应的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体加入队列之外，这些 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体都会被串成链表附着在 Goroutine 上。在入队之后会调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopark</code></a> 函数挂起当前 Goroutine 等待调度器的唤醒。</p><p><img alt="Golang-Select-Waiting" data-src="https://img.draveness.me/2020-01-19-15794018429558-Golang-Select-Waiting.png"></p><p><strong>图 5-9 Goroutine 上等待收发的 sudog 链表</strong></p><p>等到 <code>select</code> 中的一些 Channel 准备就绪之后，当前 Goroutine 就会被调度器唤醒。这时会继续执行 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数的第三阶段，从 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体中获取数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">sg = (*sudog)(gp.param)</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">casi = <span class="number">-1</span></span><br><span class="line">cas = <span class="literal">nil</span></span><br><span class="line">sglist = gp.waiting</span><br><span class="line"><span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">k = &amp;scases[casei]</span><br><span class="line"><span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line">casi = <span class="keyword">int</span>(casei)</span><br><span class="line">cas = k</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">c.sendq.dequeueSudoG(sglist)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.recvq.dequeueSudoG(sglist)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sgnext = sglist.waitlink</span><br><span class="line">sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">releaseSudog(sglist)</span><br><span class="line">sglist = sgnext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = cas.c</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三次遍历全部 <code>case</code> 时，我们会先获取当前 Goroutine 接收到的参数 <code>sudog</code> 结构，我们会依次对比所有 <code>case</code> 对应的 <code>sudog</code> 结构找到被唤醒的 <code>case</code>，获取该 <code>case</code> 对应的索引并返回。</p><p>由于当前的 <code>select</code> 结构找到了一个 <code>case</code> 执行，那么剩下 <code>case</code> 中没有被用到的 <code>sudog</code> 就会被忽略并且释放掉。为了不影响 Channel 的正常使用，我们还是需要将这些废弃的 <code>sudog</code> 从 Channel 中出队。</p><p>当我们在循环中发现缓冲区中有元素或者缓冲区未满时就会通过 <code>goto</code> 关键字跳转到 <code>bufrecv</code> 和 <code>bufsend</code> 两个代码段，这两段代码的执行过程都很简单，它们只是向 Channel 中发送数据或者从缓冲区中获取新数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bufrecv:</span><br><span class="line">recvOK = <span class="literal">true</span></span><br><span class="line">qp = chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br></pre></td></tr></table></figure><p>这里在缓冲区进行的操作和直接调用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a> 函数差不多，上述两个过程在执行结束之后都会直接跳到 <code>retc</code> 字段。</p><p>两个直接对 Channel 收发的情况会调用 Channel 运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L286-L317" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.send</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L594-L635" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recv</code></a>，这两个函数会直接与处于休眠状态的 Goroutine 打交道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">recv:</span><br><span class="line">recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">recvOK = <span class="literal">true</span></span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br></pre></td></tr></table></figure><p>不过如果向关闭的 Channel 发送数据或者从关闭的 Channel 中接收数据，情况就稍微有一点复杂了：</p><ul><li>从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；</li><li>向一个关闭的 Channel 发送数据就会直接 <code>panic</code> 造成程序崩溃：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rclose:</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line">recvOK = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br></pre></td></tr></table></figure><p>总体来看，<code>select</code> 语句中的 Channel 收发操作和直接操作 Channel 没有太多出入，只是由于 <code>select</code> 多出了 <code>default</code> 关键字所以会支持非阻塞的收发。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们简单总结一下 <code>select</code> 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 <code>select</code> 语句进行优化，它会根据 <code>select</code> 中 <code>case</code> 的不同选择不同的优化路径：</p><ol><li><p>空的 <code>select</code> 语句会被转换成 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.block</code></a> 函数的调用，直接挂起当前 Goroutine；</p></li><li><p>如果</p></li></ol>   <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br></pre></td></tr></table></figure><p>   语句中只包含一个</p>   <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br></pre></td></tr></table></figure><p>   ，就会被转换成</p>   <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ch == nil &#123; <span class="keyword">block </span>&#125;<span class="comment">; n;</span></span><br></pre></td></tr></table></figure><p>   表达式；</p><ul><li>首先判断操作的 Channel 是不是空的；</li><li>然后执行 <code>case</code> 结构中的内容；</li></ul><ol><li><p>如果 <code>select</code> 语句中只包含两个 <code>case</code> 并且其中一个是 <code>default</code>，那么会使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbsend</code></a> 非阻塞地执行收发操作；</p></li><li><p>在默认情况下会通过 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数获取执行 <code>case</code> 的索引，并通过多个 <code>if</code> 语句执行对应 <code>case</code> 中的代码；</p></li></ol><p>在编译器已经对 <code>select</code> 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数，该函数会按照以下的流程执行：</p><ol><li><p>随机生成一个遍历的轮询顺序 <code>pollOrder</code> 并根据 Channel 地址生成锁定顺序 <code>lockOrder</code>；</p></li><li><p>根据</p></li></ol>   <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pollOrder</span></span><br></pre></td></tr></table></figure><p>   遍历所有的</p>   <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br></pre></td></tr></table></figure><p>   查看是否有可以立刻处理的 Channel；</p><ol><li>如果存在就直接获取 <code>case</code> 对应的索引并返回；</li><li>如果不存在就会创建 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopark</code></a> 挂起当前 Goroutine 等待调度器的唤醒；</li></ol><ol><li>当调度器唤醒当前 Goroutine 时就会再次按照 <code>lockOrder</code> 遍历所有的 <code>case</code>，从中查找需要被处理的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构对应的索引；</li></ol><p><code>select</code> 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多 C 语言或者 Unix 开发者听到 &lt;code&gt;select&lt;/code&gt; 想到的都是系统调用，而谈到 I/O 模型时最终大都会提到基于 &lt;code&gt;select&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt; 和 &lt;code&gt;epoll&lt;/code&gt; 等函数构建的 IO 多路复用模型。Go 语言的 &lt;code&gt;select&lt;/code&gt; 与 C 语言中的 &lt;code&gt;select&lt;/code&gt; 有着比较相似的功能。本节会介绍 Go 语言 &lt;code&gt;select&lt;/code&gt; 常见的现象、数据结构以及四种不同情况下的实现原理。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://img.draveness.me/2020-01-19-15794018429532-Golang-Select-Channels.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="select" scheme="http://houmin.cc/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】循环</title>
    <link href="http://houmin.cc/posts/44c65087/"/>
    <id>http://houmin.cc/posts/44c65087/</id>
    <published>2020-07-30T04:15:23.000Z</published>
    <updated>2020-08-21T08:11:30.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>循环是所有编程语言都有的控制结构，除了使用经典的「三段式」循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/" target="_blank" rel="external nofollow noopener noreferrer">数组</a>、<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/" target="_blank" rel="external nofollow noopener noreferrer">切片</a>、<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/" target="_blank" rel="external nofollow noopener noreferrer">哈希表</a> 以及 <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/" target="_blank" rel="external nofollow noopener noreferrer">Channel</a> 等集合类型。本节将深入分析 Go 语言的两种不同循环，也就是经典的 for 循环和 for/range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，</p><a id="more"></a><p>for 循环能够将代码中的数据和逻辑分离，让同一份代码能够多次复用处理同样的逻辑。我们先来看一下 Go 语言 for 循环对应的汇编代码，下面是一段经典的三段式循环的代码，我们将它编译成汇编指令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">98</span> args=<span class="number">0x0</span> locals=<span class="number">0x18</span></span><br><span class="line"><span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)TEXT<span class="string">""</span>.main(SB), $<span class="number">24</span><span class="number">-0</span></span><br><span class="line">...</span><br><span class="line"><span class="number">00029</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)XORLAX, AX                   ;; i := <span class="number">0</span></span><br><span class="line"><span class="number">00031</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)JMP<span class="number">75</span></span><br><span class="line"><span class="number">00033</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVQAX, <span class="string">""</span>.i+<span class="number">8</span>(SP)</span><br><span class="line"><span class="number">00038</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)CALLruntime.printlock(SB)</span><br><span class="line"><span class="number">00043</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)MOVQ<span class="string">""</span>.i+<span class="number">8</span>(SP), AX</span><br><span class="line"><span class="number">00048</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)MOVQAX, (SP)</span><br><span class="line"><span class="number">00052</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)CALLruntime.printint(SB)</span><br><span class="line"><span class="number">00057</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)CALLruntime.printnl(SB)</span><br><span class="line"><span class="number">00062</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)CALLruntime.printunlock(SB)</span><br><span class="line"><span class="number">00067</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVQ<span class="string">""</span>.i+<span class="number">8</span>(SP), AX</span><br><span class="line"><span class="number">00072</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)INCQAX                       ;; i++</span><br><span class="line"><span class="number">00075</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)CMPQAX, $<span class="number">10</span>                  ;; 比较变量 i 和 <span class="number">10</span></span><br><span class="line"><span class="number">00079</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)JLT<span class="number">33</span>                           ;; 跳转到 <span class="number">33</span> 行如果 i &lt; <span class="number">10</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们将上述汇编指令的执行过程分成三个部分进行分析：</p><ol><li><p>0029 ~ 0031 行负责循环的初始化；</p><ol><li>对寄存器 <code>AX</code> 中的变量 <code>i</code> 进行初始化并执行 <code>JMP 75</code> 指令跳转到 0075 行；</li></ol></li><li><p>0075 ~ 0079 行负责检查循环的终止条件，将寄存器中存储的数据</p></li></ol>   <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">i</span></span><br></pre></td></tr></table></figure><p>   与 10 比较；</p><ol><li><code>JLT 33</code> 命令会在变量的值小于 10 时跳转到 0033 行执行循环主体；</li><li><code>JLT 33</code> 命令会在变量的值大于 10 时跳出循环体执行下面的代码；</li></ol><ol><li><p>0033 ~ 0072 行是循环内部的语句；</p><ol><li>通过多个汇编指令打印变量中的内容；</li><li><code>INCQ AX</code> 指令会将变量加一，然后再与 10 进行比较，回到第二步；</li></ol></li></ol><p>for/range 循环经过优化的汇编代码有着完全相同的结构。无论是变量的初始化、循环体的执行还是最后的条件判断都是完全一样的，所以这里也就不展开分析对应的汇编指令了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在汇编语言中，无论是经典的 for 循环还是 for/range 循环都会使用 <code>JMP</code> 以及相关的命令跳回循环体的开始位置来多次执行代码的逻辑。从不同循环具有相同的汇编代码可以猜到，使用 for /range 的控制结构最终也会被 Go 语言编译器转换成普通的 for 循环，后面的分析会印证这一点。</p><h2 id="5-1-1-现象"><a href="#5-1-1-现象" class="headerlink" title="5.1.1 现象"></a>5.1.1 现象</h2><p>在深入语言的源代码中了解两种不同循环的实现之前，我们可以先来看一下使用 <code>for</code> 和 <code>range</code> 会遇到的一些现象和问题，我们可以带着这些现象和问题去源代码中寻找答案，这样能更高效地理解实现。</p><h3 id="循环永动机"><a href="#循环永动机" class="headerlink" title="循环永动机"></a>循环永动机</h3><p>如果我们在遍历数组的同时修改数组的元素，能否得到一个永远都不会停止的循环呢？你可以自己尝试运行下面的代码来得到结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">arr = <span class="built_in">append</span>(arr, v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>上述代码的输出意味着循环只遍历了原始切片中的三个元素，我们在遍历切片时追加的元素不会增加循环的执行次数，所以循环最终还是停了下来。</p><h3 id="神奇的指针"><a href="#神奇的指针" class="headerlink" title="神奇的指针"></a>神奇的指针</h3><p>第二个例子是使用 Go 语言经常会犯的错误<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。当我们在遍历一个数组时，如果获取 <code>range</code> 返回变量的地址并保存到另一个数组或者哈希时，就会遇到令人困惑的现象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">newArr = <span class="built_in">append</span>(newArr, &amp;v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">fmt.Println(*v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>上述代码最终会输出三个连续的 <code>3</code>，这个问题比较常见，一些有经验的开发者不经意也会犯这种错误，正确的做法应该是使用 <code>&amp;arr[i]</code> 替代 <code>&amp;v</code>，我们会在下面分析这一现象背后的原因。</p><h3 id="遍历清空数组"><a href="#遍历清空数组" class="headerlink" title="遍历清空数组"></a>遍历清空数组</h3><p>当我们想要在 Go 语言中清空一个切片或者哈希表时，我们一般都会使用以下的方法将切片中的元素置零，但是依次去遍历切片和哈希表看起来是非常耗费性能的事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr &#123;</span><br><span class="line">arr[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数组、切片和哈希表占用的内存空间都是连续的，所以最快的方法是直接清空这片内存中的内容，当我们编译上述代码时会得到以下的汇编指令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">93</span> args=<span class="number">0x0</span> locals=<span class="number">0x30</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)TEXT<span class="string">""</span>.main(SB), $<span class="number">48</span><span class="number">-0</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0x001d</span> <span class="number">00029</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVQ<span class="string">""</span>.statictmp_0(SB), AX</span><br><span class="line"><span class="number">0x0024</span> <span class="number">00036</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVQAX, <span class="string">""</span>..autotmp_3+<span class="number">16</span>(SP)</span><br><span class="line"><span class="number">0x0029</span> <span class="number">00041</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVUPS<span class="string">""</span>.statictmp_0+<span class="number">8</span>(SB), X0</span><br><span class="line"><span class="number">0x0030</span> <span class="number">00048</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVUPSX0, <span class="string">""</span>..autotmp_3+<span class="number">24</span>(SP)</span><br><span class="line"><span class="number">0x0035</span> <span class="number">00053</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)PCDATA$<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line"><span class="number">0x0035</span> <span class="number">00053</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)LEAQ<span class="string">""</span>..autotmp_3+<span class="number">16</span>(SP), AX</span><br><span class="line"><span class="number">0x003a</span> <span class="number">00058</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)PCDATA$<span class="number">2</span>, $<span class="number">0</span></span><br><span class="line"><span class="number">0x003a</span> <span class="number">00058</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)MOVQAX, (SP)</span><br><span class="line"><span class="number">0x003e</span> <span class="number">00062</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)MOVQ$<span class="number">24</span>, <span class="number">8</span>(SP)</span><br><span class="line"><span class="number">0x0047</span> <span class="number">00071</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)CALLruntime.memclrNoHeapPointers(SB)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从生成的汇编代码我们可以看出，编译器会直接使用 <a href="https://github.com/golang/go/blob/05c02444eb2d8b8d3ecd949c4308d8e2323ae087/src/runtime/memclr_386.s#L12-L16" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.memclrNoHeapPointers</code></a> 清空切片中的数据，这也是我们在下面的小节会介绍的内容。</p><h3 id="随机遍历"><a href="#随机遍历" class="headerlink" title="随机遍历"></a>随机遍历</h3><p>当我们在 Go 语言中使用 <code>range</code> 遍历哈希表时，往往都会使用如下的代码结构，但是这段代码在每次运行时都会打印出不同的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hash := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"1"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"2"</span>: <span class="number">2</span>,</span><br><span class="line"><span class="string">"3"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line"><span class="built_in">println</span>(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次运行上述代码可能会得到不同的结果，第一次会打印 <code>2 3 1</code>，第二次会打印 <code>1 2 3</code>，如果我们运行的次数足够多，最后会得到几种不同的遍历顺序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">1 1</span><br><span class="line"></span><br><span class="line">$ go run main.go</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><p>这是 Go 语言故意的设计，它在运行时为哈希表的遍历引入不确定性，也是告诉所有使用 Go 语言的使用者，程序不要依赖于哈希表的稳定遍历，我们在下面的小节会介绍在遍历的过程是如何引入不确定性的。</p><h2 id="5-1-2-经典循环"><a href="#5-1-2-经典循环" class="headerlink" title="5.1.2 经典循环"></a>5.1.2 经典循环</h2><p>Go 语言中的经典循环在编译器看来是一个 <code>OFOR</code> 类型的节点，这个节点由以下四个部分组成：</p><ol><li>初始化循环的 <code>Ninit</code>；</li><li>循环的继续条件 <code>Left</code>；</li><li>循环体结束时执行的 <code>Right</code>；</li><li>循环体 <code>NBody</code>：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> Ninit; Left; Right &#123;</span><br><span class="line">    NBody</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生成 SSA 中间代码的阶段，<a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023-L1502" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.stmt</code></a> 方法在发现传入的节点类型是 <code>OFOR</code> 时就会执行以下的代码块，这段代码的会将循环中的代码分成不同的块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">stmt</span><span class="params">(n *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OFOR, OFORUNTIL:</span><br><span class="line">bCond, bBody, bIncr, bEnd := ...</span><br><span class="line"></span><br><span class="line">b := s.endBlock()</span><br><span class="line">b.AddEdgeTo(bCond)</span><br><span class="line">s.startBlock(bCond)</span><br><span class="line">s.condBranch(n.Left, bBody, bEnd, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s.startBlock(bBody)</span><br><span class="line">s.stmtList(n.Nbody)</span><br><span class="line"></span><br><span class="line">b.AddEdgeTo(bIncr)</span><br><span class="line">s.startBlock(bIncr)</span><br><span class="line">s.stmt(n.Right)</span><br><span class="line">b.AddEdgeTo(bCond)</span><br><span class="line">s.startBlock(bEnd)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个常见的 for 循环代码会被 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023-L1502" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.stmt</code></a> 方法转换成下面的控制结构，该结构中包含了 4 个不同的块，这些代码块之间的连接就表示汇编语言中的跳转关系，与我们理解的 for 循环控制结构其实没有太多的差别。</p><p><img alt="golang-for-loop-ssa" data-src="https://img.draveness.me/2020-01-17-15792766877627-golang-for-loop-ssa.png"></p><p><strong>图 5-1 Go 语言循环生成的 SSA 代码</strong></p><p><a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/" target="_blank" rel="external nofollow noopener noreferrer">机器码生成</a>阶段会将这些代码块转换成机器码，以及指定 CPU 架构上运行的机器语言，就是我们在前面编译得到的汇编指令。</p><h2 id="5-1-3-范围循环"><a href="#5-1-3-范围循环" class="headerlink" title="5.1.3 范围循环"></a>5.1.3 范围循环</h2><p>与简单的经典循环相比，范围循环在 Go 语言中更常见、实现也更复杂。这种循环同时使用 for 和 range 两个关键字，编译器会在编译期间将所有 for/range 循环变成的经典循环。从编译器的视角来看，就是将 <code>ORANGE</code> 类型的节点转换成 <code>OFOR</code> 节点:</p><p><img alt="Golang-For-Range-Loop" data-src="https://img.draveness.me/2020-01-17-15792766926441-Golang-For-Range-Loop.png"></p><p><strong>图 5-2 范围循环、普通循环和 SSA</strong></p><p>节点类型的转换过程都发生在 SSA 中间代码生成阶段，所有的 for/range 循环都会被 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/cmd/compile/internal/gc/range.go#L155-L456" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkrange</code></a> 函数转换成不包含复杂结构、只包含基本表达式的语句。接下来，我们按照循环遍历的元素类型依次介绍遍历数组和切片、哈希表、字符串以及管道时的过程。</p><h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>对于数组和切片来说，Go 语言有三种不同的遍历方式，这三种不同的遍历方式分别对应着代码中的不同条件，它们会在 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/cmd/compile/internal/gc/range.go#L155-L456" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkrange</code></a> 函数中转换成不同的控制逻辑，我们将该函数的相关逻辑分成几个部分进行分析：</p><ol><li>分析遍历数组和切片清空元素的情况；</li><li>分析使用 <code>for range a {}</code> 遍历数组和切片，不关心索引和数据的情况；</li><li>分析使用 <code>for i := range a {}</code> 遍历数组和切片，只关心索引的情况；</li><li>分析使用 <code>for i, elem := range a {}</code> 遍历数组和切片，关心索引和数据的情况；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkrange</span><span class="params">(n *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line"><span class="keyword">case</span> TARRAY, TSLICE:</span><br><span class="line"><span class="keyword">if</span> arrayClear(n, v1, v2, a) &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/cmd/compile/internal/gc/range.go#L532-L610" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.arrayClear</code></a> 是一个非常有趣的优化，这个函数会优化 Go 语言遍历数组或者切片并删除全部元素的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// original</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">a[i] = zero</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optimized</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="number">0</span> &#123;</span><br><span class="line">hp = &amp;a[<span class="number">0</span>]</span><br><span class="line">hn = <span class="built_in">len</span>(a)*sizeof(elem(a))</span><br><span class="line">memclrNoHeapPointers(hp, hn)</span><br><span class="line">i = <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于依次清除数组或者切片中的数据，Go 语言会直接使用 <a href="https://github.com/golang/go/blob/05c02444eb2d8b8d3ecd949c4308d8e2323ae087/src/runtime/memclr_386.s#L12-L16" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.memclrNoHeapPointers</code></a> 或者 <a href="https://github.com/golang/go/blob/db16de920370892b0241d3fa0617dddff2417a4d/src/runtime/mbarrier.go#L345-L348" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.memclrHasPointers</code></a> 函数直接清除目标数组对应内存空间中的数据，并在执行完成后更新用于遍历数组的索引，这也印证了我们在遍历清空数组一节中观察到的现象。</p><p>处理了这种特殊的情况之后，我们就可以继续回到 <code>ORANGE</code> 节点的处理过程了。这里会设置 for 循环的 <code>Left</code> 和 <code>Right</code> 字段，也就是终止条件和循环体每次执行结束后运行的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ha := a</span><br><span class="line"></span><br><span class="line">hv1 := temp(types.Types[TINT])</span><br><span class="line">hn := temp(types.Types[TINT])</span><br><span class="line"></span><br><span class="line">init = <span class="built_in">append</span>(init, nod(OAS, hv1, <span class="literal">nil</span>))</span><br><span class="line">init = <span class="built_in">append</span>(init, nod(OAS, hn, nod(OLEN, ha, <span class="literal">nil</span>)))</span><br><span class="line"></span><br><span class="line">n.Left = nod(OLT, hv1, hn)</span><br><span class="line">n.Right = nod(OAS, hv1, nod(OADD, hv1, nodintconst(<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v1 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果原始的循环是 <code>for range a {}</code>，那么就满足 <code>v1 == nil</code> 的条件，即循环不关心数组的索引和数据，它会被编译器转换成如下所示的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1 := <span class="number">0</span></span><br><span class="line">hn := <span class="built_in">len</span>(ha)</span><br><span class="line">v1 := hv1</span><br><span class="line"><span class="keyword">for</span> ; hv1 &lt; hn; hv1++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>ORANGE</code> 结构在编译期间被转换的最简单形式，由于原始代码不需要获取数组的索引和元素，只需要使用数组或者切片的数量执行对应次数的循环，所以会生成一个最简单的 for 循环。</p><p>如果我们在遍历数组时需要使用索引 <code>for i := range a {}</code>，那么编译器会继续会执行下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v2 == <span class="literal">nil</span> &#123;</span><br><span class="line">body = []*Node&#123;nod(OAS, v1, hv1)&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>v2 == nil</code> 意味着调用方不关心数组的元素，只关心遍历数组使用的索引。它会将 <code>for i := range a {}</code> 转换成如下所示的逻辑，与第一种循环相比，这种循环在循环体中添加了 <code>v1 := hv1</code> 语句，传递遍历数组时的索引：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1 := <span class="number">0</span></span><br><span class="line">hn := <span class="built_in">len</span>(ha)</span><br><span class="line">v1 := hv1</span><br><span class="line"><span class="keyword">for</span> ; hv1 &lt; hn; hv1++ &#123;</span><br><span class="line">    v1 := hv1</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两种情况虽然也是使用 range 经常遇到的情况，但是同时去遍历索引和元素也很常见。处理这种情况会使用下面这段的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tmp := nod(OINDEX, ha, hv1)</span><br><span class="line">tmp.SetBounded(<span class="literal">true</span>)</span><br><span class="line">a := nod(OAS2, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">a.List.Set2(v1, v2)</span><br><span class="line">a.Rlist.Set2(hv1, tmp)</span><br><span class="line">body = []*Node&#123;a&#125;</span><br><span class="line">&#125;</span><br><span class="line">n.Ninit.Append(init...)</span><br><span class="line">n.Nbody.Prepend(body...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码处理的就是遍历数组和切片时，同时关心索引和切片的情况。它不仅会在循环体中插入更新索引的语句，还会插入赋值操作让循环体内部的代码能够访问数组中的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1 := <span class="number">0</span></span><br><span class="line">hn := <span class="built_in">len</span>(ha)</span><br><span class="line">v1 := hv1</span><br><span class="line"><span class="keyword">for</span> ; hv1 &lt; hn; hv1++ &#123;</span><br><span class="line">    tmp := ha[hv1]</span><br><span class="line">    v1, v2 := hv1, tmp</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新的变量 <code>ha</code>，在赋值的过程中就发生了拷贝，所以我们遍历的切片已经不是原始的切片变量了。</p><p>而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 <code>v2</code> 变量存储切片中的元素，<strong>循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，在赋值时也发生了拷贝</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr &#123;</span><br><span class="line">newArr = <span class="built_in">append</span>(newArr, &amp;arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">fmt.Println(*v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在循环中获取返回变量的地址都完全相同，所以会发生神奇的指针一节中的现象。所以如果我们想要访问数组中元素所在的地址，不应该直接获取 range 返回的变量地址 <code>&amp;v2</code>，而应该使用 <code>&amp;a[index]</code> 这种形式。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在遍历哈希表时，编译器会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L797-L844" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiterinit</code></a> 和 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L846-L970" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiternext</code></a> 两个运行时函数重写原始的 for/range 循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hit := hiter(n.Type)</span><br><span class="line">th := hit.Type</span><br><span class="line">mapiterinit(typename(t), ha, &amp;hit)</span><br><span class="line"><span class="keyword">for</span> ; hit.key != <span class="literal">nil</span>; mapiternext(&amp;hit) &#123;</span><br><span class="line">    key := *hit.key</span><br><span class="line">    val := *hit.val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是 <code>for key, val := range hash {}</code> 生成的，在 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/cmd/compile/internal/gc/range.go#L155-L456" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkrange</code></a> 函数处理 <code>TMAP</code> 节点时会根据接受 range 返回值的数量在循环体中插入需要的赋值语句：</p><p><img alt="golang-range-map" data-src="https://img.draveness.me/2020-01-17-15792766877639-golang-range-map.png"></p><p><strong>图 5-3 不同方式遍历哈希插入的语句</strong></p><p>这三种不同的情况会分别向循环体插入不同的赋值语句。遍历哈希表时会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L797-L844" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiterinit</code></a> 函数初始化遍历开始的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">it.t = t</span><br><span class="line">it.h = h</span><br><span class="line">it.B = h.B</span><br><span class="line">it.buckets = h.buckets</span><br><span class="line"></span><br><span class="line">r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line">it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line">it.bucket = it.startBucket</span><br><span class="line">mapiternext(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会初始化 <code>hiter</code> 结构体中的字段，并通过 <a href="https://github.com/golang/go/blob/383b447e0da5bd1fcdc2439230b5a1d3e3402117/src/runtime/stubs.go#L99-L111" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.fastrand</code></a> 生成一个随机数帮助我们随机选择一个桶开始遍历。Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性。</p><p>遍历哈希会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L846-L970" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiternext</code></a> 函数，我们在这里简化了很多逻辑，省去了一些边界条件以及哈希表扩容时的兼容操作，这里只需要关注处理遍历逻辑的核心代码，我们会将该函数分成桶的选择和桶内元素的遍历两部分进行分析，首先是桶的选择过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">h := it.h</span><br><span class="line">t := it.t</span><br><span class="line">bucket := it.bucket</span><br><span class="line">b := it.bptr</span><br><span class="line">i := it.i</span><br><span class="line">alg := t.key.alg</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line"><span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">it.key = <span class="literal">nil</span></span><br><span class="line">it.value = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">b = (*bmap)(add(it.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">bucket++</span><br><span class="line"><span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">bucket = <span class="number">0</span></span><br><span class="line">it.wrapped = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要有两个作用：</p><ol><li>在待遍历的桶为空时选择需要遍历的新桶；</li><li>在不存在待遍历的桶时返回 <code>(nil, nil)</code> 键值对并中止遍历过程；</li></ol><p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L846-L970" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiternext</code></a> 函数中第二段代码的主要作用就是从桶中找到下一个遍历的元素，在大多数情况下都会直接操作内存获取目标键值的内存地址，不过如果哈希表处于扩容期间就会调用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L511-L552" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccessK</code></a> 函数获取键值对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">!(t.reflexivekey() || alg.equal(k, k)) &#123;</span><br><span class="line">it.key = k</span><br><span class="line">it.value = v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rk, rv := mapaccessK(t, h, k)</span><br><span class="line">it.key = rk</span><br><span class="line">it.value = rv</span><br><span class="line">&#125;</span><br><span class="line">it.bucket = bucket</span><br><span class="line">it.i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">b = b.overflow(t)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上述函数已经遍历了正常桶，就会通过 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L207-L209" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.bmap.overflow</code></a> 获取溢出桶依次进行遍历。</p><p><img alt="golang-range-map-and-buckets" data-src="https://img.draveness.me/2020-01-17-15792766877646-golang-range-map-and-buckets.png"></p><p><strong>图 5-4 哈希表的遍历过程</strong></p><p>简单总结一下哈希表遍历的顺序，首先会选出一个绿色的正常桶开始遍历，随后遍历对应的所有黄色溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>遍历字符串的过程与数组、切片和哈希表非常相似，只是在遍历时会获取字符串中索引对应的字节并将字节转换成 <code>rune</code>。我们在遍历字符串时拿到的值都是 <code>rune</code> 类型的变量，<code>for i, r := range s {}</code> 的结构都会被转换成如下所示的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ha := s</span><br><span class="line"><span class="keyword">for</span> hv1 := <span class="number">0</span>; hv1 &lt; <span class="built_in">len</span>(ha); &#123;</span><br><span class="line">    hv1t := hv1</span><br><span class="line">    hv2 := <span class="keyword">rune</span>(ha[hv1])</span><br><span class="line">    <span class="keyword">if</span> hv2 &lt; utf8.RuneSelf &#123;</span><br><span class="line">        hv1++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hv2, hv1 = decoderune(h1, hv1)</span><br><span class="line">    &#125;</span><br><span class="line">    v1, v2 = hv1t, hv2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的字符串一节中我们曾经介绍过字符串是一个只读的字节数组切片，所以范围循环在编译期间生成的框架与切片非常类似，只是细节有一些不同。</p><p>使用下标访问字符串中的元素时得到的就是字节，但是这段代码会将当前的字节转换成 <code>rune</code> 类型。如果当前的 <code>rune</code> 是 ASCII 的，那么只会占用一个字节长度，每次循环体运行之后只需要将索引加一，但是如果当前 <code>rune</code> 占用了多个字节就会使用 <a href="https://github.com/golang/go/blob/c6e84263865fa418b4d4a60f077d02c10a0fff23/src/runtime/utf8.go#L60-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.decoderune</code></a> 函数解码，具体的过程就不在这里详细介绍了。</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>使用 range 遍历 Channel 也是比较常见的做法，一个形如 <code>for v := range ch {}</code> 的语句最终会被转换成如下的格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1, hb := &lt;-ha</span><br><span class="line"><span class="keyword">for</span> ; hb != <span class="literal">false</span>; hv1, hb = &lt;-ha &#123;</span><br><span class="line">    v1 := hv1</span><br><span class="line">    hv1 = <span class="literal">nil</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码可能与编译器生成的稍微有一些出入，但是结构和效果是完全相同的。该循环会使用 <code>&lt;-ch</code> 从管道中取出等待处理的值，这个操作会调用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L437-L440" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv2</code></a> 并阻塞当前的协程，当 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L437-L440" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv2</code></a> 返回时会根据布尔值 <code>hb</code> 判断当前的值是否存在，如果不存在就意味着当前的管道已经被关闭了，如果存在就会为 <code>v1</code> 赋值并清除 <code>hv1</code> 变量中的数据，然后会重新陷入阻塞等待新数据。</p><h2 id="5-1-4-小结"><a href="#5-1-4-小结" class="headerlink" title="5.1.4 小结"></a>5.1.4 小结</h2><p>这一节介绍的两个关键字 for 和 range 都是我们在学习和使用 Go 语言中无法绕开的，通过分析和研究它们的底层原理，让我们对实现细节有了更清楚的认识，包括 Go 语言遍历数组和切片时会复用变量、哈希表的随机遍历原理以及底层的一些优化，这都能帮助我们理解和使用 Go 语言。</p><hr><ol><li>CommonMistakes · Go <a href="https://github.com/golang/go/wiki/CommonMistakes" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/wiki/CommonMistakes</a> <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/#fnref:1" target="_blank" rel="external nofollow noopener noreferrer">↩︎</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;循环是所有编程语言都有的控制结构，除了使用经典的「三段式」循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历&lt;a href=&quot;https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;数组&lt;/a&gt;、&lt;a href=&quot;https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;切片&lt;/a&gt;、&lt;a href=&quot;https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;哈希表&lt;/a&gt; 以及 &lt;a href=&quot;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Channel&lt;/a&gt; 等集合类型。本节将深入分析 Go 语言的两种不同循环，也就是经典的 for 循环和 for/range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="循环" scheme="http://houmin.cc/tags/%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Reflect</title>
    <link href="http://houmin.cc/posts/bf9c845a/"/>
    <id>http://houmin.cc/posts/bf9c845a/</id>
    <published>2020-07-29T04:15:04.000Z</published>
    <updated>2020-08-21T08:11:30.086Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>反射是 Go 语言比较重要的特性。虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制实现简化代码的逻辑。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包能够弥补它在语法上的一些劣势。</p><a id="more"></a><p><a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 实现了运行时的反射能力，能够让程序操作不同类型的对象<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。反射包中有两对非常重要的函数和类型，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 能获取类型信息，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 能获取数据的运行时表示，另外两个类型是 <code>Type</code> 和 <code>Value</code>，它们与函数是一一对应的关系：</p><p><img alt="golang-reflection" data-src="https://img.draveness.me/golang-reflection.png"></p><p><strong>图 4-15 反射函数和类型</strong></p><p>类型 <code>Type</code> 是反射包定义的一个接口，我们可以使用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 函数获取任意变量的的类型，<code>Type</code> 接口中定义了一些有趣的方法，<code>MethodByName</code> 可以获取当前类型对应方法的引用、<code>Implements</code> 可以判断当前类型是否实现了某个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">        Align() <span class="keyword">int</span></span><br><span class="line">        FieldAlign() <span class="keyword">int</span></span><br><span class="line">        Method(<span class="keyword">int</span>) Method</span><br><span class="line">        MethodByName(<span class="keyword">string</span>) (Method, <span class="keyword">bool</span>)</span><br><span class="line">        NumMethod() <span class="keyword">int</span></span><br><span class="line">        ...</span><br><span class="line">        Implements(u Type) <span class="keyword">bool</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射包中 <code>Value</code> 的类型与 <code>Type</code> 不同，它被声明成了结构体。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Addr</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Bool</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>反射包中的所有方法基本都是围绕着 <code>Type</code> 和 <code>Value</code> 这两个类型设计的。我们通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a>、<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 可以将一个普通的变量转换成『反射』包中提供的 <code>Type</code> 和 <code>Value</code>，随后就可以使用反射包中的方法对它们进行复杂的操作。</p><h2 id="4-3-1-三大法则"><a href="#4-3-1-三大法则" class="headerlink" title="4.3.1 三大法则"></a>4.3.1 三大法则</h2><p>运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>，但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍 Go 语言反射的三大法则<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>，其中包括：</p><ol><li>从 <code>interface{}</code> 变量可以反射出反射对象；</li><li>从反射对象可以获取 <code>interface{}</code> 变量；</li><li>要修改反射对象，其值必须可设置；</li></ol><h3 id="第一法则"><a href="#第一法则" class="headerlink" title="第一法则"></a>第一法则</h3><p>反射的第一法则是我们能将 Go 语言的 <code>interface{}</code> 变量转换成反射对象。很多读者可能会对这以法则产生困惑 —— 为什么是从 <code>interface{}</code> 变量到反射对象？当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是由于 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a>、<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 两个方法的入参都是 <code>interface{}</code> 类型，所以在方法执行的过程中发生了类型转换。</p><p>在<a href="http://draveness.me/golang-function-call" target="_blank" rel="external nofollow noopener noreferrer">函数调用</a>一节中曾经介绍过，Go 语言的函数调用都是值传递的，变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface{}</code> 类型，这也就是为什么第一条法则是『从接口到反射对象』。</p><p>上面提到的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 函数就能完成这里的转换，如果我们认为 Go 语言的类型和反射类型处于两个不同的『世界』，那么这两个函数就是连接这两个世界的桥梁。</p><p><img alt="golang-interface-to-reflection" data-src="https://img.draveness.me/golang-interface-to-reflection.png"></p><p><strong>图 4-16 接口到反射对象</strong></p><p>我们通过以下例子简单介绍这两个函数的作用，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 获取了变量 <code>author</code> 的类型，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 获取了变量的值 <code>draven</code>。如果我们知道了一个变量的类型和值，那么就意味着知道了这个变量的全部信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">author := <span class="string">"draven"</span></span><br><span class="line">fmt.Println(<span class="string">"TypeOf author:"</span>, reflect.TypeOf(author))</span><br><span class="line">fmt.Println(<span class="string">"ValueOf author:"</span>, reflect.ValueOf(author))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">TypeOf author: <span class="keyword">string</span></span><br><span class="line">ValueOf author: draven</span><br></pre></td></tr></table></figure><p>有了变量的类型之后，我们可以通过 <code>Method</code> 方法获得类型实现的方法，通过 <code>Field</code> 获取类型包含的全部字段。对于不同的类型，我们也可以调用不同的方法获取相关信息：</p><ul><li>结构体：获取字段的数量并通过下标和字段名获取字段 <code>StructField</code>；</li><li>哈希表：获取哈希表的 <code>Key</code> 类型；</li><li>函数或方法：获取入参和返回值的类型；</li><li>…</li></ul><p>总而言之，使用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 能够获取 Go 语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。</p><h3 id="第二法则"><a href="#第二法则" class="headerlink" title="第二法则"></a>第二法则</h3><p>反射的第二法则是我们可以从反射对象可以获取 <code>interface{}</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 中的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L992-L994" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Interface</code></a> 方法就能完成这项工作：</p><p><img alt="golang-reflection-to-interface" data-src="https://img.draveness.me/golang-reflection-to-interface.png"></p><p><strong>图 4-17 反射对象到接口</strong></p><p>不过调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L992-L994" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Interface</code></a> 方法只能获得 <code>interface{}</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface().(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>从反射对象到接口值的过程就是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p><ul><li>从接口值到反射对象：<ul><li>从基本类型到接口类型的类型转换；</li><li>从接口类型到反射对象的转换；</li></ul></li><li>从反射对象到接口值：<ul><li>反射对象转换成接口类型；</li><li>通过显式类型转换变成原始类型；</li></ul></li></ul><p><img alt="golang-bidirectional-reflection" data-src="https://img.draveness.me/golang-bidirectional-reflection.png"></p><p><strong>图 4-18 接口和反射对象的双向转换</strong></p><p>当然不是所有的变量都需要类型转换这一过程。如果变量本身就是 <code>interface{}</code> 类型，那么它不需要类型转换，因为类型转换这一过程一般都是隐式的，所以我不太需要关心它，只有在我们需要将反射对象转换回基本类型时才需要显式的转换操作。</p><h3 id="第三法则"><a href="#第三法则" class="headerlink" title="第三法则"></a>第三法则</h3><p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的，假设我们有以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(i)</span><br><span class="line">v.SetInt(<span class="number">10</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run reflect.<span class="keyword">go</span></span><br><span class="line"><span class="built_in">panic</span>: reflect: reflect.flag.mustBeAssignable using unaddressable value</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">reflect.flag.mustBeAssignableSlow(<span class="number">0x82</span>, <span class="number">0x1014c0</span>)</span><br><span class="line">/usr/local/<span class="keyword">go</span>/src/reflect/value.<span class="keyword">go</span>:<span class="number">247</span> +<span class="number">0x180</span></span><br><span class="line">reflect.flag.mustBeAssignable(...)</span><br><span class="line">/usr/local/<span class="keyword">go</span>/src/reflect/value.<span class="keyword">go</span>:<span class="number">234</span></span><br><span class="line">reflect.Value.SetInt(<span class="number">0x100dc0</span>, <span class="number">0x414020</span>, <span class="number">0x82</span>, <span class="number">0x1840</span>, <span class="number">0xa</span>, <span class="number">0x0</span>)</span><br><span class="line">/usr/local/<span class="keyword">go</span>/src/reflect/value.<span class="keyword">go</span>:<span class="number">1606</span> +<span class="number">0x40</span></span><br><span class="line">main.main()</span><br><span class="line">/tmp/sandbox590309925/prog.<span class="keyword">go</span>:<span class="number">11</span> +<span class="number">0xe0</span></span><br></pre></td></tr></table></figure><p>运行上述代码会导致程序崩溃并报出 <code>reflect: reflect.flag.mustBeAssignable using unaddressable value</code> 错误，仔细思考一下就能够发现出错的原因，Go 语言的<a href="http://draveness.me/golang-function-call" target="_blank" rel="external nofollow noopener noreferrer">函数调用</a>都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，所以直接对它修改会导致崩溃。</p><p>想要修改原有的变量只能通过如下的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;i)</span><br><span class="line">v.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run reflect.<span class="keyword">go</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><ol><li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 函数获取变量指针；</li><li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L788-L821" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Elem</code></a> 方法获取指针指向的变量；</li><li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L1600-L1616" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.SetInt</code></a> 方法更新变量的值：</li></ol><p>由于 Go 语言的函数调用都是值传递的，所以我们只能先获取指针对应的 <code>reflect.Value</code>，再通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L788-L821" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Elem</code></a> 方法迂回的方式得到可以被设置的变量，我们通过如下所示的代码理解这个过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">v := &amp;i</span><br><span class="line">*v = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不能直接操作 <code>i</code> 变量修改其持有的值，我们就只能获取 <code>i</code> 变量所在地址并使用 <code>*v</code> 修改所在地址中存储的整数。</p><h2 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h2><p>Go 语言的 <code>interface{}</code> 类型在语言内部是通过 <code>emptyInterface</code> 这个结体来表示的，其中的 <code>rtype</code> 字段用于表示变量的类型，另一个 <code>word</code> 字段指向内部封装的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">typ  *rtype</span><br><span class="line">word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于获取变量类型的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 函数将传入的变量隐式转换成 <code>emptyInterface</code> 类型并获取其中存储的类型信息 <code>rtype</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"><span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rtype</code> 就是一个实现了 <code>Type</code> 接口的结构体，我们能在 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包中找到如下所示的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L752-L758" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtype.String</code></a> 方法帮助我们获取当前类型的名称等信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">s := t.nameOff(t.str).name()</span><br><span class="line"><span class="keyword">if</span> t.tflag&amp;tflagExtraStar != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 函数的实现原理其实并不复杂，它只是将一个 <code>interface{}</code> 变量转换成了内部的 <code>emptyInterface</code> 表示，然后从中获取相应的类型信息。</p><p>用于获取接口值 <code>Value</code> 的函数 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 实现也非常简单，在该函数中我们先调用了 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2779-L2783" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.escapes</code></a> 函数保证当前值逃逸到堆上，然后通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L140-L152" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.unpackEface</code></a> 方法从接口中获取 <code>Value</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">escapes(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">t := e.typ</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">f := flag(t.Kind())</span><br><span class="line"><span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">f |= flagIndir</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L140-L152" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.unpackEface</code></a> 函数会将传入的接口转换成 <code>emptyInterface</code> 结构体，然后将具体类型和指针包装成 <code>Value</code> 结构体并返回。</p><p><a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 函数的实现都很简单。我们已经分析了这两个函数的实现，现在需要了解编译器在调用函数之前做了哪些工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">20</span></span><br><span class="line">_ = reflect.TypeOf(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> build -gcflags=<span class="string">"-S -N"</span> main.<span class="keyword">go</span></span><br><span class="line">...</span><br><span class="line">MOVQ$<span class="number">20</span>, <span class="string">""</span>..autotmp_20+<span class="number">56</span>(SP) <span class="comment">// autotmp = 20</span></span><br><span class="line">LEAQ<span class="keyword">type</span>.<span class="keyword">int</span>(SB), AX           <span class="comment">// AX = type.int(SB)</span></span><br><span class="line">MOVQAX, <span class="string">""</span>..autotmp_19+<span class="number">280</span>(SP) <span class="comment">// autotmp_19+280(SP) = type.int(SB)</span></span><br><span class="line">LEAQ<span class="string">""</span>..autotmp_20+<span class="number">56</span>(SP), CX  <span class="comment">// CX = 20</span></span><br><span class="line">MOVQCX, <span class="string">""</span>..autotmp_19+<span class="number">288</span>(SP) <span class="comment">// autotmp_19+288(SP) = 20</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上面这段截取的汇编语言，我们发现在函数调用之前已经发生了类型转换，上述指令将 <code>int</code> 类型的变量转换成了占用 16 字节 <code>autotmp_19+280(SP) ~ autotmp_19+288(SP)</code> 的接口，两个 <code>LEAQ</code> 指令分别获取了类型的指针 <code>type.int(SB)</code> 以及变量 <code>i</code> 所在的地址。</p><p>当我们想要将一个变量转换成反射对象时，Go 语言会在编译期间完成类型转换的工作，将变量的类型和值转换成了 <code>interface{}</code> 并等待运行期间使用 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包获取接口中存储的信息。</p><h2 id="更新变量"><a href="#更新变量" class="headerlink" title="更新变量"></a>更新变量</h2><p>当我们想要更新一个 <code>reflect.Value</code>，就需要调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L1525-L1538" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Set</code></a> 方法更新反射对象，该方法会调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L232-L236" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.flag.mustBeAssignable</code></a> 和 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L214-L218" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.flag.mustBeExported</code></a> 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Set</span><span class="params">(x Value)</span></span> &#123;</span><br><span class="line">v.mustBeAssignable()</span><br><span class="line">x.mustBeExported()</span><br><span class="line"><span class="keyword">var</span> target unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> v.kind() == Interface &#123;</span><br><span class="line">target = v.ptr</span><br><span class="line">&#125;</span><br><span class="line">x = x.assignTo(<span class="string">"reflect.Set"</span>, v.typ, target)</span><br><span class="line">typedmemmove(v.typ, v.ptr, x.ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L1525-L1538" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Set</code></a> 方法会调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.assignTo</code></a> 并返回一个新的反射对象，这个返回的反射对象指针就会直接覆盖原始的反射变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">assignTo</span><span class="params">(context <span class="keyword">string</span>, dst *rtype, target unsafe.Pointer)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> directlyAssignable(dst, v.typ):</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> Value&#123;dst, v.ptr, fl&#125;</span><br><span class="line"><span class="keyword">case</span> implements(dst, v.typ):</span><br><span class="line"><span class="keyword">if</span> v.Kind() == Interface &amp;&amp; v.IsNil() &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;dst, <span class="literal">nil</span>, flag(Interface)&#125;</span><br><span class="line">&#125;</span><br><span class="line">x := valueInterface(v, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> dst.NumMethod() == <span class="number">0</span> &#123;</span><br><span class="line">*(*<span class="keyword">interface</span>&#123;&#125;)(target) = x</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ifaceE2I(dst, x, target)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Value&#123;dst, target, flagIndir | flag(Interface)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(context + <span class="string">": value of type "</span> + v.typ.String() + <span class="string">" is not assignable to type "</span> + dst.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.assignTo</code></a> 会根据当前和被设置的反射对象类型创建一个新的 <code>Value</code> 结构体：</p><ul><li>如果两个反射对象的类型是可以被直接替换，就会直接将目标反射对象返回；</li><li>如果当前反射对象是接口并且目标对象实现了接口，就会将目标对象简单包装成接口值；</li></ul><p>在变量更新的过程中，<a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.assignTo</code></a> 返回的 <code>reflect.Value</code> 中的指针会覆盖当前反射对象中的指针实现变量的更新。</p><h2 id="实现协议"><a href="#实现协议" class="headerlink" title="实现协议"></a>实现协议</h2><p><a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包还为我们提供了 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtypes.Implements</code></a> 方法可以用于判断某些类型是否遵循特定的接口。在 Go 语言中获取结构体的反射类型 <code>reflect.Type</code> 还是比较容易的，但是想要获得接口的类型就需要通过以下方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf((*&lt;<span class="keyword">interface</span>&gt;)(<span class="literal">nil</span>)).Elem()</span><br></pre></td></tr></table></figure><p>我们通过一个例子在介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的 <code>CustomError</code> 是否实现了 Go 语言标准库中的 <code>error</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">typeOfError := reflect.TypeOf((*error)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">customErrorPtr := reflect.TypeOf(&amp;CustomError&#123;&#125;)</span><br><span class="line">customError := reflect.TypeOf(CustomError&#123;&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(customErrorPtr.Implements(typeOfError)) <span class="comment">// #=&gt; true</span></span><br><span class="line">fmt.Println(customError.Implements(typeOfError)) <span class="comment">// #=&gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的运行结果正如我们在<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/" target="_blank" rel="external nofollow noopener noreferrer">接口</a>一节中介绍的：</p><ul><li><code>CustomError</code> 类型并没有实现 <code>error</code> 接口；</li><li><code>*CustomError</code> 指针类型实现了 <code>error</code> 接口；</li></ul><p>抛开上述的执行结果不谈，我们来分析一下 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtypes.Implements</code></a> 方法的工作原理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span> <span class="title">Implements</span><span class="params">(u Type)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect: nil type passed to Type.Implements"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> u.Kind() != Interface &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect: non-interface type passed to Type.Implements"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> implements(u.(*rtype), t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtypes.Implements</code></a> 方法会检查传入的类型是不是接口，如果不是接口或者是空值就会直接 panic 中止当前程序。在参数没有问题的情况下，上述方法会调用私有函数 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1461-L1543" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.implements</code></a> 判断类型之间是否有实现关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">implements</span><span class="params">(T, V *rtype)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">t := (*interfaceType)(unsafe.Pointer(T))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(t.methods) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">v := V.uncommon()</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">vmethods := v.methods()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="keyword">int</span>(v.mcount); j++ &#123;</span><br><span class="line">tm := &amp;t.methods[i]</span><br><span class="line">tmName := t.nameOff(tm.name)</span><br><span class="line">vm := vmethods[j]</span><br><span class="line">vmName := V.nameOff(vm.name)</span><br><span class="line"><span class="keyword">if</span> vmName.name() == tmName.name() &amp;&amp; V.typeOff(vm.mtyp) == t.typeOff(tm.typ) &#123;</span><br><span class="line"><span class="keyword">if</span> i++; i &gt;= <span class="built_in">len</span>(t.methods) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口，这时就会直接返回 <code>true</code>。</p><p><img alt="golang-type-implements-interface" data-src="https://img.draveness.me/golang-type-implements-interface.png"></p><p><strong>图 4-19 类型实现接口</strong></p><p>在其他情况下，由于方法都是按照字母序存储的，<a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1461-L1543" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.implements</code></a> 会维护两个用于遍历接口和类型方法的索引 <code>i</code> 和 <code>j</code> 判断类型是否实现了接口，因为最多只会进行 <code>n</code> 次比较（类型的方法数量），所以整个过程的时间复杂度是 <code>O(n)</code>。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>作为一门静态语言，如果我们想要通过 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包利用反射在运行期间执行方法不是一件容易的事情，下面的十几行代码就使用反射来执行 <code>Add(0, 1)</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(Add)</span><br><span class="line"><span class="keyword">if</span> v.Kind() != reflect.Func &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">t := v.Type()</span><br><span class="line">argv := <span class="built_in">make</span>([]reflect.Value, t.NumIn())</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> argv &#123;</span><br><span class="line"><span class="keyword">if</span> t.In(i).Kind() != reflect.Int &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">argv[i] = reflect.ValueOf(i)</span><br><span class="line">&#125;</span><br><span class="line">result := v.Call(argv)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="number">1</span> || result[<span class="number">0</span>].Kind() != reflect.Int &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result[<span class="number">0</span>].Int()) <span class="comment">// #=&gt; 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 获取函数 <code>Add</code> 对应的反射对象；</li><li>根据反射对象 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L979-L985" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtype.NumIn</code></a> 方法返回的参数个数创建 <code>argv</code> 数组；</li><li>多次调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 函数逐一设置 <code>argv</code> 数组中的各个参数；</li><li>调用反射对象 <code>Add</code> 的 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L318-L322" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Call</code></a> 方法并传入参数列表；</li><li>获取返回值数组、验证数组的长度以及类型并打印其中的数据；</li></ol><p>使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性需要付出的成本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Call</span><span class="params">(in []Value)</span> []<span class="title">Value</span></span> &#123;</span><br><span class="line">v.mustBe(Func)</span><br><span class="line">v.mustBeExported()</span><br><span class="line"><span class="keyword">return</span> v.call(<span class="string">"Call"</span>, in)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L318-L322" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Call</code></a> 方法是运行时调用方法的入口，它通过两个 <code>MustBe</code> 开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L339-L501" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.call</code></a> 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：</p><ol><li>检查输入参数以及类型的合法性；</li><li>将传入的 <code>reflect.Value</code> 参数数组设置到栈上；</li><li>通过函数指针和输入参数调用函数；</li><li>从栈上获取函数的返回值；</li></ol><p>我们将按照上面的顺序分析使用 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 进行函数调用的几个过程。</p><h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>参数检查是通过反射调用方法的第一步，在参数检查期间我们会从反射对象中取出当前的函数指针 <code>unsafe.Pointer</code>，如果该函数指针是方法，那么我们就会通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L612-L645" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.methodReceiver</code></a> 函数获取方法的接受者和函数指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">call</span><span class="params">(op <span class="keyword">string</span>, in []Value)</span> []<span class="title">Value</span></span> &#123;</span><br><span class="line">t := (*funcType)(unsafe.Pointer(v.typ))</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> v.flag&amp;flagMethod != <span class="number">0</span> &#123;</span><br><span class="line">rcvr = v</span><br><span class="line">rcvrtype, t, fn = methodReceiver(op, v, <span class="keyword">int</span>(v.flag)&gt;&gt;flagMethodShift)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">n := t.NumIn()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in) &lt; n &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect: Call with too few input arguments"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in) &gt; n &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect: Call with too many input arguments"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> xt, targ := in[i].Type(), t.In(i); !xt.AssignableTo(targ) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect: "</span> + op + <span class="string">" using "</span> + xt.String() + <span class="string">" as type "</span> + targ.String())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述方法中，上述方法还会检查传入参数的个数以及参数的类型与函数签名中的类型是否可以匹配，任何参数的不匹配都会导致整个程序的崩溃中止。</p><h3 id="准备参数"><a href="#准备参数" class="headerlink" title="准备参数"></a>准备参数</h3><p>当我们已经对当前方法的参数完成验证之后，就会进入函数调用的下一个阶段，为函数调用准备参数，在前面的章节<a href="https://draveness.me/golang/basic/golang-function-call.html" target="_blank" rel="external nofollow noopener noreferrer">函数调用</a>中我们已经介绍过 Go 语言的函数调用惯例，函数或者方法在调用时，所有的参数都会被依次放置到栈上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">nout := t.NumOut()</span><br><span class="line">frametype, _, retOffset, _, framePool := funcLayout(t, rcvrtype)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> nout == <span class="number">0</span> &#123;</span><br><span class="line">args = framePool.Get().(unsafe.Pointer)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">args = unsafe_New(frametype)</span><br><span class="line">&#125;</span><br><span class="line">off := <span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> rcvrtype != <span class="literal">nil</span> &#123;</span><br><span class="line">storeRcvr(rcvr, args)</span><br><span class="line">off = ptrSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> in &#123;</span><br><span class="line">targ := t.In(i).(*rtype)</span><br><span class="line">a := <span class="keyword">uintptr</span>(targ.align)</span><br><span class="line">off = (off + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line">n := targ.size</span><br><span class="line">...</span><br><span class="line">addr := add(args, off, <span class="string">"n &gt; 0"</span>)</span><br><span class="line">v = v.assignTo(<span class="string">"reflect.Value.Call"</span>, targ, addr)</span><br><span class="line">*(*unsafe.Pointer)(addr) = v.ptr</span><br><span class="line">off += n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L2975-L3048" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.funcLayout</code></a> 函数计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小；</p></li><li><p>如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间 <code>args</code>；</p></li><li><p>如果当前函数是方法，需要向将方法的接受者拷贝到 <code>args</code> 内存中；</p></li><li><p>将所有函数的参数按照顺序依次拷贝到对应</p></li></ol>   <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">args</span></span><br></pre></td></tr></table></figure><p>   内存中</p><ol><li>使用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L2975-L3048" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.funcLayout</code></a> 返回的参数计算参数在内存中的位置；<ol><li>将参数拷贝到内存空间中；</li></ol></li></ol><p>准备参数的过程是计算各个参数和返回值占用的内存空间并将所有的参数都拷贝内存空间对应的位置的过程，该过程会考虑函数和方法、返回值数量以及参数类型带来的差异。</p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>准备好调用函数需要的全部参数之后，就会通过以下的代码执行函数指针了。我们会向该函数传入栈类型、函数指针、参数和返回值的内存空间、栈的大小以及返回值的偏移量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call(frametype, fn, args, <span class="keyword">uint32</span>(frametype.size), <span class="keyword">uint32</span>(retOffset))</span><br></pre></td></tr></table></figure><p>上述函数实际上并不存在，它会在编译期间被链接到 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L489-L526" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.reflectcall</code></a> 这个用汇编实现的函数上，我们在这里不会分析该函数的具体实现，感兴趣的读者可以自行了解其实现原理。</p><h3 id="处理返回值"><a href="#处理返回值" class="headerlink" title="处理返回值"></a>处理返回值</h3><p>当函数调用结束之后，就会开始处理函数的返回值：</p><ul><li>如果函数没有任何返回值，会直接清空 <code>args</code> 中的全部内容来释放内存空间；</li><li>如果当前函数有返回值；<ol><li>将 <code>args</code> 中与输入参数有关的内存空间清空；</li><li>创建一个 <code>nout</code> 长度的切片用于保存由反射对象构成的返回值数组；</li><li>从函数对象中获取返回值的类型和内存大小，将 <code>args</code> 内存中的数据转换成 <code>reflect.Value</code> 类型并存储到切片中；</li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret []Value</span><br><span class="line"><span class="keyword">if</span> nout == <span class="number">0</span> &#123;</span><br><span class="line">typedmemclr(frametype, args)</span><br><span class="line">framePool.Put(args)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">typedmemclrpartial(frametype, args, <span class="number">0</span>, retOffset)</span><br><span class="line">ret = <span class="built_in">make</span>([]Value, nout)</span><br><span class="line">off = retOffset</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nout; i++ &#123;</span><br><span class="line">tv := t.Out(i)</span><br><span class="line">a := <span class="keyword">uintptr</span>(tv.Align())</span><br><span class="line">off = (off + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> tv.Size() != <span class="number">0</span> &#123;</span><br><span class="line">fl := flagIndir | flag(tv.Kind())</span><br><span class="line">ret[i] = Value&#123;tv.common(), add(args, off, <span class="string">"tv.Size() != 0"</span>), fl&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret[i] = Zero(tv)</span><br><span class="line">&#125;</span><br><span class="line">off += tv.Size()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 <code>reflect.Value</code> 构成的 <code>ret</code> 数组会被返回到上层，到这里为止使用反射实现函数调用的过程就结束了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Go 语言的 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包为我们提供的多种能力，包括如何使用反射来动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能，通过对反射包中方法原理的分析能帮助我们理解之前看起来比较怪异、令人困惑的现象。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="external nofollow noopener noreferrer">The Laws of Reflection</a></li><li><a href="https://github.com/golang/go/commit/3d1699ea787f38be6088f9a098d6e08dafca9387" target="_blank" rel="external nofollow noopener noreferrer">runtime: new itab lookup table</a></li><li><a href="https://github.com/golang/go/issues/20505" target="_blank" rel="external nofollow noopener noreferrer">runtime: need a better itab table</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射是 Go 语言比较重要的特性。虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制实现简化代码的逻辑。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 &lt;a href=&quot;https://golang.org/pkg/reflect/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; 包能够弥补它在语法上的一些劣势。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="reflect" scheme="http://houmin.cc/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Interface</title>
    <link href="http://houmin.cc/posts/c31234d9/"/>
    <id>http://houmin.cc/posts/c31234d9/</id>
    <published>2020-07-28T04:14:41.000Z</published>
    <updated>2020-08-21T08:11:30.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Go 语言中的接口就是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们更好地组织并写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也不清楚其底层的实现原理，这成为了开发高性能服务的最大阻碍。</p><p>本节会介绍使用接口时遇到的一些常见问题以及它的设计与实现，包括接口的类型转换、类型断言以及动态派发机制，帮助各位读者更好地理解接口类型。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在计算机科学中，接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。如图 4-5，接口的本质就是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p><p><img alt="golang-interface" data-src="https://img.draveness.me/golang-interface.png"></p><p><strong>图 4-5 上下游通过接口解耦</strong></p><p>这种面向接口的编程方式有着非常强大的生命力，无论是在框架还是操作系统中我们都能够找到接口的身影。可移植操作系统接口（Portable Operating System Interface，POSIX)<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>就是一个典型的例子，它定义了应用程序接口和命令行等标准，为计算机软件带来了可移植性 — 只要操作系统实现了 POSIX，计算机软件就可以直接在不同操作系统上运行。</p><p>除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。《计算机程序的构造和解释》中有这么一句话：</p><blockquote><p>代码必须能够被人阅读，只是机器恰好可以执行<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a></p></blockquote><p>人能够同时处理的信息非常有限，定义良好的接口能够隔离底层的实现，让我们将重点放在当前的代码片段中。SQL 就是接口的一个例子，当我们使用 SQL 语句查询数据时，其实不需要关心底层数据库的具体实现，我们只在乎 SQL 返回的结果是否符合预期。</p><p><img alt="sql-and-databases" data-src="https://img.draveness.me/2020-01-12-15787970694046-sql-and-databases.png"></p><p><strong>图 4-6 SQL 和不同数据库</strong></p><p>计算机科学中的接口是一个比较抽象的概念，但是编程语言中接口的概念就更加具体。Go 语言中的接口是一种内置的类型，它定义了一组方法的签名，这一小节会先介绍 Go 语言接口的几个基本概念以及常见问题，为之后介绍实现原理做一些铺垫。</p><h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>很多面向对象语言都有接口这一概念，例如 Java 和 C#。Java 的接口不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义了一个必须实现的方法 <code>sayHello</code> 和一个会注入到实现类的变量 <code>hello</code>。在下面的代码中，<code>MyInterfaceImpl</code> 就实现了 <code>MyInterface</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(MyInterface.hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的类必须通过上述方式显式地声明实现的接口，但是在 Go 语言中实现接口就不需要使用类似的方式。首先，我们简单了解一下在 Go 语言中如何定义接口。定义接口需要使用 <code>interface</code> 关键字，在接口中我们只能定义方法签名，不能包含成员变量，一个常见的 Go 语言接口是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类型需要实现 <code>error</code> 接口，那么它只需要实现 <code>Error() string</code> 方法，下面的 <code>RPCError</code> 结构体就是 <code>error</code> 接口的一个实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCError <span class="keyword">struct</span> &#123;</span><br><span class="line">Code    <span class="keyword">int64</span></span><br><span class="line">Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RPCError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s, code=%d"</span>, e.Message, e.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者可能会发现上述代码根本就没有 <code>error</code> 接口的影子，这是为什么呢？Go 语言中<strong>接口的实现都是隐式的</strong>，我们只需要实现 <code>Error() string</code> 方法实现了 <code>error</code> 接口。Go 语言实现接口的方式与 Java 完全不同：</p><ul><li>在 Java 中：实现接口需要显式的声明接口并实现所有方法；</li><li>在 Go 中：实现接口的所有方法就隐式的实现了接口；</li></ul><p>我们使用上述 <code>RPCError</code> 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查，这里举几个例子来演示发生接口类型检查的时机：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rpcErr error = NewRPCError(<span class="number">400</span>, <span class="string">"unknown err"</span>) <span class="comment">// typecheck1</span></span><br><span class="line">err := AsErr(rpcErr) <span class="comment">// typecheck2</span></span><br><span class="line"><span class="built_in">println</span>(err) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRPCError</span><span class="params">(code <span class="keyword">int64</span>, msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RPCError&#123; <span class="comment">// typecheck3</span></span><br><span class="line">Code:    code,</span><br><span class="line">Message: msg,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsErr</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言会<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/" target="_blank" rel="external nofollow noopener noreferrer">编译期间</a>对代码进行类型检查，上述代码总共触发了三次类型检查：</p><ol><li>将 <code>*RPCError</code> 类型的变量赋值给 <code>error</code> 类型的变量 <code>rpcErr</code>；</li><li>将 <code>*RPCError</code> 类型的变量 <code>rpcErr</code> 传递给签名中参数类型为 <code>error</code> 的 <code>AsErr</code> 函数；</li><li>将 <code>*RPCError</code> 类型的变量从函数签名的返回值类型为 <code>error</code> 的 <code>NewRPCError</code> 函数中返回；</li></ol><p>从类型检查的过程来看，编译器仅在需要时才对类型进行检查，类型实现接口时只需要实现接口中的全部方法，不需要像 Java 等编程语言中一样显式声明。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 <code>interface{}</code>：</p><p><img alt="golang-different-interface" data-src="https://img.draveness.me/golang-different-interface.png"></p><p><strong>图 4-7 Go 语言中的两种接口</strong></p><p>Go 语言使用 <code>iface</code> 结构体表示第一种接口，使用 <code>eface</code> 结构体表示第二种空接口，两种接口虽然都使用 <code>interface</code> 声明，但是由于后者在 Go 语言中非常常见，所以在实现时使用了特殊的类型。</p><p>需要注意的是，与 C 语言中的 <code>void *</code> 不同，<code>interface{}</code> 类型<strong>不是任意类型</strong>，如果我们将类型转换成了 <code>interface{}</code> 类型，这边变量在运行期间的类型也发生了变化，获取变量类型时就会得到 <code>interface{}</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">v := Test&#123;&#125;</span><br><span class="line">Print(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数不接受任意类型的参数，只接受 <code>interface{}</code> 类型的值，在调用 <code>Print</code> 函数时会对参数 <code>v</code> 进行类型转换，将原来的 <code>Test</code> 类型转换成 <code>interface{}</code> 类型，我们会在本节后面介绍类型转换的过程和原理。</p><h3 id="指针和接口"><a href="#指针和接口" class="headerlink" title="指针和接口"></a>指针和接口</h3><p>在 Go 语言中同时使用指针和接口时会发生一些让人困惑的问题，接口在定义一组方法时没有对实现的接收者做限制，所以我们会看到『一个类型』实现接口的两种方式：</p><p><img alt="golang-interface-and-pointer" data-src="https://img.draveness.me/golang-interface-and-pointer.png"></p><p><strong>图 4-8 结构体和指针实现接口</strong></p><p>这是因为结构体类型和指针类型是完全不同的，就像我们不能向一个接受指针的函数传递结构体，在实现接口时这两种类型也不能划等号。但是上图中的两种实现不可以同时存在，Go 语言的编译器会在结构体类型和指针类型都实现一个方法时报错 —— <code>method redeclared</code>。</p><p>对 <code>Cat</code> 结构体来说，它在实现接口时可以选择接受者的类型，即结构体或者结构体指针，在初始化时也可以初始化成结构体或者指针。下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c  Cat)</span> <span class="title">Quack</span></span> &#123;&#125;  <span class="comment">// 使用结构体实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span></span> &#123;&#125;  <span class="comment">// 使用结构体指针实现接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d Duck = Cat&#123;&#125;      <span class="comment">// 使用结构体初始化变量</span></span><br><span class="line"><span class="keyword">var</span> d Duck = &amp;Cat&#123;&#125;     <span class="comment">// 使用结构体指针初始化变量</span></span><br></pre></td></tr></table></figure><p>实现接口的类型和初始化返回的类型两个维度组成了四种情况，这四种情况并不都能通过编译器的检查：</p><div class="table-container"><table><thead><tr><th></th><th>结构体实现接口</th><th>结构体指针实现接口</th></tr></thead><tbody><tr><td>结构体初始化变量</td><td>通过</td><td>不通过</td></tr><tr><td>结构体指针初始化变量</td><td>通过</td><td>通过</td></tr></tbody></table></div><p>四种中只有『使用指针实现接口，使用结构体初始化变量』无法通过编译，其他的三种情况都可以正常执行。当实现接口的类型和初始化变量时返回的类型时相同时，代码通过编译是理所应当的：</p><ul><li>方法接受者和初始化类型都是结构体；</li><li>方法接受者和初始化类型都是结构体指针；</li></ul><p>而剩下的两种方式为什么一种能够通过编译，另一种无法通过编译呢？我们先来看一下能够通过编译的情况，也就是方法的接受者是结构体，而初始化的变量是结构体指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"meow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Duck = &amp;Cat&#123;&#125;</span><br><span class="line">c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为指针的 <code>&amp;Cat{}</code> 变量能够<strong>隐式地获取</strong>到指向的结构体，所以能在结构体上调用 <code>Walk</code> 和 <code>Quack</code> 方法。我们可以将这里的调用理解成 C 语言中的 <code>d-&gt;Walk()</code> 和 <code>d-&gt;Speak()</code>，它们都会先获取指向的结构体再执行对应的方法。</p><p>但是如果我们将上述代码中方法的接受者和初始化的类型进行交换，代码就无法通过编译了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"meow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Duck = Cat&#123;&#125;</span><br><span class="line">c.Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> build <span class="keyword">interface</span>.<span class="keyword">go</span></span><br><span class="line">./<span class="keyword">interface</span>.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">6</span>: cannot use Cat literal (<span class="keyword">type</span> Cat) as <span class="keyword">type</span> Duck in assignment:</span><br><span class="line">Cat does not implement Duck (Quack method has pointer receiver)</span><br></pre></td></tr></table></figure><p>编译器会提醒我们：<code>Cat</code> 类型没有实现 <code>Duck</code> 接口，<code>Quack</code> 方法的接受者是指针。这两个报错对于刚刚接触 Go 语言的开发者比较难以理解，如果我们想要搞清楚这个问题，首先要知道 Go 语言在<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/" target="_blank" rel="external nofollow noopener noreferrer">传递参数</a>时都是传值的。</p><p><img alt="golang-interface-method-receive" data-src="https://img.draveness.me/golang-interface-method-receiver.png"></p><p><strong>图 4-9 实现接口的接受者类型</strong></p><p>如上图所示，无论上述代码中初始化的变量 <code>c</code> 是 <code>Cat{}</code> 还是 <code>&amp;Cat{}</code>，使用 <code>c.Quack()</code> 调用方法时都会发生值拷贝：</p><ul><li>如图 4-9 左侧，对于 <code>&amp;Cat{}</code> 来说，这意味着拷贝一个新的 <code>&amp;Cat{}</code> 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体；</li><li>如图 4-9 右侧，对于 <code>Cat{}</code> 来说，这意味着 <code>Quack</code> 方法会接受一个全新的 <code>Cat{}</code>，因为方法的参数是 <code>*Cat</code>，编译器不会无中生有创建一个新的指针；即使编译器可以创建新指针，这个指针指向的也不是最初调用该方法的结构体；</li></ul><p>上面的分析解释了指针类型的现象，当我们使用指针实现接口时，只有指针类型的变量才会实现该接口；当我们使用结构体实现接口时，指针类型和结构体类型都会实现该接口。当然这并不意味着我们应该一律使用结构体实现接口，这个问题在实际工程中也没那么重要，在这里我们只想解释现象背后的原因。</p><h3 id="nil-和-non-nil"><a href="#nil-和-non-nil" class="headerlink" title="nil 和 non-nil"></a>nil 和 non-nil</h3><p>我们可以通过一个例子理解<strong>『Go 语言的接口类型不是任意类型』</strong>这一句话，下面的代码在 <code>main</code> 函数中初始化了一个 <code>*TestStruct</code> 结构体指针，由于指针的零值是 <code>nil</code>，所以变量 <code>s</code> 在初始化之后也是 <code>nil</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NilOrNot</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> v == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s *TestStruct</span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>)      <span class="comment">// #=&gt; true</span></span><br><span class="line">fmt.Println(NilOrNot(s))   <span class="comment">// #=&gt; false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>我们简单总结一下上述代码执行的结果：</p><ul><li>将上述变量与 <code>nil</code> 比较会返回 <code>true</code>；</li><li>将上述变量传入 <code>NilOrNot</code> 方法并与 <code>nil</code> 比较会返回 <code>false</code>；</li></ul><p>出现上述现象的原因是 —— 调用 <code>NilOrNot</code> 函数时发生了<strong>隐式的类型转换</strong>，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，<code>*TestStruct</code> 类型会转换成 <code>interface{}</code> 类型，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 <code>TestStruct</code>，所以转换后的变量与 <code>nil</code> 不相等。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>相信各位读者已经对 Go 语言的接口有了一些的了解，接下来我们从源代码和汇编指令层面介绍接口的底层数据结构。</p><p>Go 语言根据接口类型『是否包含一组方法』对类型做了不同的处理。我们使用 <code>iface</code> 结构体表示包含方法的接口；使用 <code>eface</code> 结构体表示不包含任何方法的 <code>interface{}</code> 类型，<code>eface</code> 结构体在 Go 语言的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 bytes</span></span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>interface{}</code> 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针。从上述结构我们也能推断出 — Go 语言中的任意类型都可以转换成 <code>interface{}</code> 类型。</p><p>另一个用于表示接口的结构体就是 <code>iface</code>，这个结构体中有指向原始数据的指针 <code>data</code>，不过更重要的是 <code>itab</code> 类型的 <code>tab</code> 字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 bytes</span></span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们将详细分析 Go 语言接口中的这两个类型，即 <code>_type</code> 和 <code>itab</code>。</p><h3 id="类型结构体"><a href="#类型结构体" class="headerlink" title="类型结构体"></a>类型结构体</h3><p><code>_type</code> 是 Go 语言类型的运行时表示。下面是运行时包中的结构体，结构体包含了很多元信息，例如：类型的大小、哈希、对齐以及种类等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">size       <span class="keyword">uintptr</span></span><br><span class="line">ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">hash       <span class="keyword">uint32</span></span><br><span class="line">tflag      tflag</span><br><span class="line">align      <span class="keyword">uint8</span></span><br><span class="line">fieldAlign <span class="keyword">uint8</span></span><br><span class="line">kind       <span class="keyword">uint8</span></span><br><span class="line">equal      <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line">gcdata     *<span class="keyword">byte</span></span><br><span class="line">str        nameOff</span><br><span class="line">ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>size</code> 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li><li><code>hash</code> 字段能够帮助我们快速确定类型是否相等；</li><li><code>equal</code> 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 <code>typeAlg</code> 结构体中迁移过来的<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:4" target="_blank" rel="external nofollow noopener noreferrer">4</a>；</li></ul><p>我们只需要对 <code>_type</code> 结构体中的字段有一个大体的概念，不需要详细理解所有字段的作用和意义。</p><h3 id="itab-结构体"><a href="#itab-结构体" class="headerlink" title="itab 结构体"></a>itab 结构体</h3><p><code>itab</code> 结构体是接口类型的核心组成部分，每一个 <code>itab</code> 都占 32 字节的空间，我们可以将其看成接口类型和具体类型的组合，它们分别用 <code>inter</code> 和 <code>_type</code> 两个字段表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123; <span class="comment">// 32 bytes</span></span><br><span class="line">inter *interfacetype</span><br><span class="line">_type *_type</span><br><span class="line">hash  <span class="keyword">uint32</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>inter</code> 和 <code>_type</code> 两个用于表示类型的字段之外，上述结构体中的另外两个字段也有自己的作用：</p><ul><li><code>hash</code> 是对 <code>_type.hash</code> 的拷贝，当我们想将 <code>interface</code> 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <code>_type</code> 是否一致；</li><li><code>fun</code> 是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 <code>fun</code> 数组中保存的元素数量是不确定的；</li></ul><p>我们会在类型断言中介绍 <code>hash</code> 字段的使用，在动态派发一节中介绍 <code>fun</code> 数组中存储的函数指针是如何被使用的。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>既然我们已经了解了接口在运行时的数据结构，接下来会通过几个例子来深入理解接口类型是如何初始化和传递的，这里会介绍在实现接口时使用指针类型和结构体类型的区别。这两种不同的接口实现方式会导致 Go 语言编译器生成不同的汇编代码，带来执行过程上的一些差异。</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>首先我们回到这一节开头提到的 <code>Duck</code> 接口的例子，我们使用 <code>//go:noinline</code> 指令<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:5" target="_blank" rel="external nofollow noopener noreferrer">5</a>禁止 <code>Quack</code> 方法的内联编译：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(c.Name + <span class="string">" meow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用编译器将上述代码编译成汇编语言，删掉其中一些对理解接口原理无用的指令并保留与赋值语句 <code>var c Duck = &amp;Cat{Name: &quot;grooming&quot;}</code> 相关的代码，我们将生成的汇编指令拆分成三部分分析：</p><ol><li>结构体 <code>Cat</code> 的初始化；</li><li>赋值触发的类型转换过程；</li><li>调用接口的方法 <code>Quack()</code>；</li></ol><p>我们先来分析结构体 <code>Cat</code> 的初始化过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LEAQ<span class="keyword">type</span>.<span class="string">""</span>.Cat(SB), AX                ;; AX = &amp;<span class="keyword">type</span>.<span class="string">""</span>.Cat</span><br><span class="line">MOVQAX, (SP)                           ;; SP = &amp;<span class="keyword">type</span>.<span class="string">""</span>.Cat</span><br><span class="line">CALLruntime.newobject(SB)              ;; SP + <span class="number">8</span> = &amp;Cat&#123;&#125;</span><br><span class="line">MOVQ<span class="number">8</span>(SP), DI                          ;; DI = &amp;Cat&#123;&#125;</span><br><span class="line">MOVQ$<span class="number">8</span>, <span class="number">8</span>(DI)                          ;; StringHeader(DI.Name).Len = <span class="number">8</span></span><br><span class="line">LEAQ<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"grooming"</span>(SB), AX       ;; AX = &amp;<span class="string">"grooming"</span></span><br><span class="line">MOVQAX, (DI)                           ;; StringHeader(DI.Name).Data = &amp;<span class="string">"grooming"</span></span><br></pre></td></tr></table></figure><ol><li>获取 <code>Cat</code> 结构体类型指针并将其作为参数放到栈上；</li><li>通过 <code>CALL</code> 指定调用 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 函数，这个函数会以 <code>Cat</code> 结构体类型指针作为入参，分配一片新的内存空间并将指向这片内存空间的指针返回到 SP+8 上；</li><li>SP+8 现在存储了一个指向 <code>Cat</code> 结构体的指针，我们将栈上的指针拷贝到寄存器 <code>DI</code> 上方便操作；</li><li>由于 <code>Cat</code> 中只包含一个字符串类型的 <code>Name</code> 变量，所以在这里会分别将字符串地址 <code>&amp;&quot;grooming&quot;</code> 和字符串长度 <code>8</code> 设置到结构体上，最后三行汇编指令等价于 <code>cat.Name = &quot;grooming&quot;</code>；</li></ol><p>字符串在运行时的表示其实就是指针加上字符串长度，在前面的章节<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/" target="_blank" rel="external nofollow noopener noreferrer">字符串</a>已经介绍过它的底层表示和实现原理，但是我们这里要看一下初始化之后的 <code>Cat</code> 结构体在内存中的表示是什么样的：</p><p><img alt="golang-new-struct-pointe" data-src="https://img.draveness.me/golang-new-struct-pointer.png"></p><p><strong>图 4-10 Cat 结构体指针</strong></p><p>因为 <code>Cat</code> 结构体的定义中只包含一个字符串，而字符串在 Go 语言中总共占 16 字节，所以每一个 <code>Cat</code> 结构体的大小都是 16 字节。初始化 <code>Cat</code> 结构体之后就进入了将 <code>*Cat</code> 转换成 <code>Duck</code> 类型的过程了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEAQ<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck(SB), AX    ;; AX = *itab(<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck)</span><br><span class="line">MOVQDI, (SP)                           ;; SP = AX</span><br></pre></td></tr></table></figure><p>类型转换的过程比较简单，<code>Duck</code> 作为一个包含方法的接口，它在底层使用 <code>iface</code> 结构体表示。<code>iface</code> 结构体包含两个字段，其中一个是指向数据的指针，另一个是表示接口和结构体关系的 <code>tab</code> 字段，我们已经通过上一段代码 SP+8 初始化了 <code>Cat</code> 结构体指针，这段代码只是将编译期间生成的 <code>itab</code> 结构体指针复制到 SP 上：</p><p><img alt="golang-struct-pointer-to-iface" data-src="https://img.draveness.me/golang-struct-pointer-to-iface.png"></p><p><strong>图 4-11 Cat 类型转换</strong></p><p>到这里，我们会发现 SP ~ SP+16 共同组成了 <code>iface</code> 结构体，而栈上的这个 <code>iface</code> 结构体也是 <code>Quack</code> 方法的第一个入参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL    <span class="string">""</span>.(*Cat).Quack(SB)                ;; SP.Quack()</span><br></pre></td></tr></table></figure><p>上述代码会直接通过 <code>CALL</code> 指令完成方法的调用，细心的读者可能会发现一个问题 —— 为什么在代码中我们调用的是 <code>Duck.Quack</code> 但生成的汇编是 <code>*Cat.Quack</code> 呢？Go 语言的编译器会在编译期间将一些需要动态派发的方法调用改写成对目标方法的直接调用，以减少性能的额外开销。如果在这里禁用编译器优化，就会看到动态派发的过程，我们会在后面分析接口的动态派发以及性能上的额外开销。</p><h3 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h3><p>在这里，我们继续修改上一节中的代码，使用结构体类型实现 <code>Duck</code> 接口并初始化结构体类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(c.Name + <span class="string">" meow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Duck = Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在初始化变量时使用指针类型 <code>&amp;Cat{Name: &quot;grooming&quot;}</code> 也能够通过编译，不过生成的汇编代码和上一节中的几乎完全相同，所以这里也就不分析这个情况了。</p><p>编译上述的代码会得到如下所示的汇编指令，需要注意的是为了代码更容易理解和分析，这里的汇编指令依然经过了删减，不过不会影响具体的执行过程。与上一节一样，我们将汇编代码的执行过程分成以下几个部分：</p><ol><li>初始化 <code>Cat</code> 结构体；</li><li>完成从 <code>Cat</code> 到 <code>Duck</code> 接口的类型转换；</li><li>调用接口的 <code>Quack</code> 方法；</li></ol><p>我们先来看一下上述汇编代码中用于初始化 <code>Cat</code> 结构体的部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XORPS   X0, X0                          ;; X0 = <span class="number">0</span></span><br><span class="line">MOVUPS  X0, <span class="string">""</span>..autotmp_1+<span class="number">32</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Data = <span class="number">0</span></span><br><span class="line">LEAQ    <span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"grooming"</span>(SB), AX    ;; AX = &amp;<span class="string">"grooming"</span></span><br><span class="line">MOVQ    AX, <span class="string">""</span>..autotmp_1+<span class="number">32</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Data = AX</span><br><span class="line">MOVQ    $<span class="number">8</span>, <span class="string">""</span>..autotmp_1+<span class="number">40</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Len =<span class="number">8</span></span><br></pre></td></tr></table></figure><p>这段汇编指令会在栈上初始化 <code>Cat</code> 结构体，而上一节的代码在堆上申请了 16 字节的内存空间，栈上只有一个指向 <code>Cat</code> 的指针。</p><p>初始化结构体后就进入类型转换的阶段，编译器会将 <code>go.itab.&quot;&quot;.Cat,&quot;&quot;.Duck</code> 的地址和指向 <code>Cat</code> 结构体的指针作为参数一并传入 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.convT2I</code></a> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEAQ<span class="keyword">go</span>.itab.<span class="string">""</span>.Cat,<span class="string">""</span>.Duck(SB), AX     ;; AX = &amp;(<span class="keyword">go</span>.itab.<span class="string">""</span>.Cat,<span class="string">""</span>.Duck)</span><br><span class="line">MOVQAX, (SP)                           ;; SP = AX</span><br><span class="line">LEAQ<span class="string">""</span>..autotmp_1+<span class="number">32</span>(SP), AX           ;; AX = &amp;(SP+<span class="number">32</span>) = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">MOVQAX, <span class="number">8</span>(SP)                          ;; SP + <span class="number">8</span> = AX</span><br><span class="line">CALLruntime.convT2I(SB)                ;; runtime.convT2I(SP, SP+<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>这个函数会获取 <code>itab</code> 中存储的类型，根据类型的大小申请一片内存空间并将 <code>elem</code> 指针中的内容拷贝到目标的内存空间中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">t := tab._type</span><br><span class="line">x := mallocgc(t.size, t, <span class="literal">true</span>)</span><br><span class="line">typedmemmove(t, x, elem)</span><br><span class="line">i.tab = tab</span><br><span class="line">i.data = x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.convT2I</code></a> 会返回一个 <code>iface</code> 结构体，其中包含 <code>itab</code> 指针和 <code>Cat</code> 变量。当前函数返回之后，<code>main</code> 函数的栈上会包含以下数据：</p><p><img alt="golang-struct-to-iface" data-src="https://img.draveness.me/golang-struct-to-iface.png"></p><p><strong>图 4-12 结构体到指针</strong></p><p>SP 和 SP+8 中存储的 <code>itab</code> 和 <code>Cat</code> 指针就是 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.convT2I</code></a> 函数的入参，这个函数的返回值位于 SP+16，是一个占 16 字节内存空间的 <code>iface</code> 结构体，SP+32 存储的就是在栈上的 <code>Cat</code> 结构体，它会在 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.convT2I</code></a> 执行的过程中拷贝到堆上。</p><p>在最后，我们会通过以下的指令调用 <code>Cat</code> 实现的接口方法 <code>Quack()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOVQ<span class="number">16</span>(SP), AX ;; AX = &amp;(<span class="keyword">go</span>.itab.<span class="string">""</span>.Cat,<span class="string">""</span>.Duck)</span><br><span class="line">MOVQ<span class="number">24</span>(SP), CX ;; CX = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">MOVQ<span class="number">24</span>(AX), AX ;; AX = AX.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQCX, (SP)   ;; SP = CX</span><br><span class="line">CALLAX         ;; CX.Quack()</span><br></pre></td></tr></table></figure><p>这几个汇编指令还是非常好理解的，<code>MOVQ 24(AX), AX</code> 是最关键的指令，它从 <code>itab</code> 结构体中取出 <code>Cat.Quack</code> 方法指针作为 <code>CALL</code> 指令调用时的参数。接口变量的第 24 字节是 <code>itab.fun</code> 数组开始的位置，由于 <code>Duck</code> 接口只包含一个方法，所以 <code>itab.fun[0]</code> 中存储的就是指向 <code>Quack</code> 方法的指针了。</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>上一节介绍是如何把具体类型转换成接口类型，而这一节介绍的是如何将一个接口类型转换成具体类型。本节会根据接口中是否存在方法分两种情况介绍类型断言的执行过程。</p><h3 id="非空接口"><a href="#非空接口" class="headerlink" title="非空接口"></a>非空接口</h3><p>首先分析接口中包含方法的情况，<code>Duck</code> 接口一个非空的接口，我们来分析从 <code>Duck</code> 转换回 <code>Cat</code> 结构体的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line"><span class="keyword">switch</span> c.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Cat:</span><br><span class="line">cat := c.(*Cat)</span><br><span class="line">cat.Quack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将编译得到的汇编指令分成两部分分析，第一部分是变量的初始化，第二部分是类型断言，第一部分的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000</span> TEXT<span class="string">""</span>.main(SB), ABIInternal, $<span class="number">32</span><span class="number">-0</span></span><br><span class="line">...</span><br><span class="line"><span class="number">00029</span> XORPSX0, X0</span><br><span class="line"><span class="number">00032</span> MOVUPSX0, <span class="string">""</span>..autotmp_4+<span class="number">8</span>(SP)</span><br><span class="line"><span class="number">00037</span> LEAQ<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"grooming"</span>(SB), AX</span><br><span class="line"><span class="number">00044</span> MOVQAX, <span class="string">""</span>..autotmp_4+<span class="number">8</span>(SP)</span><br><span class="line"><span class="number">00049</span> MOVQ$<span class="number">8</span>, <span class="string">""</span>..autotmp_4+<span class="number">16</span>(SP)</span><br></pre></td></tr></table></figure><p>0037 ~ 0049 三个指令初始化了 <code>Duck</code> 变量，<code>Cat</code> 结构体初始化在 SP+8 ~ SP+24 上。因为 Go 语言的编译器做了一些优化，所以代码中没有<code>iface</code> 的构建过程，不过对于这一节要介绍的类型断言和转换没有太多的影响。下面进入类型转换的部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00058</span> CMPL  <span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck+<span class="number">16</span>(SB), $<span class="number">593696792</span>  </span><br><span class="line">                                        ;; <span class="keyword">if</span> (c.tab.hash != <span class="number">593696792</span>) &#123;</span><br><span class="line"><span class="number">00068</span> JEQ   <span class="number">80</span>                          ;;      </span><br><span class="line"><span class="number">00070</span> MOVQ  <span class="number">24</span>(SP), BP                  ;;      BP = SP+<span class="number">24</span></span><br><span class="line"><span class="number">00075</span> ADDQ  $<span class="number">32</span>, SP                     ;;      SP += <span class="number">32</span></span><br><span class="line"><span class="number">00079</span> RET                               ;;      <span class="keyword">return</span></span><br><span class="line">                                        ;; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">00080</span> LEAQ  <span class="string">""</span>..autotmp_4+<span class="number">8</span>(SP), AX     ;;      AX = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line"><span class="number">00085</span> MOVQ  AX, (SP)                    ;;      SP = AX</span><br><span class="line"><span class="number">00089</span> CALL  <span class="string">""</span>.(*Cat).Quack(SB)         ;;      SP.Quack()</span><br><span class="line"><span class="number">00094</span> JMP   <span class="number">70</span>                          ;;      ...</span><br><span class="line">                                        ;;      BP = SP+<span class="number">24</span></span><br><span class="line">                                        ;;      SP += <span class="number">32</span></span><br><span class="line">                                        ;;      <span class="keyword">return</span></span><br><span class="line">                                        ;; &#125;</span><br></pre></td></tr></table></figure><p>switch语句生成的汇编指令会将目标类型的 <code>hash</code> 与接口变量中的 <code>itab.hash</code> 进行比较：</p><ul><li>如果两者相等意味着变量的具体类型是</li></ul>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cat</span></span><br></pre></td></tr></table></figure><p>  ，我们会跳转到 0080 所在的分支完成类型转换。</p><ol><li>获取 SP+8 存储的 <code>Cat</code> 结构体指针；</li><li>将结构体指针拷贝到栈顶；</li><li>调用 <code>Quack</code> 方法；</li><li>恢复函数的栈并返回；</li></ol><ul><li>如果接口中存在的具体类型不是 <code>Cat</code>，就会直接恢复栈指针并返回到调用方；</li></ul><p><img alt="golang-interface-to-struct" data-src="https://img.draveness.me/golang-interface-to-struct.png"></p><p><strong>图 4-13 接口转换成结构体</strong></p><p>上图展示了调用 <code>Quack</code> 方法时的堆栈情况，其中 <code>Cat</code> 结构体存储在 SP+8 ~ SP+24 上，<code>Cat</code> 指针存储在栈顶并指向上述结构体。</p><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>当我们使用空接口类型 <code>interface{}</code> 进行类型断言时，如果不关闭 Go 语言编译器的优化选项，生成的汇编指令是差不多的。编译器会省略将 <code>Cat</code> 结构体转换成 <code>eface</code> 的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line"><span class="keyword">switch</span> c.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Cat:</span><br><span class="line">cat := c.(*Cat)</span><br><span class="line">cat.Quack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果禁用编译器优化，上述代码会在类型断言时就不是直接获取变量中具体类型的 <code>_type</code>，而是从 <code>eface._type</code> 中获取，汇编指令仍然会使用目标类型的 <code>hash</code> 字段与变量的类型比较。</p><h2 id="动态派发"><a href="#动态派发" class="headerlink" title="动态派发"></a>动态派发</h2><p>动态派发（Dynamic dispatch）是在运行期间选择具体多态操作（方法或者函数）执行的过程，它是一种在面向对象语言中常见的特性<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:6" target="_blank" rel="external nofollow noopener noreferrer">6</a>。Go 语言虽然不是严格意义上的面向对象语言，但是接口的引入为它带来了动态派发这一特性，调用接口类型的方法时，如果编译期间不能确认接口的类型，Go 语言会在运行期间决定具体调用该方法的哪个实现。</p><p>在如下所示的代码中，<code>main</code> 函数调用了两次 <code>Quack</code> 方法：</p><ol><li>第一次以 <code>Duck</code> 接口类型的身份调用，调用时需要经过运行时的动态派发；</li><li>第二次以 <code>*Cat</code> 具体类型的身份调用，编译期就会确定调用的函数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">c.Quack()</span><br><span class="line">c.(*Cat).Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为编译器优化影响了我们对原始汇编指令的理解，所以需要使用编译参数 <code>-N</code> 关闭编译器优化。如果不指定这个参数，编译器会对代码进行重写，与最初生成的执行过程有一些偏差，例如：</p><ul><li>因为接口类型中的 <code>tab</code> 参数并没有被使用，所以优化从 <code>Cat</code> 转换到 <code>Duck</code> 的过程；</li><li>因为变量的具体类型是确定的，所以删除从 <code>Duck</code> 接口类型转换到 <code>*Cat</code> 具体类型时可能会发生 <code>panic</code> 的分支；</li><li>…</li></ul><p>在具体分析调用 <code>Quack</code> 方法的两种姿势之前，我们要先了解 <code>Cat</code> 结构体究竟是如何初始化的，以及初始化完成后的栈上有哪些数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LEAQ<span class="keyword">type</span>.<span class="string">""</span>.Cat(SB), AX                </span><br><span class="line">MOVQAX, (SP)</span><br><span class="line">CALLruntime.newobject(SB)              ;; SP + <span class="number">8</span> = <span class="built_in">new</span>(Cat)</span><br><span class="line">MOVQ<span class="number">8</span>(SP), DI                          ;; DI = SP + <span class="number">8</span></span><br><span class="line">MOVQDI, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(SP)           ;; SP + <span class="number">32</span> = DI</span><br><span class="line">MOVQ$<span class="number">8</span>, <span class="number">8</span>(DI)                          ;; StringHeader(cat).Len = <span class="number">8</span></span><br><span class="line">LEAQ<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"grooming"</span>(SB), AX       ;; AX = &amp;<span class="string">"grooming"</span></span><br><span class="line">MOVQAX, (DI)                           ;; StringHeader(cat).Data = AX</span><br><span class="line">MOVQ<span class="string">""</span>..autotmp_2+<span class="number">32</span>(SP), AX           ;; AX = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQAX, <span class="string">""</span>..autotmp_1+<span class="number">40</span>(SP)           ;; SP + <span class="number">40</span> = &amp;Cat&#123;...&#125;</span><br><span class="line">LEAQ<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck(SB), CX    ;; CX = &amp;<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck</span><br><span class="line">MOVQCX, <span class="string">""</span>.c+<span class="number">48</span>(SP)                    ;; iface(c).tab = SP + <span class="number">48</span> = CX</span><br><span class="line">MOVQAX, <span class="string">""</span>.c+<span class="number">56</span>(SP)                    ;; iface(c).data = SP + <span class="number">56</span> = AX</span><br></pre></td></tr></table></figure><p>这段代码的初始化过程其实和上两节中的过程没有太多的差别，它先初始化了 <code>Cat</code> 结构体指针，再将 <code>Cat</code> 和 <code>tab</code> 打包成了一个 <code>iface</code> 类型的结构体，我们直接来看初始化结束后的栈情况：</p><p><img alt="stack-after-initialize" data-src="https://img.draveness.me/stack-after-initialize.png"></p><p><strong>图 4-14 接口类型初始化后的栈</strong></p><ul><li>SP 是 <code>Cat</code> 类型，它也是运行时 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 方法的参数；</li><li>SP+8 是 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 方法的返回值，也就是指向堆上的 <code>Cat</code> 结构体的指针；</li><li>SP+32、SP+40 是对 SP+8 的拷贝，这两个指针都会指向栈上的 <code>Cat</code> 结构体；</li><li>SP+48 ~ SP+64 是接口变量 <code>iface</code> 结构体，其中包含了 <code>tab</code> 结构体指针和 <code>*Cat</code> 指针；</li></ul><p>初始化过程结束之后，我们进入到了动态派发的过程，<code>c.Quack()</code> 语句展开的汇编指令会在运行时确定函数指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOVQ<span class="string">""</span>.c+<span class="number">48</span>(SP), AX                    ;; AX = iface(c).tab</span><br><span class="line">MOVQ<span class="number">24</span>(AX), AX                         ;; AX = iface(c).tab.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQ<span class="string">""</span>.c+<span class="number">56</span>(SP), CX                    ;; CX = iface(c).data</span><br><span class="line">MOVQCX, (SP)                           ;; SP = CX = &amp;Cat&#123;...&#125;</span><br><span class="line">CALLAX                                 ;; SP.Quack()</span><br></pre></td></tr></table></figure><p>这段代码的执行过程可以分成以下三个步骤：</p><ol><li>从接口变量中获取了保存 <code>Cat.Quack</code> 方法指针的 <code>tab.func[0]</code>；</li><li>接口变量在中的数据会被拷贝到栈顶；</li><li>方法指针会被拷贝到寄存器中并通过汇编指令 <code>CALL</code> 触发：</li></ol><p>另一个调用 <code>Quack</code> 方法的语句 <code>c.(*Cat).Quack()</code> 生成的汇编指令看起来会有一些复杂，但是代码前半部分都是在做类型转换，将接口类型转换成 <code>*Cat</code> 类型，只有最后两行代码才是函数调用相关的指令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOVQ<span class="string">""</span>.c+<span class="number">56</span>(SP), AX                    ;; AX = iface(c).data = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQ<span class="string">""</span>.c+<span class="number">48</span>(SP), CX                    ;; CX = iface(c).tab</span><br><span class="line">LEAQ<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck(SB), DX    ;; DX = &amp;&amp;<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck</span><br><span class="line">CMPQCX, DX                             ;; CMP(CX, DX)</span><br><span class="line">JEQ<span class="number">163</span></span><br><span class="line">JMP<span class="number">201</span></span><br><span class="line">MOVQAX, <span class="string">""</span>..autotmp_3+<span class="number">24</span>(SP)           ;; SP+<span class="number">24</span> = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQAX, (SP)                           ;; SP = &amp;Cat&#123;...&#125;</span><br><span class="line">CALL<span class="string">""</span>.(*Cat).Quack(SB)                ;; SP.Quack()</span><br></pre></td></tr></table></figure><p>下面的几行代码只是将 <code>Cat</code> 指针拷贝到了栈顶并调用 <code>Quack</code> 方法。这一次调用的函数指针在编译期就已经确定了，所以运行时就不需要动态查找方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVQ<span class="string">""</span>.c+<span class="number">48</span>(SP), AX                    ;; AX = iface(c).tab</span><br><span class="line">MOVQ<span class="number">24</span>(AX), AX                         ;; AX = iface(c).tab.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQ<span class="string">""</span>.c+<span class="number">56</span>(SP), CX                    ;; CX = iface(c).data</span><br></pre></td></tr></table></figure><p>两次方法调用对应的汇编指令差异就是动态派发带来的额外开销，这些额外开销在有低延时、高吞吐量需求的服务中是不能被忽视的，我们来详细分析一下产生的额外汇编指令对性能造成的影响。</p><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>下面代码中的两个方法 <code>BenchmarkDirectCall</code> 和 <code>BenchmarkDynamicDispatch</code> 分别会调用结构体方法和接口方法，在接口上调用方法时会使用动态派发机制，我们以直接调用作为基准分析动态派发带来了多少额外开销：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDirectCall</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">c := &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line"><span class="comment">// MOVQAX, "".c+24(SP)</span></span><br><span class="line"><span class="comment">// MOVQAX, (SP)</span></span><br><span class="line"><span class="comment">// CALL"".(*Cat).Quack(SB)</span></span><br><span class="line">c.Quack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDynamicDispatch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">c := Duck(&amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line"><span class="comment">// MOVQ"".d+56(SP), AX</span></span><br><span class="line"><span class="comment">// MOVQ24(AX), AX</span></span><br><span class="line"><span class="comment">// MOVQ"".d+64(SP), CX</span></span><br><span class="line"><span class="comment">// MOVQCX, (SP)</span></span><br><span class="line"><span class="comment">// CALLAX</span></span><br><span class="line">c.Quack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接运行下面的命令，使用 1 个 CPU 运行上述代码，每一个基准测试都会被执行 3 次：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -gcflags=-N -benchmem -test.count=<span class="number">3</span> -test.cpu=<span class="number">1</span> -test.benchtime=<span class="number">1</span>s -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/golang/playground</span><br><span class="line">BenchmarkDirectCall      <span class="number">500000000</span>         <span class="number">3.11</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      <span class="number">500000000</span>         <span class="number">2.94</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      <span class="number">500000000</span>         <span class="number">3.04</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch <span class="number">500000000</span>         <span class="number">3.40</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch <span class="number">500000000</span>         <span class="number">3.79</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch <span class="number">500000000</span>         <span class="number">3.55</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure><ul><li>调用结构体方法时，每一次调用需要 <code>~3.03ns</code>；</li><li>使用动态派发时，每一调用需要 <code>~3.58ns</code>；</li></ul><p>在关闭编译器优化的情况下，从上面的数据来看，动态派发生成的指令会带来 <code>~18%</code> 左右的额外性能开销。</p><p>这些性能开销在一个复杂的系统中不会带来太多的影响。一个项目不可能只使用动态派发，而且如果我们开启编译器优化后，动态派发的额外开销会降低至 <code>~5%</code>，这对应用性能的整体影响就更小了，所以与使用接口带来的好处相比，动态派发的额外开销往往可以忽略。</p><p>上面的性能测试建立在实现和调用方法的都是结构体指针上，当我们将结构体指针换成结构体又会有比较大的差异：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDirectCall</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">c := Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line"><span class="comment">// MOVQAX, (SP)</span></span><br><span class="line"><span class="comment">// MOVQ$8, 8(SP)</span></span><br><span class="line"><span class="comment">// CALL"".Cat.Quack(SB)</span></span><br><span class="line">c.Quack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDynamicDispatch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">c := Duck(Cat&#123;Name: <span class="string">"grooming"</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line"><span class="comment">// MOVQ16(SP), AX</span></span><br><span class="line"><span class="comment">// MOVQ24(SP), CX</span></span><br><span class="line"><span class="comment">// MOVQAX, "".d+32(SP)</span></span><br><span class="line"><span class="comment">// MOVQCX, "".d+40(SP)</span></span><br><span class="line"><span class="comment">// MOVQ"".d+32(SP), AX</span></span><br><span class="line"><span class="comment">// MOVQ24(AX), AX</span></span><br><span class="line"><span class="comment">// MOVQ"".d+40(SP), CX</span></span><br><span class="line"><span class="comment">// MOVQCX, (SP)</span></span><br><span class="line"><span class="comment">// CALLAX</span></span><br><span class="line">c.Quack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重新执行相同的基准测试时，会得到如下所示的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -gcflags=-N -benchmem -test.count=<span class="number">3</span> -test.cpu=<span class="number">1</span> -test.benchtime=<span class="number">1</span>s .</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/golang/playground</span><br><span class="line">BenchmarkDirectCall      <span class="number">500000000</span>         <span class="number">3.15</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      <span class="number">500000000</span>         <span class="number">3.02</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      <span class="number">500000000</span>         <span class="number">3.09</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch <span class="number">200000000</span>         <span class="number">6.92</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch <span class="number">200000000</span>         <span class="number">6.91</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch <span class="number">200000000</span>         <span class="number">7.10</span> ns/op       <span class="number">0</span> B/op       <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure><p>直接调用方法需要消耗时间的平均值和使用指针实现接口时差不多，约为 <code>~3.09ns</code>，而使用动态派发调用方法却需要 <code>~6.98ns</code> 相比直接调用额外消耗了 <code>~125%</code> 的时间，从生成的汇编指令我们也能看出后者的额外开销会高很多。</p><div class="table-container"><table><thead><tr><th></th><th>直接调用</th><th>动态派发</th></tr></thead><tbody><tr><td>指针</td><td>~3.03ns</td><td>~3.58ns</td></tr><tr><td>结构体</td><td>~3.09ns</td><td>~6.98ns</td></tr></tbody></table></div><p>从上述表格我们可以看到使用结构体来实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口。</p><p>使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要因为 Go 语言在函数调用时是传值的，动态派发的过程只是放大了参数拷贝带来的影响。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>重新回顾一下本节介绍的内容，我们在开头简单介绍了使用 Go 语言接口的常见问题，例如使用不同类型实现接口带来的差异、函数调用时发生的隐式类型转换；我们还分析了接口的类型转换、类型断言以及动态派发机制。相信这一节中内容能够帮助各位读者深入理解 Go 语言的接口。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://www.tapirgames.com/blog/golang-interface-implementation" target="_blank" rel="external nofollow noopener noreferrer">How Interfaces Work in Go</a></li><li><a href="https://golang.org/doc/effective_go.html#interfaces_and_types" target="_blank" rel="external nofollow noopener noreferrer">Interfaces and other types · Effective Go</a></li><li><a href="https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go" target="_blank" rel="external nofollow noopener noreferrer">How to use interfaces in Go</a></li><li><a href="https://research.swtch.com/interfaces" target="_blank" rel="external nofollow noopener noreferrer">Go Data Structures: Interfaces</a></li><li><a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="external nofollow noopener noreferrer">Duck typing · Wikipedia</a></li><li><a href="http://www.robelle.com/smugbook/posix.html" target="_blank" rel="external nofollow noopener noreferrer">What is POSIX?</a></li><li><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="external nofollow noopener noreferrer">Chapter II: Interfaces</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言中的接口就是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们更好地组织并写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也不清楚其底层的实现原理，这成为了开发高性能服务的最大阻碍。&lt;/p&gt;
&lt;p&gt;本节会介绍使用接口时遇到的一些常见问题以及它的设计与实现，包括接口的类型转换、类型断言以及动态派发机制，帮助各位读者更好地理解接口类型。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="interface" scheme="http://houmin.cc/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Function</title>
    <link href="http://houmin.cc/posts/4e214fa9/"/>
    <id>http://houmin.cc/posts/4e214fa9/</id>
    <published>2020-07-27T04:13:59.000Z</published>
    <updated>2020-08-30T09:35:05.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>函数是 Go 语言中的一等公民，理解和掌握函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数的传递方法两个方面分别介绍函数的执行过程。</p><a id="more"></a><h2 id="调用惯例"><a href="#调用惯例" class="headerlink" title="调用惯例"></a>调用惯例</h2><p>无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">somefunction(arg0, arg1)</span><br></pre></td></tr></table></figure><p>虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。调用惯例是调用方和被调用方对于参数和返回值传递的约定，我们将在这里为各位读者分别介绍 C 和 Go 语言的调用惯例。</p><h3 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h3><p>我们先来研究 C 语言的调用惯例，使用 <a href="https://gcc.gnu.org/" target="_blank" rel="external nofollow noopener noreferrer">GCC</a><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a> 和 <a href="https://clang.llvm.org/" target="_blank" rel="external nofollow noopener noreferrer">Clang</a><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a> 编译器将 C 语言编译成汇编代码是分析它调用惯例的最好方法，从汇编语言中可以一窥函数调用的具体过程。</p><p>GCC 和 Clang 编译相同 C 语言代码可能会生成不同的汇编指令，不过生成的代码在结构上不会有太大的区别，所以对只想理解调用惯例的人来说没有太多影响。作者在本节中选择使用 GCC 编译器来编译 C 语言：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc --version</span><br><span class="line">gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>假设我们有以下的 C 语言代码，代码中只包含两个函数，其中一个是主函数 <code>main</code>，另一个是我们定义的函数 <code>my_function</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ch04/my_function.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_function</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = my_function(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>cc -S my_function.c</code> 命令将上述文件编译成如下所示的汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">subq$<span class="number">16</span>, %rsp</span><br><span class="line">movl$<span class="number">2</span>, %esi  <span class="comment">// 设置第二个参数</span></span><br><span class="line">movl$<span class="number">1</span>, %edi  <span class="comment">// 设置第一个参数</span></span><br><span class="line">callmy_function</span><br><span class="line">movl%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">my_function:</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">movl%edi, <span class="number">-4</span>(%rbp)    <span class="comment">// 取出第一个参数，放到栈上</span></span><br><span class="line">movl%esi, <span class="number">-8</span>(%rbp)    <span class="comment">// 取出第二个参数，放到栈上</span></span><br><span class="line">movl<span class="number">-8</span>(%rbp), %eax    <span class="comment">// eax = esi = 1</span></span><br><span class="line">movl<span class="number">-4</span>(%rbp), %edx    <span class="comment">// edx = edi = 2</span></span><br><span class="line">addl%edx, %eax        <span class="comment">// eax = eax + edx = 1 + 2 = 3</span></span><br><span class="line">popq%rbp</span><br></pre></td></tr></table></figure><p>我们按照 <code>my_function</code> 函数调用前、调用时以及调用后三个部分分析上述调用过程：</p><ul><li>在 <code>my_function</code> 调用之前，调用方 <code>main</code> 函数将 <code>my_function</code> 的两个参数分别存到 edi 和 esi 寄存器中；</li><li>在 <code>my_function</code> 执行时，它会将寄存器 edi 和 esi 中的数据存储到 eax 和 edx 两个寄存器中，随后通过汇编指令 <code>addl</code> 计算两个入参之和；</li><li>在 <code>my_function</code> 调用之后，使用寄存器 eax 传递返回值，<code>main</code> 函数将 <code>my_function</code> 的返回值存储到栈上的 <code>i</code> 变量中；</li></ul><p>当 <code>my_function</code> 函数的入参增加至八个，这时重新编译当前的程序可以会得到不同的汇编语言：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">subq$<span class="number">16</span>, %rsp     <span class="comment">// 为参数传递申请 16 字节的栈空间</span></span><br><span class="line">movl$<span class="number">8</span>, <span class="number">8</span>(%rsp)   <span class="comment">// 传递第 8 个参数</span></span><br><span class="line">movl$<span class="number">7</span>, (%rsp)    <span class="comment">// 传递第 7 个参数</span></span><br><span class="line">movl$<span class="number">6</span>, %r9d</span><br><span class="line">movl$<span class="number">5</span>, %r8d</span><br><span class="line">movl$<span class="number">4</span>, %ecx</span><br><span class="line">movl$<span class="number">3</span>, %edx</span><br><span class="line">movl$<span class="number">2</span>, %esi</span><br><span class="line">movl$<span class="number">1</span>, %edi</span><br><span class="line">callmy_function</span><br></pre></td></tr></table></figure><p><code>main</code> 函数调用 <code>my_function</code> 时，前六个参数是使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递的。寄存器的使用顺序也是调用惯例的一部分，函数的第一个参数一定会使用 edi 寄存器，第二个参数使用 esi 寄存器，以此类推。</p><p>最后的两个参数与前面的完全不同，调用方 <code>main</code> 函数通过传递这两个参数，图 4-1 展示了 <code>main</code> 函数在调用 <code>my_function</code> 前的栈信息：</p><p><img alt="c-function-call-stack" data-src="https://img.draveness.me/2019-01-20-c-function-call-stack.png"></p><p><strong>图 4-1 C 语言 main 函数的调用栈</strong></p><p>上图中 rbp 寄存器的作用是存储函数调用栈的基址指针，即属于 <code>main</code> 函数的栈空间的起始位置，而另一个寄存器 rsp 存储的是 <code>main</code> 函数调用栈结束的位置，这两个寄存器共同表示了一个函数的栈空间。</p><p>在调用 <code>my_function</code> 之前，<code>main</code> 函数通过 <code>subq $16, %rsp</code> 指令分配了 16 个字节的栈地址，随后将第六个以上的参数按照从右到左的顺序存入栈中，即第八个和第七个，余下的六个参数会通过寄存器传递，接下来运行的 <code>call my_function</code> 指令会调用 <code>my_function</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">my_function:</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">movl%edi, <span class="number">-4</span>(%rbp)    <span class="comment">// rbp-4 = edi = 1</span></span><br><span class="line">movl%esi, <span class="number">-8</span>(%rbp)    <span class="comment">// rbp-8 = esi = 2</span></span><br><span class="line">...</span><br><span class="line">movl<span class="number">-8</span>(%rbp), %eax    <span class="comment">// eax = 2</span></span><br><span class="line">movl<span class="number">-4</span>(%rbp), %edx    <span class="comment">// edx = 1</span></span><br><span class="line">addl%eax, %edx        <span class="comment">// edx = eax + edx = 3</span></span><br><span class="line">...</span><br><span class="line">movl<span class="number">16</span>(%rbp), %eax    <span class="comment">// eax = 7</span></span><br><span class="line">addl%eax, %edx        <span class="comment">// edx = eax + edx = 28</span></span><br><span class="line">movl<span class="number">24</span>(%rbp), %eax    <span class="comment">// eax = 8</span></span><br><span class="line">addl%edx, %eax        <span class="comment">// edx = eax + edx = 36</span></span><br><span class="line">popq%rbp</span><br></pre></td></tr></table></figure><p><code>my_function</code> 会先将寄存器中的全部数据转移到栈上，然后利用 eax 寄存器计算所有入参的和并返回结果。</p><p>我们可以将本节的发现和分析简单总结成 —— 当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：</p><ul><li>六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；</li><li>六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；</li></ul><p>而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。</p><h3 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h3><p>分析了 C 语言函数的调用惯例之后，我们再来剖析一下 Go 语言中函数的调用惯例。我们以下面这个非常简单的代码片段为例简要分析一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b, a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">myFunction(<span class="number">66</span>, <span class="number">77</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的 <code>myFunction</code> 函数接受两个整数并返回两个整数，<code>main</code> 函数在调用 <code>myFunction</code> 时将 66 和 77 两个参数传递到当前函数中，使用 <code>go tool compile -S -N -l main.go</code> 命令编译上述代码可以得到如下所示的汇编指令：</p><blockquote><p>注：如果编译时不使用 -N -l 参数，编译器会对汇编代码进行优化，编译结果会有较大差别。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">68</span> args=<span class="number">0x0</span> locals=<span class="number">0x28</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)MOVQ(TLS), CX</span><br><span class="line"><span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)CMPQSP, <span class="number">16</span>(CX)</span><br><span class="line"><span class="number">0x000d</span> <span class="number">00013</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)JLS<span class="number">61</span></span><br><span class="line"><span class="number">0x000f</span> <span class="number">00015</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)SUBQ$<span class="number">40</span>, SP      <span class="comment">// 分配 40 字节栈空间</span></span><br><span class="line"><span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)MOVQBP, <span class="number">32</span>(SP)   <span class="comment">// 将基址指针存储到栈上</span></span><br><span class="line"><span class="number">0x0018</span> <span class="number">00024</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)LEAQ<span class="number">32</span>(SP), BP</span><br><span class="line"><span class="number">0x001d</span> <span class="number">00029</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)MOVQ$<span class="number">66</span>, (SP)    <span class="comment">// 第一个参数</span></span><br><span class="line"><span class="number">0x0025</span> <span class="number">00037</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)MOVQ$<span class="number">77</span>, <span class="number">8</span>(SP)   <span class="comment">// 第二个参数</span></span><br><span class="line"><span class="number">0x002e</span> <span class="number">00046</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)CALL<span class="string">""</span>.myFunction(SB)</span><br><span class="line"><span class="number">0x0033</span> <span class="number">00051</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)MOVQ<span class="number">32</span>(SP), BP</span><br><span class="line"><span class="number">0x0038</span> <span class="number">00056</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)ADDQ$<span class="number">40</span>, SP</span><br><span class="line"><span class="number">0x003c</span> <span class="number">00060</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)RET</span><br></pre></td></tr></table></figure><p>根据 <code>main</code> 函数生成的汇编指令，我们可以分析出 <code>main</code> 函数调用 <code>myFunction</code> 之前的栈情况：</p><p><img alt="golang-function-call-stack-before-calling" data-src="https://img.draveness.me/2019-01-20-golang-function-call-stack-before-calling.png"></p><p><strong>图 4-2 Go 语言 main 函数的调用栈</strong></p><p><code>main</code> 函数通过 <code>SUBQ $40, SP</code> 指令一共在栈上分配了 40 字节的内存空间：</p><div class="table-container"><table><thead><tr><th>空间</th><th>大小</th><th>作用</th></tr></thead><tbody><tr><td>SP+32 ~ BP</td><td>8 字节</td><td><code>main</code> 函数的栈基址指针</td></tr><tr><td>SP+16 ~ SP+32</td><td>16 字节</td><td>函数 <code>myFunction</code> 的两个返回值</td></tr><tr><td>SP ~ SP+16</td><td>16 字节</td><td>函数 <code>myFunction</code> 的两个参数</td></tr></tbody></table></div><p><code>myFunction</code> 入参的压栈顺序和 C 语言一样，都是从右到左，即第一个参数 66 在栈顶的 SP ~ SP+8，第二个参数存储在 SP+8 ~ SP+16 的空间中。</p><p>当我们准备好函数的入参之后，会调用汇编指令 <code>CALL &quot;&quot;.myFunction(SB)</code>，这个指令首先会将 <code>main</code> 的返回地址存入栈中，然后改变当前的栈指针 SP 并开始执行 <code>myFunction</code> 的汇编指令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.myFunction STEXT nosplit size=<span class="number">49</span> args=<span class="number">0x20</span> locals=<span class="number">0x0</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)MOVQ$<span class="number">0</span>, <span class="string">""</span>.~r2+<span class="number">24</span>(SP) <span class="comment">// 初始化第一个返回值</span></span><br><span class="line"><span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)MOVQ$<span class="number">0</span>, <span class="string">""</span>.~r3+<span class="number">32</span>(SP) <span class="comment">// 初始化第二个返回值</span></span><br><span class="line"><span class="number">0x0012</span> <span class="number">00018</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVQ<span class="string">""</span>.a+<span class="number">8</span>(SP), AX    <span class="comment">// AX = 66</span></span><br><span class="line"><span class="number">0x0017</span> <span class="number">00023</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)ADDQ<span class="string">""</span>.b+<span class="number">16</span>(SP), AX   <span class="comment">// AX = AX + 77 = 143</span></span><br><span class="line"><span class="number">0x001c</span> <span class="number">00028</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVQAX, <span class="string">""</span>.~r2+<span class="number">24</span>(SP) <span class="comment">// (24)SP = AX = 143</span></span><br><span class="line"><span class="number">0x0021</span> <span class="number">00033</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVQ<span class="string">""</span>.a+<span class="number">8</span>(SP), AX    <span class="comment">// AX = 66</span></span><br><span class="line"><span class="number">0x0026</span> <span class="number">00038</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)SUBQ<span class="string">""</span>.b+<span class="number">16</span>(SP), AX   <span class="comment">// AX = AX - 77 = -11</span></span><br><span class="line"><span class="number">0x002b</span> <span class="number">00043</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)MOVQAX, <span class="string">""</span>.~r3+<span class="number">32</span>(SP) <span class="comment">// (32)SP = AX = -11</span></span><br><span class="line"><span class="number">0x0030</span> <span class="number">00048</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)RET</span><br></pre></td></tr></table></figure><p>从上述的汇编代码中我们可以看出，当前函数在执行时首先会将 <code>main</code> 函数中预留的两个返回值地址置成 <code>int</code> 类型的默认值 0，然后根据栈的相对位置获取参数并进行加减操作并将值存回栈中，在 <code>myFunction</code> 函数返回之间，栈中的数据如图 4-3 所示：</p><p><img alt="golang-function-call-stack-before-return" data-src="https://img.draveness.me/2019-01-20-golang-function-call-stack-before-return.png"></p><p><strong>图 4-3 myFunction 函数返回前的栈</strong></p><p>在 <code>myFunction</code> 返回之后，<code>main</code> 函数会通过以下的指令来恢复栈基址指针并销毁已经失去作用的 40 字节的栈空间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0033</span> <span class="number">00051</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)    MOVQ    <span class="number">32</span>(SP), BP</span><br><span class="line"><span class="number">0x0038</span> <span class="number">00056</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)    ADDQ    $<span class="number">40</span>, SP</span><br><span class="line"><span class="number">0x003c</span> <span class="number">00060</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)    RET</span><br></pre></td></tr></table></figure><p>通过分析 Go 语言编译后的汇编指令，我们发现 Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>C 语言和 Go 语言在设计函数的调用惯例时选择也不同的实现。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。我们可以对比一下这两种设计的优点和缺点：</p><ul><li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；<ul><li>CPU 访问栈的开销比访问寄存器高几十倍<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>；</li><li>需要单独处理函数参数过多的情况；</li></ul></li><li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；<ul><li>不需要考虑超过寄存器数量的参数应该如何传递；</li><li>不需要考虑不同架构上的寄存器差异；</li><li>函数入参和出参的内存空间需要在栈上进行分配；</li></ul></li></ul><p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>除了函数的调用惯例之外，Go 语言在传递参数时是传值还是传引用也是一个有趣的问题，这个问题影响的是当我们在函数中对入参进行修改时会不会影响调用方看到的数据。我们先来介绍一下传值和传引用两者的区别：</p><ul><li>传值：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；</li><li>传引用：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。</li></ul><p>不同语言会选择不同的方式传递参数，Go 语言选择了传值的方式，<strong>无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong>。本节剩下的内容将会验证这个结论的正确性。</p><h3 id="整型和数组"><a href="#整型和数组" class="headerlink" title="整型和数组"></a>整型和数组</h3><p>我们先来分析 Go 语言是如何传递基本类型和数组的。如下所示的函数 <code>myFunction</code> 接收了两个参数，整型变量 <code>i</code> 和数组 <code>arr</code>，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 <code>myFunction</code> 函数调用前后分别打印两个参数的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(i <span class="keyword">int</span>, arr [2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"in my_funciton - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">30</span></span><br><span class="line">arr := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">66</span>, <span class="number">77</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"before calling - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)</span><br><span class="line">myFunction(i, arr)</span><br><span class="line">fmt.Printf(<span class="string">"after  calling - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">before calling - i=(<span class="number">30</span>, <span class="number">0xc00009a000</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc00009a010</span>)</span><br><span class="line">in my_funciton - i=(<span class="number">30</span>, <span class="number">0xc00009a008</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc00009a020</span>)</span><br><span class="line">after  calling - i=(<span class="number">30</span>, <span class="number">0xc00009a000</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc00009a010</span>)</span><br></pre></td></tr></table></figure><p>当我们通过命令运行这段代码我们会发现，<code>main</code> 函数和被调用者 <code>myFunction</code> 中参数的地址是完全不同的。</p><p>不过从 <code>main</code> 函数的角度来看，在调用 <code>myFunction</code> 前后，整数 <code>i</code> 和数组 <code>arr</code> 两个参数的地址都没有变化。那么如果我们在 <code>myFunction</code> 函数内部对参数进行修改是否会影响 <code>main</code> 函数中的变量呢？我们更新 <code>myFunction</code> 函数并重新执行这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(i <span class="keyword">int</span>, arr [2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i = <span class="number">29</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">88</span></span><br><span class="line">fmt.Printf(<span class="string">"in my_funciton - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">before calling - i=(<span class="number">30</span>, <span class="number">0xc000072008</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc000072010</span>)</span><br><span class="line">in my_funciton - i=(<span class="number">29</span>, <span class="number">0xc000072028</span>) arr=([<span class="number">66</span> <span class="number">88</span>], <span class="number">0xc000072040</span>)</span><br><span class="line">after  calling - i=(<span class="number">30</span>, <span class="number">0xc000072008</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc000072010</span>)</span><br></pre></td></tr></table></figure><p>你可以看到在 <code>myFunction</code> 中对参数的修改也仅仅影响了当前函数，并没有影响调用方 <code>main</code> 函数，所以我们能给出如下的结论 - <strong>Go 语言中对于整型和数组类型的参数都是值传递的</strong>，也就是在调用函数时会对内容进行拷贝，需要注意的是如果当前数组的大小非常的大，这种传值方式就会对性能造成比较大的影响。</p><h3 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h3><p>接下来我们继续分析 Go 语言另外两种常见类型 —— 结构体和指针。在这段代码中定义一个只包含一个成员变量的简单结构体 <code>MyStruct</code> 以及接受两个参数的 <code>myFunction</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(a MyStruct, b *MyStruct)</span></span> &#123;</span><br><span class="line">a.i = <span class="number">31</span></span><br><span class="line">b.i = <span class="number">41</span></span><br><span class="line">fmt.Printf(<span class="string">"in my_function - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := MyStruct&#123;i: <span class="number">30</span>&#125;</span><br><span class="line">b := &amp;MyStruct&#123;i: <span class="number">40</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"before calling - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">myFunction(a, b)</span><br><span class="line">fmt.Printf(<span class="string">"after calling  - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">before calling - a=(&#123;<span class="number">30</span>&#125;, <span class="number">0xc000018178</span>) b=(&amp;&#123;<span class="number">40</span>&#125;, <span class="number">0xc00000c028</span>)</span><br><span class="line">in my_function - a=(&#123;<span class="number">31</span>&#125;, <span class="number">0xc000018198</span>) b=(&amp;&#123;<span class="number">41</span>&#125;, <span class="number">0xc00000c038</span>)</span><br><span class="line">after calling  - a=(&#123;<span class="number">30</span>&#125;, <span class="number">0xc000018178</span>) b=(&amp;&#123;<span class="number">41</span>&#125;, <span class="number">0xc00000c028</span>)</span><br></pre></td></tr></table></figure><p>从运行的结果我们可以得出如下结论：</p><ul><li>传递结构体时：会对结构体中的全部内容进行拷贝；</li><li>传递结构体指针时：会对结构体指针进行拷贝；</li></ul><p>对结构体指针的修改是改变了指针指向的结构体，<code>b.i</code> 可以被理解成 <code>(*b).i</code>，也就是我们先获取指针 <code>b</code> 背后的结构体，再修改结构体的成员变量。我们简单修改上述代码，分析一下 Go 语言结构体在内存中的布局：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="keyword">int</span></span><br><span class="line">j <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(ms *MyStruct)</span></span> &#123;</span><br><span class="line">ptr := unsafe.Pointer(ms)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">c := (*<span class="keyword">int</span>)(unsafe.Pointer((<span class="keyword">uintptr</span>(ptr) + <span class="keyword">uintptr</span>(<span class="number">8</span>*i))))</span><br><span class="line">*c += i + <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">"[%p] %d\n"</span>, c, *c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := &amp;MyStruct&#123;i: <span class="number">40</span>, j: <span class="number">50</span>&#125;</span><br><span class="line">myFunction(a)</span><br><span class="line">fmt.Printf(<span class="string">"[%p] %v\n"</span>, a, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">[<span class="number">0xc000018180</span>] <span class="number">41</span></span><br><span class="line">[<span class="number">0xc000018188</span>] <span class="number">52</span></span><br><span class="line">[<span class="number">0xc000018180</span>] &amp;&#123;<span class="number">41</span> <span class="number">52</span>&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们通过指针的方式修改结构体中的成员变量，结构体在内存中是一片连续的空间，指向结构体的指针也是指向这个结构体的首地址。将 <code>MyStruct</code> 指针修改成 <code>int</code> 类型的，那么访问新指针就会返回整型变量 <code>i</code>，将指针移动 8 个字节之后就能获取下一个成员变量 <code>j</code>。</p><p>如果我们将上述代码简化成如下所示的代码片段并使用 <code>go tool compile</code> 进行编译会得到如下的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="keyword">int</span></span><br><span class="line">j <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(ms *MyStruct)</span> *<span class="title">MyStruct</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> tool compile -S -N -l main.<span class="keyword">go</span></span><br><span class="line"><span class="string">""</span>.myFunction STEXT nosplit size=<span class="number">20</span> args=<span class="number">0x10</span> locals=<span class="number">0x0</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)MOVQ$<span class="number">0</span>, <span class="string">""</span>.~r1+<span class="number">16</span>(SP) <span class="comment">// 初始化返回值</span></span><br><span class="line"><span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)MOVQ<span class="string">""</span>.ms+<span class="number">8</span>(SP), AX   <span class="comment">// 复制引用</span></span><br><span class="line"><span class="number">0x000e</span> <span class="number">00014</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)MOVQAX, <span class="string">""</span>.~r1+<span class="number">16</span>(SP) <span class="comment">// 返回引用</span></span><br><span class="line"><span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)RET</span><br></pre></td></tr></table></figure><p>在这段汇编语言中我们发现当参数是指针时，也会使用 <code>MOVQ &quot;&quot;.ms+8(SP), AX</code> 指令对引用进行复制，然后将复制后的指针作为返回值传递回调用方。</p><p><img alt="golang-pointer-as-argument" data-src="https://img.draveness.me/2019-01-21-golang-pointer-as-argument.png"></p><p><strong>图 4-4 Go 语言指针参数</strong></p><p>所以将指针作为参数传入某一个函数时，在函数内部会对指针进行复制，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中『传指针』也是传值。</p><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><p>当我们对 Go 语言中大多数常见的数据结构进行验证之后，其实就能够推测出 Go 语言在传递参数时其实使用的就是传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们在一些函数中应该尽量使用指针作为参数类型来避免发生大量数据的拷贝而影响性能。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一节我们详细分析了 Go 语言的调用惯例，包括传递参数和返回值的过程和原理。Go 通过栈传递函数的参数和返回值，在调用函数之前会在栈上为返回值分配合适的内存空间，随后将入参从右到左按顺序压栈并拷贝参数，返回值会被存储到调用方预留好的栈空间上，我们可以简单总结出以下几条规则：</p><ol><li>通过堆栈传递参数，入栈的顺序是从右到左；</li><li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li><li>调用函数时都是传值，接收方会对入参进行复制再计算；</li></ol><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html" target="_blank" rel="external nofollow noopener noreferrer">The Function Stack</a></li><li><a href="https://stackoverflow.com/questions/16453314/why-do-byte-spills-occur-and-what-do-they-achieve" target="_blank" rel="external nofollow noopener noreferrer">Why do byte spills occur and what do they achieve?</a></li><li><a href="https://mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external nofollow noopener noreferrer">Friday Q&amp;A 2011-12-16: Disassembling the Assembly, Part 1</a></li><li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="external nofollow noopener noreferrer">x86 calling conventions</a></li><li><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="external nofollow noopener noreferrer">Call Stack</a></li><li><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter1_assembly_primer/README.md" target="_blank" rel="external nofollow noopener noreferrer">Chapter I: A Primer on Go Assembly</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数是 Go 语言中的一等公民，理解和掌握函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数的传递方法两个方面分别介绍函数的执行过程。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="function" scheme="http://houmin.cc/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>【下厨房】电饭锅焖鸡腿</title>
    <link href="http://houmin.cc/posts/45418583/"/>
    <id>http://houmin.cc/posts/45418583/</id>
    <published>2020-07-26T14:23:43.000Z</published>
    <updated>2020-08-21T08:11:30.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「吃顿好的」第一道菜，【快手菜】电饭锅焖鸡腿。</p><a id="more"></a><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><div class="table-container"><table><thead><tr><th>原料</th><th>分量</th></tr></thead><tbody><tr><td>鸡腿</td><td>5只</td></tr><tr><td>洋葱</td><td>半只</td></tr><tr><td>姜</td><td>3片</td></tr><tr><td>水</td><td>3汤匙</td></tr></tbody></table></div><p>腌料</p><div class="table-container"><table><thead><tr><th>配料</th><th>分量</th></tr></thead><tbody><tr><td>老抽</td><td>1汤匙</td></tr><tr><td>生抽</td><td>1汤匙</td></tr><tr><td>料酒</td><td>1汤匙</td></tr><tr><td>糖</td><td>2汤匙</td></tr><tr><td>芝麻香油</td><td>1茶匙</td></tr><tr><td>盐</td><td>1/4茶匙</td></tr><tr><td>胡椒粉</td><td>适量</td></tr></tbody></table></div><blockquote><p>汤匙：15mL，茶匙：5mL</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>鸡腿洗净切几刀，便于入味</li><li>腌料拌匀，研制入味，冷藏半天或者一夜</li><li>电饭锅底铺上洋葱丝、小葱、姜片，水</li><li>放入腌制好的鸡腿，倒入腌制的汁</li><li>铺均匀后按下煮饭按钮，40分钟</li><li>中间20分钟翻动一次</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>倒入腌鸡腿的汁后不用加水了，因为洋葱也会出很多的水</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「吃顿好的」第一道菜，【快手菜】电饭锅焖鸡腿。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="吃顿好的" scheme="http://houmin.cc/categories/%E5%90%83%E9%A1%BF%E5%A5%BD%E7%9A%84/"/>
    
    
      <category term="下厨房" scheme="http://houmin.cc/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>Project Ocean</title>
    <link href="http://houmin.cc/posts/f7bd8265/"/>
    <id>http://houmin.cc/posts/f7bd8265/</id>
    <published>2020-07-26T13:10:19.000Z</published>
    <updated>2020-08-21T08:11:30.076Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>千年以来人们一直梦想有一个世界级的图书馆，在这个图书馆里能够存放世界上所有出版过的印刷在纸上的知识。可以预见，如果是实体的图书馆这种想法将很难实现。但是，随着信息化时代的到来，全世界所有知识的电子化是可以实现的。Google在2002年就启动了一个「Project Ocean」计划，用以扫描所有的图书，建立一个统一的世界数字图书馆。</p><p>然而，经过十年的发展，这个计划却最终在一阵喧嚣中戛然而止。这里是「朝花夕拾」第二十一期，本期话题来自于最近听的「Blow Your Mind」的一期播客。</p><a id="more"></a><h2 id="雄心勃勃的计划"><a href="#雄心勃勃的计划" class="headerlink" title="雄心勃勃的计划"></a>雄心勃勃的计划</h2><p>从工程师的角度来说，这个计划毋庸置疑是一个雄心勃勃的伟大的计划。如果这件事情做成了，这将是留给人类的一个伟大礼物。2000年后出版的图书是可以直接电子化的，问题在于将之前存在的纸质的图书电子化。人类的知识有几千年的历史，而书籍中承载的可能是其中质量最高的部分。</p><p>然而，这么多的知识中，很大的一部分都深藏在世界上各大图书馆深深的房间中，很少有人能够访问。设想一下，如果这些积累了千年的知识电子化后，人们通过浏览器就可以搜索到对应的知识，这将有多么的大的裨益。</p><h2 id="技术的问题"><a href="#技术的问题" class="headerlink" title="技术的问题"></a>技术的问题</h2><ul><li>首先我们需要知道，有多少本书需要电子化。在2010年8月，也就是10年前，谷歌在博客中发了一条消息，说全世界总共有<code>129864880</code>册图书。这里主要是英文图书，如果算上其他文字的，还是在亿这个量级。</li><li>第二个问题，如何电子化。Google给的方法是扫描，他们研发了一套专门的扫描系统，每台仪器一小时可以数字化1000页左右的图书。</li></ul><blockquote><p>待扫描的书会被放在一个特别设计的自动支架上，支架可以适应不同的书脊，并且将图书固定。仪器上方有一排灯，还有价值至少1000美元的光学器材，包括四个摄像头，两个分别照着摊开的书的左右两半，还有一个负责确定扫描范围的光学雷达，它会在图书表面生成一层激光网格，从而捕捉到纸页的曲度。操作员负责手动翻页，因为也没有机器能比得上人手的快捷和轻柔了，然后脚踩踏板来触发相机进行拍照，一系列动作仿佛是在弹一架奇怪的钢琴。</p></blockquote><ul><li>是的，这个系统还是需要人来翻页的，因为也没有机器能比得上人手的快捷和轻柔了。</li><li>第三个问题，扫描后如何将这些扫描的照片转化为文字，识别书籍中的插图和图表、提取页码、把脚注转化为引用、将所有的书籍形成网络，形成一个知识库。这个就更多的是OCR和NLP等研究的领域。</li></ul><p>其实，Google并不是第一个产生这个想法，密歇根大学早就开始了其700万册图书馆藏数字化的计划。按照他们的计划，700万册图书需要1000年，而Google告诉他们，同样的事情，他们只需要六年。</p><blockquote><p>Google给密歇根大学图书馆提议：图书馆将所有的书借给谷歌，谷歌来替对方完成全部的扫描。最后你能得到你的全部馆藏的电子版，而谷歌将获得海量的还不曾被人问津的数据资源。布林如此描述谷歌对图书馆藏的渴望，“人类的知识有几千年的历史，而书籍中承载的可能是其中质量最高的部分。”试想如果所有被尘封在纸页间的知识能够进入搜索引擎？</p><p>早在2004年之前，谷歌就开始了扫描工作。之后，谷歌和密歇根大学、哈佛、斯坦福、牛津、纽约公共图书馆和许多其他图书馆系统都订立了合约，并且以超过佩吉预言的速度，在十年多一点的时间里扫描了大约<strong>2500万册图书</strong>。图书扫描工作花掉了谷歌大约4亿美元。这项工作不仅仅依靠技术，还依靠强大的物流支持。</p></blockquote><ul><li>因为有的图书比较古老，在扫描过程中可能会出现错误。谷歌提出了一个机智的<a href="https://en.wikipedia.org/wiki/ReCAPTCHA" target="_blank" rel="external nofollow noopener noreferrer">ReCAPTCHA</a>计划用于解决在扫描中发现的错误。其基本思路是，为了验证人类所输入的文字是正确的，而不是随意输入，有两个字会被显示出来；一个是光学文字识别软件无法辨别的字，另一个是一个已经知道正确答案的字。如果用户正确的回答出已知正确答案的字，那么就假设所输入的另一个光学识别软件无法识别的字是认真的查看后被输入而非随便输入。</li></ul><h2 id="人的问题"><a href="#人的问题" class="headerlink" title="人的问题"></a>人的问题</h2><p>经过10年的时间，Google已经扫描了2500万册的图书，这是他们之前预计的图书总量五分之一。然而，在这个过程中，逐渐出现了很多反对的声音，并最终导致了这个项目的终止。</p><ul><li><p>美国作家协会和出版商对Google提出了集体诉讼，<strong>指控谷歌大规模侵犯知识产权</strong>，毕竟他们才有图书的版权。</p></li><li><p>Google则认为他们的目标是为了让用户能够检索图书，对于那些有版权的书，谷歌只能显示图书的片段，搜索结果中只能显示你搜索到的条目前后的几句话。Google认为他们只是制作了图书的副本，属于对于图书的合理使用。</p></li><li><p>事实上，这种版权问题早就发生在唱片、广播、有线电视等传统出版商身上，并不是版权所有者想要打压新技术，相反他们是想从新技术中分一杯羹。</p></li><li><p>随着诉讼的进展，出版商发现，他们实际上并不想阻止Google扫描绝版图书，甚至鼓励这种行为。</p></li><li><p>于是在这个过程中，Google，作家，出版商，图书馆四方进行了妥协，形成了「谷歌图书搜索修正协议」</p><ul><li>协议要求谷歌支付1亿2500万美元，其中包括一次性支付给它已经扫描过的图书的版权方的4500万美元（大约按每本书60美元计算），分别向出版商和作者支付的1550万美元和3000万美元诉讼费，以及用来创立图书版权登记处的3450万美元。</li><li>这项协议中也规定了到底应该如何展示和出售这些重获新生的绝版图书。按照协议，谷歌可以展示该书至多20%的部分来诱使用户购买，谷歌可以出售可下载的电子版，价格则由算法或者版权所有者来确定，由1.99美元到29.99美元不等。所有绝版书都会被打包存进一个“机构订阅数据库”，大学可以买下这个数据库，供全校师生免费搜索和阅读里面的全部书籍。</li><li>这个解决方案像是一个三赢——图书馆可以得到成千上万的图书，谷歌在图书搜索服务上的投资没有白费，作者和出版商能够从已经毫无商业价值的书中获得一笔新的收入来源。</li></ul></li><li><p>但是这个「谷歌图书搜索修正协议」引起了更大的争议</p><ul><li><p>学校的教授们担心发生在学术期刊市场的事情会在谷歌图书的数据库上重演，一旦图书馆和学校对订购谷歌的数据库产生依赖，订购价格将会像高利贷一样暴涨，最终涨的和各路学术期刊一样高</p></li><li><p>Google的竞争对手也觉得收到了这份协议的威胁。</p><ul><li><blockquote><p>微软公司就不出所料地声称，如果谷歌是唯一一个可以合法地检索绝版图书的搜索引擎，这无疑会强化谷歌在全世界作为搜索引擎霸主的地位。如果谷歌利用这些绝版图书来满足用户的长尾需求，这将是一个对于其他公司来说很不公平的竞争优势。</p></blockquote></li></ul></li></ul></li></ul><pre><code>- &gt;   &gt;  &gt; 亚马逊公司则担心这项协议会让谷歌建立一个无可匹敌的图书商店。亚马逊认为，任何想要出售绝版图书的人，都必须要一本一本地确认图书版权，这是最好的，但是集体诉讼的协议却让谷歌一次性获得了所有图书的授权。</code></pre><p>  随着一轮又一轮的诉讼与协议，现在的状态是，Google基本尘封了这个计划。之前扫描的这2500万册图书以50PB的大小的文件存在于硬盘上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.thepaper.cn/newsDetail_forward_1679335" target="_blank" rel="external nofollow noopener noreferrer">https://www.thepaper.cn/newsDetail_forward_1679335</a></li><li><a href="https://www.theatlantic.com/technology/archive/2017/04/the-tragedy-of-google-books/523320/" target="_blank" rel="external nofollow noopener noreferrer">Torching the Modern-Day Library of Alexandria</a></li><li>Blow Your Mind</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;千年以来人们一直梦想有一个世界级的图书馆，在这个图书馆里能够存放世界上所有出版过的印刷在纸上的知识。可以预见，如果是实体的图书馆这种想法将很难实现。但是，随着信息化时代的到来，全世界所有知识的电子化是可以实现的。Google在2002年就启动了一个「Project Ocean」计划，用以扫描所有的图书，建立一个统一的世界数字图书馆。&lt;/p&gt;
&lt;p&gt;然而，经过十年的发展，这个计划却最终在一阵喧嚣中戛然而止。这里是「朝花夕拾」第二十一期，本期话题来自于最近听的「Blow Your Mind」的一期播客。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-26_google-books.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="google" scheme="http://houmin.cc/tags/google/"/>
    
      <category term="图书" scheme="http://houmin.cc/tags/%E5%9B%BE%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】String</title>
    <link href="http://houmin.cc/posts/e87a4e07/"/>
    <id>http://houmin.cc/posts/e87a4e07/</id>
    <published>2020-07-26T04:12:31.000Z</published>
    <updated>2020-08-16T15:03:05.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>字符串是 Go 语言中最常用的基础数据类型之一，虽然字符串往往被看做一个整体，但是实际上字符串是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，在这一节中就会详细介绍字符串的实现原理、相关转换过程以及常见操作的实现。</p><a id="more"></a><p>字符串虽然在 Go 语言中是基本类型 <code>string</code>，但是它实际上是由字符组成的数组，C 语言中的字符串就使用字符数组 <code>char[]</code> 表示，作为数组会占用一片连续的内存空间，这片内存空间存储了的字节共同组成了字符串，Go 语言中的字符串其实是一个只读的字节数组，下图展示了 <code>&quot;hello&quot;</code> 字符串在内存中的存储方式：</p><p><img alt="in-memory-string" data-src="https://img.draveness.me/2019-12-31-15777265631608-in-memory-string.png"></p><p><strong>图 3-18 内存中的字符串</strong></p><p>如果是代码中存在的字符串，会在编译期间被标记成只读数据 <code>SRODATA</code> 符号，假设我们有以下的一段代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 <code>hello</code> 字符串有一个 <code>SRODATA</code> 的标记：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">str := <span class="string">"hello"</span></span><br><span class="line">println([]byte(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOOS=linux GOARCH=amd64 go tool compile -S main.go</span><br><span class="line">...</span><br><span class="line">go.string.<span class="string">"hello"</span> SRODATA dupok size=5</span><br><span class="line">0x0000 68 65 6c 6c 6f                                   hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>只读只意味着字符串会分配到只读的内存空间并且这块内存不会被修改，但是在运行时我们其实还是可以将这段内存拷贝到堆或者栈上，将变量的类型转换成 <code>[]byte</code> 之后就可以进行，修改后通过类型转换就可以变回 <code>string</code>，Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>字符串在 Go 语言中的接口其实非常简单，每一个字符串在运行时都会使用如下的 <code>StringHeader</code> 结构体表示，在运行时包的内部其实有一个私有的结构 <code>stringHeader</code>，它有着完全相同的结构只是用于存储数据的 <code>Data</code> 字段使用了 <code>unsafe.Pointer</code> 类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会经常会说字符串是一个只读的<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/" target="_blank" rel="external nofollow noopener noreferrer">切片</a>类型，这是因为切片在 Go 语言的运行时表示与字符串高度相似：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与切片的结构体相比，字符串少了一个表示容量的 <code>Cap</code> 字段，因为字符串作为只读的类型，我们并不会直接向字符串直接追加元素改变其本身的内存空间，所有在字符串上执行的写入操作实际都是通过拷贝实现的。</p><h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>字符串的解析一定是解析器在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/" target="_blank" rel="external nofollow noopener noreferrer">词法分析</a>时就完成的，词法分析阶段会对源文件中的字符串进行切片和分组，将原有无意义的字符流转换成 Token 序列，在 Go 语言中，有两种字面量方式可以声明一个字符串，一种是使用双引号，另一种是使用反引号:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">"this is a string"</span></span><br><span class="line">str2 := <span class="string">`this is another </span></span><br><span class="line"><span class="string">string`</span></span><br></pre></td></tr></table></figure><p>使用双引号声明的字符串和其他语言中的字符串没有太多的区别，它只能用于单行字符串的初始化，如果字符串内部出现双引号，需要使用 <code>\</code> 符号避免编译器的解析错误，而反引号声明的字符串就可以摆脱单行的限制，因为双引号不再负责标记字符串的开始和结束，我们可以在字符串内部直接使用 <code>&quot;</code>，在遇到需要手写 JSON 或者其他复杂数据格式的场景下非常方便。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json := <span class="string">`&#123;"author": "draven", "tags": ["golang"]&#125;`</span></span><br></pre></td></tr></table></figure><p>两种不同的声明方式其实也意味着 Go 语言的编译器需要在解析的阶段能够区分并且正确解析这两种不同的字符串格式，解析字符串使用的 <code>scanner</code> 扫描器，它的功能就是将输入的字符流转换成 Token 流，<a href="https://github.com/golang/go/blob/cdd2c265cc132a15e20298fbb083a70d7f3b495d/src/cmd/compile/internal/syntax/scanner.go#L641-L669" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/syntax.scanner.stdString</code></a> 方法就是它用来解析使用双引号包裹的标准字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scanner)</span> <span class="title">stdString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s.startLit()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">r := s.getr()</span><br><span class="line"><span class="keyword">if</span> r == <span class="string">'"'</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r == <span class="string">'\\'</span> &#123;</span><br><span class="line">s.escape(<span class="string">'"'</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r == <span class="string">'\n'</span> &#123;</span><br><span class="line">s.ungetr()</span><br><span class="line">s.error(<span class="string">"newline in string"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r &lt; <span class="number">0</span> &#123;</span><br><span class="line">s.errh(s.line, s.col, <span class="string">"string not terminated"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">s.nlsemi = <span class="literal">true</span></span><br><span class="line">s.lit = <span class="keyword">string</span>(s.stopLit())</span><br><span class="line">s.kind = StringLit</span><br><span class="line">s.tok = _Literal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法的实现我们能分析出 Go 语言处理标准字符串的逻辑：</p><ol><li>标准字符串使用双引号表示开头和结尾；</li><li>标准字符串中需要使用反斜杠 <code>\</code> 来 <code>escape</code> 双引号；</li><li>标准字符串中不能出现如下所示的隐式换行符号 <code>\n</code>；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"start</span></span><br><span class="line"><span class="string">end"</span></span><br></pre></td></tr></table></figure><p>使用反引号声明的原始字符串的解析规则就非常简单了，<a href="https://github.com/golang/go/blob/cdd2c265cc132a15e20298fbb083a70d7f3b495d/src/cmd/compile/internal/syntax/scanner.go#L671-L693" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/syntax.scanner.rawString</code></a> 会将非反引号的所有字符都划分到当前字符串的范围中，所以我们可以使用它来支持复杂的多行字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scanner)</span> <span class="title">rawString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s.startLit()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">r := s.getr()</span><br><span class="line"><span class="keyword">if</span> r == <span class="string">'`'</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r &lt; <span class="number">0</span> &#123;</span><br><span class="line">s.errh(s.line, s.col, <span class="string">"string not terminated"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">s.nlsemi = <span class="literal">true</span></span><br><span class="line">s.lit = <span class="keyword">string</span>(s.stopLit())</span><br><span class="line">s.kind = StringLit</span><br><span class="line">s.tok = _Literal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是标准字符串还是原始字符串最终都会被标记成 <code>StringLit</code> 类型的 Token 并传递到编译的下一个阶段 — <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/" target="_blank" rel="external nofollow noopener noreferrer">语法分析</a>，在语法分析阶段，与字符串相关的表达式都会使用如下的方法 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/noder.go#L1349-L1408" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.noder.basicLit</code></a> 处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *noder)</span> <span class="title">basicLit</span><span class="params">(lit *syntax.BasicLit)</span> <span class="title">Val</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s := lit.Value; lit.Kind &#123;</span><br><span class="line"><span class="keyword">case</span> syntax.StringLit:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'`'</span> &#123;</span><br><span class="line">s = strings.Replace(s, <span class="string">"\r"</span>, <span class="string">""</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">u, _ := strconv.Unquote(s)</span><br><span class="line"><span class="keyword">return</span> Val&#123;U: u&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是 <code>import</code> 语句中包的路径、结构体中的字段标签还是表达式中的字符串都会使用这个方法将原生字符串中最后的换行符删除并对字符串 Token 进行 Unquote，也就是去掉字符串两遍的引号等无关干扰，还原其本来的面目。</p><p><code>strconv.Unquote</code> 方法处理了很多边界条件导致整个函数非常复杂，不仅包括各种不同引号的处理，还包括 UTF-8 等编码的相关问题，所以在这里也就不展开介绍了。</p><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><p>Go 语言拼接字符串会使用 <code>+</code> 符号，编译器会将该符号对应的 <code>OADD</code> 节点转换成 <code>OADDSTR</code> 类型的节点，随后在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中调用 <a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2528-L2586" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.addstr</code></a> 函数生成用于拼接字符串的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> OADDSTR:</span><br><span class="line">n = addstr(n, init)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2528-L2586" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.addstr</code></a> 函数能帮助我们在编译期间选择合适的函数对字符串进行拼接，如果需要拼接的字符串小于或者等于 5 个，那么就会直接调用 <code>concatstring{2,3,4,5}</code> 等一系列函数，如果超过 5 个就会直接选择 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L23-L55" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.concatstrings</code></a> 传入一个数组切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addstr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">c := n.List.Len()</span><br><span class="line"></span><br><span class="line">buf := nodnil()</span><br><span class="line">args := []*Node&#123;buf&#125;</span><br><span class="line"><span class="keyword">for</span> _, n2 := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">args = <span class="built_in">append</span>(args, conv(n2, types.Types[TSTRING]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> c &lt;= <span class="number">5</span> &#123;</span><br><span class="line">fn = fmt.Sprintf(<span class="string">"concatstring%d"</span>, c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fn = <span class="string">"concatstrings"</span></span><br><span class="line"></span><br><span class="line">t := types.NewSlice(types.Types[TSTRING])</span><br><span class="line">slice := nod(OCOMPLIT, <span class="literal">nil</span>, typenod(t))</span><br><span class="line">slice.List.Set(args[<span class="number">1</span>:])</span><br><span class="line">args = []*Node&#123;buf, slice&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cat := syslook(fn)</span><br><span class="line">r := nod(OCALL, cat, <span class="literal">nil</span>)</span><br><span class="line">r.List.Set(args)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实无论使用 <code>concatstring{2,3,4,5}</code> 中的哪一个，最终都会调用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L23-L55" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.concatstrings</code></a>，该函数会先对传入的切片参数进行遍历，先过滤空字符串并计算拼接后字符串的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstrings</span><span class="params">(buf *tmpBuf, a []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line">l := <span class="number">0</span></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">n := <span class="built_in">len</span>(x)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">l += n</span><br><span class="line">count++</span><br><span class="line">idx = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">1</span> &amp;&amp; (buf != <span class="literal">nil</span> || !stringDataOnStack(a[idx])) &#123;</span><br><span class="line"><span class="keyword">return</span> a[idx]</span><br><span class="line">&#125;</span><br><span class="line">s, b := rawstringtmp(buf, l)</span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="built_in">copy</span>(b, x)</span><br><span class="line">b = b[<span class="built_in">len</span>(x):]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果非空字符串的数量为 1 并且当前的字符串不在栈上就可以直接返回该字符串，不需要进行额外的任何操作。</p><p><img alt="string-concat-and-copy" data-src="https://img.draveness.me/2019-12-31-15777265631620-string-concat-and-copy.png"></p><p><strong>图 3-19 字符串的拼接和拷贝</strong></p><p>但是在正常情况下，运行时会调用 <code>copy</code> 将输入的多个字符串拷贝到目标字符串所在的内存空间中，新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失就是无法忽略的。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>当我们使用 Go 语言解析和序列化 JSON 等数据格式时，经常需要将数据在 <code>string</code> 和 <code>[]byte</code> 之间来回转换，类型转换的开销并没有想象的那么小，我们经常会看到 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L75-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.slicebytetostring</code></a> 等函数出现在火焰图<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>中，成为程序的性能热点。</p><p>从字节数组到字符串的转换就需要使用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L75-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.slicebytetostring</code></a> 函数，例如：<code>string(bytes)</code>，该函数在函数体中会先处理两种比较常见的情况，也就是字节数组的长度为 0 或者 1，这两个情况处理起来都非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostring</span><span class="params">(buf *tmpBuf, b []<span class="keyword">byte</span>)</span> <span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">l := <span class="built_in">len</span>(b)</span><br><span class="line"><span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="number">0</span>]])</span><br><span class="line">stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(b) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">p = unsafe.Pointer(buf)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = mallocgc(<span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">stringStructOf(&amp;str).str = p</span><br><span class="line">stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="built_in">len</span>(b)</span><br><span class="line">memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理过后会根据传入的缓冲区大小决定是否需要为新的字符串分配一片内存空间，<a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L229-L231" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.stringStructOf</code></a> 会将传入的字符串指针转换成 <code>stringStruct</code> 结构体指针，然后设置结构体持有的字符串指针 <code>str</code> 和长度 <code>len</code>，最后通过 <code>memmove</code> 将原 <code>[]byte</code> 中的字节全部复制到新的内存空间中。</p><p>当我们想要将字符串转换成 <code>[]byte</code> 类型时，就需要使用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L155-L165" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.stringtoslicebyte</code></a> 函数，该函数的实现非常容易理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">*buf = tmpBuf&#123;&#125;</span><br><span class="line">b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(b, s)</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果向该函数传入了缓冲区，那么它会使用传入的缓冲区存储 <code>[]byte</code>，没有传入缓冲区时，运行时会调用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L270-L279" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.rawbyteslice</code></a> 创建一个新的字节切片，<code>copy</code> 就会将字符串中的内容拷贝到新的 <code>[]byte</code> 中。</p><p><img alt="string-bytes-conversion" data-src="https://img.draveness.me/2019-12-31-15777265631625-string-bytes-conversion.png"></p><p><strong>图 3-20 字符串和字节数组的转换</strong></p><p>字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，我们不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的，无论从哪种类型转换到另一种都需要对其中的内容进行拷贝，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>字符串是 Go 语言中相对来说比较简单的一种数据结构，我们在这一节中详细分析了字符串与 <code>[]byte</code> 类型的关系，从词法分析阶段理解字符串是如何被解析的，作为只读的数据类型，我们无法改变其本身的结构，但是在做拼接和类型转换等操作时时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://go101.org/article/string.html" target="_blank" rel="external nofollow noopener noreferrer">Strings in Go</a></li><li><a href="https://blog.golang.org/strings" target="_blank" rel="external nofollow noopener noreferrer">Strings, bytes, runes and characters in Go</a></li><li><a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="external nofollow noopener noreferrer">UTF-8 · Wikipedia</a></li><li><a href="https://stackoverflow.com/questions/29255746/how-encode-rune-into-byte-using-utf8-in-golang" target="_blank" rel="external nofollow noopener noreferrer">How encode []rune into []byte using utf8 in golang?</a></li><li><a href="https://golang.org/ref/spec#Conversions_to_and_from_a_string_type" target="_blank" rel="external nofollow noopener noreferrer">Conversions to and from a string type</a></li><li><a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="external nofollow noopener noreferrer">十分钟搞清字符集和字符编码</a></li></ul><hr><ol><li>火焰图是一种分析程序性能的手段，Flame Graphs <a href="http://www.brendangregg.com/flamegraphs.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.brendangregg.com/flamegraphs.html</a> <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/#fnref:1" target="_blank" rel="external nofollow noopener noreferrer">↩︎</a></li></ol><hr><p>在Go里面，字符串实际上是类型为byte的只读切片。</p><p>一个字符串包含了任意个byte。它并不限定Unicode，UTF-8或者任何其他预定义的编码。在内容上，它完全等价于一个类型为byte的切片。</p><p>下面是一个字符串变量，它使用\xNN这样的形式来表示一些特殊的byte。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sample = <span class="string">"\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98"</span></span><br><span class="line">fmt.Println(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ��=� ⌘  </span></span><br><span class="line"><span class="comment">// 这个结果和程序执行的环境有关</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="built_in">len</span>(sample); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%x "</span>, sample[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bd b2 3d bc 20 e2 8c 98</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bdb23dbc20e28c98</span></span><br><span class="line">fmt.Printf(<span class="string">"% x\n"</span>, sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bd b2 3d bc 20 e2 8c 98</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// \xbd\xb2=\xbc ⌘</span></span><br><span class="line">fmt.Printf(<span class="string">"%+q\n"</span>, sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// "\xbd\xb2=\xbc \u2318"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> placeOfInterest = <span class="string">`⌘`</span></span><br><span class="line">    fmt.Printf(<span class="string">"plain string: "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%s"</span>, placeOfInterest)</span><br><span class="line">    fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"quoted string: "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+q"</span>, placeOfInterest)</span><br><span class="line">    fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"hex bytes: "</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(placeOfInterest); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%x "</span>, placeOfInterest[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plain string: ⌘</span></span><br><span class="line"><span class="comment">// quoted string: "\u2318"</span></span><br><span class="line"><span class="comment">// hex bytes: e2 8c 98</span></span><br><span class="line"><span class="keyword">const</span> nihongo = <span class="string">"日本語"</span></span><br><span class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> nihongo &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// U+65E5 '日' starts at byte position 0</span></span><br><span class="line"><span class="comment">// U+672C '本' starts at byte position 3</span></span><br><span class="line"><span class="comment">// U+8A9E '語' starts at byte position 6</span></span><br><span class="line"></span><br><span class="line">s = u<span class="string">"你好，中国"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))   # <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])     # 打印<span class="string">'好'</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"你好，中国"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))   # <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])     # 打印的不是<span class="string">'好'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"hello，中国"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    r[<span class="number">6</span>] = <span class="string">'美'</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(r))</span><br><span class="line"></span><br><span class="line">    e := <span class="keyword">string</span>(r)</span><br><span class="line">    fmt.Println(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 14</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// hello，美国</span></span><br></pre></td></tr></table></figure><p>关于Unicode，UTF-8和多语言文本处理，还有很多可以聊的。现在，我们希望您已经更好地了解Go字符串，尽管它们可能包含任意字节，但UTF-8是其设计的核心。</p><p>回答文章刚开始时提出的问题：字符串是由字节构建的，所以索引它们返回字节，而不是字符。字符串甚至可能不包含字符。事实上，“字符”的定义是不明确的，尝试通过定义字符串由字符组成来解决歧义是一个错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于上面的例子也可以看到，需要统计中文字符串长度时，也需要转换成对应的rune数组</p><p>因此必须先将字符串转换成字节数组(或者rune数组，对于中文等)，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式。</p><p>因为Go 语言中的字符串是不可变的，也就是说 str[index] 这样的表达式是不可以被放在等号左侧的。如果尝试运行 str[i] = ‘D’会得到错误：cannot assign to str[i]。</p><p>字符串的本质就是一个字节数组。在Go 语言里面字符串和字节数组可以相互进行显式转换，这一性质通常被用来“修改”字符串的内容。</p><p>同样我们知道string[index]获取的是字符byte,就无法像Python中通过加u前缀之后直接索引，在Go中需要将字符串转换成rune数组，runne数组中就可以通过数组下标获取一个汉字所标识的Unicode码，再将Unicode码按创建成字符串即可。</p><p>分析Python代码，我们可以看到，字符串前面加了u标识符，表示按照unicode方式索引，否则默认情况下按照索引得到的是字节索引(unicode下面中文用三个字节表示)。</p><p>编码过程中避免不了中文字符，那我们该如何提取一个中文呢？ 在Python中，我们有：</p><h2 id="中文字符相关"><a href="#中文字符相关" class="headerlink" title="中文字符相关"></a>中文字符相关</h2><p>下面是一个使用<code>%#U</code>格式化的例子，它显示了代码点的Unicode值及其打印的表现形式。</p><p>而一个range循环会在每次迭代时，解码一个UTF-8编码的符文。每次循环时，循环的索引是当前文字的起始位置，以字节为单位，代码点是它的值。</p><p>除了Go源码是UTF-8外，Go只提供一种方法特殊处理UTF-8，那就是在字符串上使用for range循环。我们已经知道使用for循环会发生什么了。</p><h2 id="range循环"><a href="#range循环" class="headerlink" title="range循环"></a>range循环</h2><ul><li>Go源码总是UTF-8</li><li>一个字符串包含任意个byte</li><li>字符串常量如果缺少字节级转义，将始终保持UTF-8序列。</li><li>Unicode的代码点在Go语言中被称为rune</li><li>Go不保证字符串中的字符是规范化的。</li></ul><p>总结一些前面的内容：</p><p>Go语言将rune定义为int32类型的别名，因此在使用一个整型值表达一个“代码点”时，代码更加清晰。此外，一个你可能认为是字符常数在Go中是符文常数。’⌘’的类型和值分别是rune和0x2318。</p><p>“代码点”这样的说法有点绕口，所以Go语言介绍了一个较短的术语概念：rune，符文。该术语出现字库和源代码中，和“代码点”表达的意思完全相同。还有一个有趣的补充。</p><p>因此，计算中的字符概念是模糊的，至少是混乱的，所以我们需要谨慎地使用它。有规范化的技术来保证字符和代码点的映射，不过这个领域和本文讨论的内容相去甚远。</p><p>举一个更普遍的例子，Unicode代码点U+0061表示小写拉丁字母’A’：a。但是小写的重音字母’A’: à怎么表示呢？这是一个字符，它可以用代码点U+00E0表示，但也有其它表示。例如，可以“组合”严重重音代码点U+0300，并将其附加到小写字母a，U+0061，以创建字符à。通常情况下，字符可以由多个不同的代码点序列表示，由此可以用不同的UTF-8字节序列表示。</p><p>我们一直非常小心地使用“字节”和“字符”这样说法。这部分是因为字符串中保存了字节，还有部分是因为“字符”的概念有点难以定义。Unicode标准使用术语“代码点”来用单个值表示一个字符。比如具有16进制值2318的代码点，U+2318表示符号⌘。</p><h2 id="字节点，字符和rune"><a href="#字节点，字符和rune" class="headerlink" title="字节点，字符和rune"></a>字节点，字符和rune</h2><p>总而言之，字符串可以包含任意字节，但是当从字符串文字构造时，这些字节（几乎总是）是UTF-8。</p><p>有些人认为Go字符串总是UTF-8，但是不是这样：只有字符串字面量是UTF-8。正如上面所示，字符串值可以包含任意字节，只要没有字节级转义，字符串文字总是包含UTF-8文本。</p><p>简单来说，Go源码是UTF-8，因此字符串文字的源代码是UTF-8文本。如果该字符串文字不包含转义序列，构造的字符串将精确保存引号之间的源文本。因此，通过定义和构造，原始字符串将总是包含其内容的有效UTF-8表示。类似的，除非它包含类似上面例子中的UTF-8拆分转义，否则常规字符串字面值也将始终包含有效的UTF-8。</p><p>Go语言中的源代码定义为UTF-8文本，不允许其他的表示。也就是说，在代码中写下字符<code>⌘</code>时，用于创建程序的文本编辑器将符号⌘的UTF-8编码放入源文本中。当打印16进制字节时，我们只是将文件中的数据打印出来。</p><p>上面的例子告诉我们，Unicode字符值U+2318，名胜古迹符号”⌘”的字节表示为”e2 8c 98”，这些字节是16进制值”2318”的UTF-8编码。</p><p>下面的程序用三种不同的方式打印一个字符串常量，一次作为纯字符串，一次作为只有ASCII的字符串，一次作为16进制的字节。为了避免混淆，创建一个“原始字符串”，用反括号括起来，因此它只包含文本。</p><p>正如我们看到的，索引一个字符串返回的是byte，而不是字符：一个字符串就是一堆字节。这意味着，当我们将字符存储在字符串中时，实际存储的是这个字符的字节。来看一个例子。</p><h2 id="UTF-8和字符串"><a href="#UTF-8和字符串" class="headerlink" title="UTF-8和字符串"></a>UTF-8和字符串</h2><p>这些打印的小技巧在调试字符串内容的时候很有用，并且会方便下面的讨论。值得注意的是，上面的小技巧对于byte的切片一样适用。</p><p>如果不熟悉字符串中奇怪的字符，可以在打印的时候使用”+q”标识，这个标识采用UTF-8编码，它不仅会转义不可打印的字节序列，还会转义非ASCII码的字节。下面的代码将字符串中非ASCII数据对应的Unicode值打印出来。字符串中的瑞典字符作为Unicode字符，打印出来带有\u的转义符。</p><p>仔细观察，在一堆乱码中我们可以看到一个’=’号和一个空格符号，最后面是瑞典表示“名胜古迹”的符号，这个符号的Unicode值为U+2318，UTF-8编码为”e28c98”。</p><p>还有一些小技巧。使用q标识，可以将字符串中任何不可打印的字节序列转义。</p><p>还有一个打印的小技巧。</p><p>下面一种更简单的打印方式。</p><p>使用for循环遍历所有的字节。</p><p>要了解这个字符串究竟是什么，我们需要把它分开来检查一下。正如上面提到的，索引一个字符串，得到的是byte，而不是字符。</p><p>在上面的例子中，有一些byte并不是ASCII码，甚至也不是UTF-8编码，直接打印出来会出现乱码</p><h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串是 Go 语言中最常用的基础数据类型之一，虽然字符串往往被看做一个整体，但是实际上字符串是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，在这一节中就会详细介绍字符串的实现原理、相关转换过程以及常见操作的实现。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://img.draveness.me/2019-12-31-15777265631608-in-memory-string.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="数据结构" scheme="http://houmin.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="String" scheme="http://houmin.cc/tags/String/"/>
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
</feed>
